"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name16 in all)
      __defProp(target, name16, { get: all[name16], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@vercel/oidc/dist/get-context.js
  var require_get_context = __commonJS({
    "node_modules/@vercel/oidc/dist/get-context.js"(exports, module) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name16 in all)
          __defProp3(target, name16, { get: all[name16], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var get_context_exports = {};
      __export3(get_context_exports, {
        SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
        getContext: () => getContext3
      });
      module.exports = __toCommonJS(get_context_exports);
      var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
      function getContext3() {
        const fromSymbol = globalThis;
        return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
      }
    }
  });

  // node_modules/@vercel/oidc/dist/index-browser.js
  var require_index_browser = __commonJS({
    "node_modules/@vercel/oidc/dist/index-browser.js"(exports, module) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name16 in all)
          __defProp3(target, name16, { get: all[name16], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var index_browser_exports = {};
      __export3(index_browser_exports, {
        getContext: () => import_get_context.getContext,
        getVercelOidcToken: () => getVercelOidcToken2,
        getVercelOidcTokenSync: () => getVercelOidcTokenSync
      });
      module.exports = __toCommonJS(index_browser_exports);
      var import_get_context = require_get_context();
      async function getVercelOidcToken2() {
        return "";
      }
      function getVercelOidcTokenSync() {
        return "";
      }
    }
  });

  // node_modules/@ai-sdk/provider/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@ai-sdk/provider/dist/index.js"(exports, module) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name143 in all)
          __defProp3(target, name143, { get: all[name143], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var src_exports = {};
      __export3(src_exports, {
        AISDKError: () => AISDKError2,
        APICallError: () => APICallError2,
        EmptyResponseBodyError: () => EmptyResponseBodyError2,
        InvalidArgumentError: () => InvalidArgumentError3,
        InvalidPromptError: () => InvalidPromptError2,
        InvalidResponseDataError: () => InvalidResponseDataError,
        JSONParseError: () => JSONParseError2,
        LoadAPIKeyError: () => LoadAPIKeyError,
        LoadSettingError: () => LoadSettingError,
        NoContentGeneratedError: () => NoContentGeneratedError,
        NoSuchModelError: () => NoSuchModelError,
        TooManyEmbeddingValuesForCallError: () => TooManyEmbeddingValuesForCallError,
        TypeValidationError: () => TypeValidationError2,
        UnsupportedFunctionalityError: () => UnsupportedFunctionalityError,
        getErrorMessage: () => getErrorMessage3,
        isJSONArray: () => isJSONArray,
        isJSONObject: () => isJSONObject,
        isJSONValue: () => isJSONValue
      });
      module.exports = __toCommonJS(src_exports);
      var marker17 = "vercel.ai.error";
      var symbol18 = Symbol.for(marker17);
      var _a17;
      var _AISDKError3 = class _AISDKError4 extends Error {
        /**
         * Creates an AI SDK Error.
         *
         * @param {Object} params - The parameters for creating the error.
         * @param {string} params.name - The name of the error.
         * @param {string} params.message - The error message.
         * @param {unknown} [params.cause] - The underlying cause of the error.
         */
        constructor({
          name: name143,
          message,
          cause
        }) {
          super(message);
          this[_a17] = true;
          this.name = name143;
          this.cause = cause;
        }
        /**
         * Checks if the given error is an AI SDK Error.
         * @param {unknown} error - The error to check.
         * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
         */
        static isInstance(error46) {
          return _AISDKError4.hasMarker(error46, marker17);
        }
        static hasMarker(error46, marker153) {
          const markerSymbol = Symbol.for(marker153);
          return error46 != null && typeof error46 === "object" && markerSymbol in error46 && typeof error46[markerSymbol] === "boolean" && error46[markerSymbol] === true;
        }
      };
      _a17 = symbol18;
      var AISDKError2 = _AISDKError3;
      var name16 = "AI_APICallError";
      var marker24 = `vercel.ai.error.${name16}`;
      var symbol24 = Symbol.for(marker24);
      var _a24;
      var APICallError2 = class extends AISDKError2 {
        constructor({
          message,
          url: url2,
          requestBodyValues,
          statusCode,
          responseHeaders,
          responseBody,
          cause,
          isRetryable = statusCode != null && (statusCode === 408 || // request timeout
          statusCode === 409 || // conflict
          statusCode === 429 || // too many requests
          statusCode >= 500),
          // server error
          data
        }) {
          super({ name: name16, message, cause });
          this[_a24] = true;
          this.url = url2;
          this.requestBodyValues = requestBodyValues;
          this.statusCode = statusCode;
          this.responseHeaders = responseHeaders;
          this.responseBody = responseBody;
          this.isRetryable = isRetryable;
          this.data = data;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker24);
        }
      };
      _a24 = symbol24;
      var name24 = "AI_EmptyResponseBodyError";
      var marker34 = `vercel.ai.error.${name24}`;
      var symbol34 = Symbol.for(marker34);
      var _a34;
      var EmptyResponseBodyError2 = class extends AISDKError2 {
        // used in isInstance
        constructor({ message = "Empty response body" } = {}) {
          super({ name: name24, message });
          this[_a34] = true;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker34);
        }
      };
      _a34 = symbol34;
      function getErrorMessage3(error46) {
        if (error46 == null) {
          return "unknown error";
        }
        if (typeof error46 === "string") {
          return error46;
        }
        if (error46 instanceof Error) {
          return error46.message;
        }
        return JSON.stringify(error46);
      }
      var name34 = "AI_InvalidArgumentError";
      var marker44 = `vercel.ai.error.${name34}`;
      var symbol44 = Symbol.for(marker44);
      var _a44;
      var InvalidArgumentError3 = class extends AISDKError2 {
        constructor({
          message,
          cause,
          argument
        }) {
          super({ name: name34, message, cause });
          this[_a44] = true;
          this.argument = argument;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker44);
        }
      };
      _a44 = symbol44;
      var name44 = "AI_InvalidPromptError";
      var marker54 = `vercel.ai.error.${name44}`;
      var symbol54 = Symbol.for(marker54);
      var _a54;
      var InvalidPromptError2 = class extends AISDKError2 {
        constructor({
          prompt,
          message,
          cause
        }) {
          super({ name: name44, message: `Invalid prompt: ${message}`, cause });
          this[_a54] = true;
          this.prompt = prompt;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker54);
        }
      };
      _a54 = symbol54;
      var name54 = "AI_InvalidResponseDataError";
      var marker64 = `vercel.ai.error.${name54}`;
      var symbol64 = Symbol.for(marker64);
      var _a64;
      var InvalidResponseDataError = class extends AISDKError2 {
        constructor({
          data,
          message = `Invalid response data: ${JSON.stringify(data)}.`
        }) {
          super({ name: name54, message });
          this[_a64] = true;
          this.data = data;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker64);
        }
      };
      _a64 = symbol64;
      var name64 = "AI_JSONParseError";
      var marker74 = `vercel.ai.error.${name64}`;
      var symbol74 = Symbol.for(marker74);
      var _a74;
      var JSONParseError2 = class extends AISDKError2 {
        constructor({ text: text2, cause }) {
          super({
            name: name64,
            message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage3(cause)}`,
            cause
          });
          this[_a74] = true;
          this.text = text2;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker74);
        }
      };
      _a74 = symbol74;
      var name73 = "AI_LoadAPIKeyError";
      var marker83 = `vercel.ai.error.${name73}`;
      var symbol83 = Symbol.for(marker83);
      var _a83;
      var LoadAPIKeyError = class extends AISDKError2 {
        // used in isInstance
        constructor({ message }) {
          super({ name: name73, message });
          this[_a83] = true;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker83);
        }
      };
      _a83 = symbol83;
      var name83 = "AI_LoadSettingError";
      var marker93 = `vercel.ai.error.${name83}`;
      var symbol93 = Symbol.for(marker93);
      var _a93;
      var LoadSettingError = class extends AISDKError2 {
        // used in isInstance
        constructor({ message }) {
          super({ name: name83, message });
          this[_a93] = true;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker93);
        }
      };
      _a93 = symbol93;
      var name93 = "AI_NoContentGeneratedError";
      var marker103 = `vercel.ai.error.${name93}`;
      var symbol103 = Symbol.for(marker103);
      var _a103;
      var NoContentGeneratedError = class extends AISDKError2 {
        // used in isInstance
        constructor({
          message = "No content generated."
        } = {}) {
          super({ name: name93, message });
          this[_a103] = true;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker103);
        }
      };
      _a103 = symbol103;
      var name103 = "AI_NoSuchModelError";
      var marker113 = `vercel.ai.error.${name103}`;
      var symbol113 = Symbol.for(marker113);
      var _a113;
      var NoSuchModelError = class extends AISDKError2 {
        constructor({
          errorName = name103,
          modelId,
          modelType,
          message = `No such ${modelType}: ${modelId}`
        }) {
          super({ name: errorName, message });
          this[_a113] = true;
          this.modelId = modelId;
          this.modelType = modelType;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker113);
        }
      };
      _a113 = symbol113;
      var name113 = "AI_TooManyEmbeddingValuesForCallError";
      var marker123 = `vercel.ai.error.${name113}`;
      var symbol123 = Symbol.for(marker123);
      var _a123;
      var TooManyEmbeddingValuesForCallError = class extends AISDKError2 {
        constructor(options) {
          super({
            name: name113,
            message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
          });
          this[_a123] = true;
          this.provider = options.provider;
          this.modelId = options.modelId;
          this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
          this.values = options.values;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker123);
        }
      };
      _a123 = symbol123;
      var name123 = "AI_TypeValidationError";
      var marker133 = `vercel.ai.error.${name123}`;
      var symbol133 = Symbol.for(marker133);
      var _a133;
      var _TypeValidationError3 = class _TypeValidationError4 extends AISDKError2 {
        constructor({ value, cause }) {
          super({
            name: name123,
            message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
            cause
          });
          this[_a133] = true;
          this.value = value;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker133);
        }
        /**
         * Wraps an error into a TypeValidationError.
         * If the cause is already a TypeValidationError with the same value, it returns the cause.
         * Otherwise, it creates a new TypeValidationError.
         *
         * @param {Object} params - The parameters for wrapping the error.
         * @param {unknown} params.value - The value that failed validation.
         * @param {unknown} params.cause - The original error or cause of the validation failure.
         * @returns {TypeValidationError} A TypeValidationError instance.
         */
        static wrap({
          value,
          cause
        }) {
          return _TypeValidationError4.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError4({ value, cause });
        }
      };
      _a133 = symbol133;
      var TypeValidationError2 = _TypeValidationError3;
      var name133 = "AI_UnsupportedFunctionalityError";
      var marker143 = `vercel.ai.error.${name133}`;
      var symbol143 = Symbol.for(marker143);
      var _a143;
      var UnsupportedFunctionalityError = class extends AISDKError2 {
        constructor({
          functionality,
          message = `'${functionality}' functionality not supported.`
        }) {
          super({ name: name133, message });
          this[_a143] = true;
          this.functionality = functionality;
        }
        static isInstance(error46) {
          return AISDKError2.hasMarker(error46, marker143);
        }
      };
      _a143 = symbol143;
      function isJSONValue(value) {
        if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return true;
        }
        if (Array.isArray(value)) {
          return value.every(isJSONValue);
        }
        if (typeof value === "object") {
          return Object.entries(value).every(
            ([key, val]) => typeof key === "string" && isJSONValue(val)
          );
        }
        return false;
      }
      function isJSONArray(value) {
        return Array.isArray(value) && value.every(isJSONValue);
      }
      function isJSONObject(value) {
        return value != null && typeof value === "object" && Object.entries(value).every(
          ([key, val]) => typeof key === "string" && isJSONValue(val)
        );
      }
    }
  });

  // node_modules/@mediapipe/tasks-text/text_bundle.cjs
  var require_text_bundle = __commonJS({
    "node_modules/@mediapipe/tasks-text/text_bundle.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var t = "undefined" != typeof self ? self : {};
      function e() {
        throw Error("Invalid UTF8");
      }
      function n(t2, e2) {
        return e2 = String.fromCharCode.apply(null, e2), null == t2 ? e2 : t2 + e2;
      }
      var r;
      var i;
      var o = "undefined" != typeof TextDecoder;
      var s;
      var a = "undefined" != typeof TextEncoder;
      function u(t2) {
        if (a)
          t2 = (s ||= new TextEncoder()).encode(t2);
        else {
          let n2 = 0;
          const r2 = new Uint8Array(3 * t2.length);
          for (let i2 = 0; i2 < t2.length; i2++) {
            var e2 = t2.charCodeAt(i2);
            if (e2 < 128)
              r2[n2++] = e2;
            else {
              if (e2 < 2048)
                r2[n2++] = e2 >> 6 | 192;
              else {
                if (e2 >= 55296 && e2 <= 57343) {
                  if (e2 <= 56319 && i2 < t2.length) {
                    const o2 = t2.charCodeAt(++i2);
                    if (o2 >= 56320 && o2 <= 57343) {
                      e2 = 1024 * (e2 - 55296) + o2 - 56320 + 65536, r2[n2++] = e2 >> 18 | 240, r2[n2++] = e2 >> 12 & 63 | 128, r2[n2++] = e2 >> 6 & 63 | 128, r2[n2++] = 63 & e2 | 128;
                      continue;
                    }
                    i2--;
                  }
                  e2 = 65533;
                }
                r2[n2++] = e2 >> 12 | 224, r2[n2++] = e2 >> 6 & 63 | 128;
              }
              r2[n2++] = 63 & e2 | 128;
            }
          }
          t2 = n2 === r2.length ? r2 : r2.subarray(0, n2);
        }
        return t2;
      }
      var c;
      var l;
      t: {
        for (h = ["CLOSURE_FLAGS"], f = t, d = 0; d < h.length; d++)
          if (null == (f = f[h[d]])) {
            l = null;
            break t;
          }
        l = f;
      }
      var h;
      var f;
      var d;
      var g;
      var p = l && l[610401301];
      c = null != p && p;
      var m = t.navigator;
      function y(t2) {
        return !!c && (!!g && g.brands.some(({ brand: e2 }) => e2 && -1 != e2.indexOf(t2)));
      }
      function b(e2) {
        var n2;
        return (n2 = t.navigator) && (n2 = n2.userAgent) || (n2 = ""), -1 != n2.indexOf(e2);
      }
      function v() {
        return !!c && (!!g && g.brands.length > 0);
      }
      function w() {
        return v() ? y("Chromium") : (b("Chrome") || b("CriOS")) && !(!v() && b("Edge")) || b("Silk");
      }
      function _(t2) {
        return _[" "](t2), t2;
      }
      g = m && m.userAgentData || null, _[" "] = function() {
      };
      var S = !v() && (b("Trident") || b("MSIE"));
      !b("Android") || w(), w(), b("Safari") && (w() || !v() && b("Coast") || !v() && b("Opera") || !v() && b("Edge") || (v() ? y("Microsoft Edge") : b("Edg/")) || v() && y("Opera"));
      var A = {};
      var E = null;
      function I(t2) {
        const e2 = t2.length;
        let n2 = 3 * e2 / 4;
        n2 % 3 ? n2 = Math.floor(n2) : -1 != "=.".indexOf(t2[e2 - 1]) && (n2 = -1 != "=.".indexOf(t2[e2 - 2]) ? n2 - 2 : n2 - 1);
        const r2 = new Uint8Array(n2);
        let i2 = 0;
        return function(t3, e3) {
          function n3(e4) {
            for (; r3 < t3.length; ) {
              const e5 = t3.charAt(r3++), n4 = E[e5];
              if (null != n4)
                return n4;
              if (!/^[\s\xa0]*$/.test(e5))
                throw Error("Unknown base64 encoding at char: " + e5);
            }
            return e4;
          }
          T();
          let r3 = 0;
          for (; ; ) {
            const t4 = n3(-1), r4 = n3(0), i3 = n3(64), o2 = n3(64);
            if (64 === o2 && -1 === t4)
              break;
            e3(t4 << 2 | r4 >> 4), 64 != i3 && (e3(r4 << 4 & 240 | i3 >> 2), 64 != o2 && e3(i3 << 6 & 192 | o2));
          }
        }(t2, function(t3) {
          r2[i2++] = t3;
        }), i2 !== n2 ? r2.subarray(0, i2) : r2;
      }
      function T() {
        if (!E) {
          E = {};
          var t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e2 = ["+/=", "+/", "-_=", "-_.", "-_"];
          for (let n2 = 0; n2 < 5; n2++) {
            const r2 = t2.concat(e2[n2].split(""));
            A[n2] = r2;
            for (let t3 = 0; t3 < r2.length; t3++) {
              const e3 = r2[t3];
              void 0 === E[e3] && (E[e3] = t3);
            }
          }
        }
      }
      var x = "undefined" != typeof Uint8Array;
      var U = !S && "function" == typeof btoa;
      function P(t2) {
        if (!U) {
          var e2;
          void 0 === e2 && (e2 = 0), T(), e2 = A[e2];
          var n2 = Array(Math.floor(t2.length / 3)), r2 = e2[64] || "";
          let u2 = 0, c2 = 0;
          for (; u2 < t2.length - 2; u2 += 3) {
            var i2 = t2[u2], o2 = t2[u2 + 1], s2 = t2[u2 + 2], a2 = e2[i2 >> 2];
            i2 = e2[(3 & i2) << 4 | o2 >> 4], o2 = e2[(15 & o2) << 2 | s2 >> 6], s2 = e2[63 & s2], n2[c2++] = a2 + i2 + o2 + s2;
          }
          switch (a2 = 0, s2 = r2, t2.length - u2) {
            case 2:
              s2 = e2[(15 & (a2 = t2[u2 + 1])) << 2] || r2;
            case 1:
              t2 = t2[u2], n2[c2] = e2[t2 >> 2] + e2[(3 & t2) << 4 | a2 >> 4] + s2 + r2;
          }
          return n2.join("");
        }
        for (e2 = "", n2 = 0, r2 = t2.length - 10240; n2 < r2; )
          e2 += String.fromCharCode.apply(null, t2.subarray(n2, n2 += 10240));
        return e2 += String.fromCharCode.apply(null, n2 ? t2.subarray(n2) : t2), btoa(e2);
      }
      var B = /[-_.]/g;
      var L = { "-": "+", _: "/", ".": "=" };
      function O(t2) {
        return L[t2] || "";
      }
      function k(t2) {
        if (!U)
          return I(t2);
        B.test(t2) && (t2 = t2.replace(B, O)), t2 = atob(t2);
        const e2 = new Uint8Array(t2.length);
        for (let n2 = 0; n2 < t2.length; n2++)
          e2[n2] = t2.charCodeAt(n2);
        return e2;
      }
      function F(t2) {
        return x && null != t2 && t2 instanceof Uint8Array;
      }
      var N = {};
      function V() {
        return M ||= new C(null, N);
      }
      function j(t2) {
        D(N);
        var e2 = t2.g;
        return null == (e2 = null == e2 || F(e2) ? e2 : "string" == typeof e2 ? k(e2) : null) ? e2 : t2.g = e2;
      }
      var C = class {
        i() {
          return new Uint8Array(j(this) || 0);
        }
        constructor(t2, e2) {
          if (D(e2), this.g = t2, null != t2 && 0 === t2.length)
            throw Error("ByteString should be constructed with non-empty values");
        }
      };
      var M;
      var G;
      function D(t2) {
        if (t2 !== N)
          throw Error("illegal external caller");
      }
      function $(t2, e2) {
        t2.__closure__error__context__984382 || (t2.__closure__error__context__984382 = {}), t2.__closure__error__context__984382.severity = e2;
      }
      function z() {
        const t2 = Error("int32");
        return $(t2, "warning"), t2;
      }
      function R(e2) {
        if (null != e2) {
          var n2 = G ??= {}, r2 = n2[e2] || 0;
          r2 >= 5 || (n2[e2] = r2 + 1, $(e2 = Error(), "incident"), function(e3) {
            t.setTimeout(() => {
              throw e3;
            }, 0);
          }(e2));
        }
      }
      var W = "function" == typeof Symbol && "symbol" == typeof Symbol();
      function H(t2, e2, n2 = false) {
        return "function" == typeof Symbol && "symbol" == typeof Symbol() ? n2 && Symbol.for && t2 ? Symbol.for(t2) : null != t2 ? Symbol(t2) : Symbol() : e2;
      }
      var q = H("jas", void 0, true);
      var K = H(void 0, "1oa");
      var X = H(void 0, Symbol());
      var J = H(void 0, "0actk");
      var Y = H(void 0, "8utk");
      var Q = W ? q : "L";
      var Z = { L: { value: 0, configurable: true, writable: true, enumerable: false } };
      var tt = Object.defineProperties;
      function et(t2, e2) {
        W || Q in t2 || tt(t2, Z), t2[Q] |= e2;
      }
      function nt(t2, e2) {
        W || Q in t2 || tt(t2, Z), t2[Q] = e2;
      }
      function rt(t2, e2) {
        nt(e2, -15615 & (0 | t2));
      }
      function it(t2, e2) {
        nt(e2, -15581 & (34 | t2));
      }
      function ot() {
        return "function" == typeof BigInt;
      }
      function st(t2) {
        return Array.prototype.slice.call(t2);
      }
      var at;
      var ut = {};
      function ct(t2) {
        return null !== t2 && "object" == typeof t2 && !Array.isArray(t2) && t2.constructor === Object;
      }
      function lt(t2, e2) {
        if (null != t2) {
          if ("string" == typeof t2)
            t2 = t2 ? new C(t2, N) : V();
          else if (t2.constructor !== C)
            if (F(t2))
              t2 = t2.length ? new C(new Uint8Array(t2), N) : V();
            else {
              if (!e2)
                throw Error();
              t2 = void 0;
            }
        }
        return t2;
      }
      var ht = [];
      function ft(t2) {
        if (2 & t2)
          throw Error();
      }
      function dt(t2) {
        return X ? t2[X] : void 0;
      }
      nt(ht, 55), at = Object.freeze(ht);
      var gt = Object.freeze({});
      var pt = "function" == typeof t.BigInt && "bigint" == typeof t.BigInt(0);
      var mt = (t2) => pt ? t2 >= bt && t2 <= wt : "-" === t2[0] ? _t(t2, yt) : _t(t2, vt);
      var yt = Number.MIN_SAFE_INTEGER.toString();
      var bt = pt ? BigInt(Number.MIN_SAFE_INTEGER) : void 0;
      var vt = Number.MAX_SAFE_INTEGER.toString();
      var wt = pt ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
      function _t(t2, e2) {
        if (t2.length > e2.length)
          return false;
        if (t2.length < e2.length || t2 === e2)
          return true;
        for (let n2 = 0; n2 < t2.length; n2++) {
          const r2 = t2[n2], i2 = e2[n2];
          if (r2 > i2)
            return false;
          if (r2 < i2)
            return true;
        }
      }
      var St = "function" == typeof Uint8Array.prototype.slice;
      var At;
      var Et = 0;
      var It = 0;
      function Tt(t2) {
        const e2 = t2 >>> 0;
        Et = e2, It = (t2 - e2) / 4294967296 >>> 0;
      }
      function xt(t2) {
        if (t2 < 0) {
          Tt(-t2);
          const [e2, n2] = Ft(Et, It);
          Et = e2 >>> 0, It = n2 >>> 0;
        } else
          Tt(t2);
      }
      function Ut(t2) {
        const e2 = At ||= new DataView(new ArrayBuffer(8));
        e2.setFloat32(0, +t2, true), It = 0, Et = e2.getUint32(0, true);
      }
      function Pt(t2, e2) {
        const n2 = 4294967296 * e2 + (t2 >>> 0);
        return Number.isSafeInteger(n2) ? n2 : Lt(t2, e2);
      }
      function Bt(t2, e2) {
        const n2 = 2147483648 & e2;
        return n2 && (e2 = ~e2 >>> 0, 0 == (t2 = 1 + ~t2 >>> 0) && (e2 = e2 + 1 >>> 0)), "number" == typeof (t2 = Pt(t2, e2)) ? n2 ? -t2 : t2 : n2 ? "-" + t2 : t2;
      }
      function Lt(t2, e2) {
        if (t2 >>>= 0, (e2 >>>= 0) <= 2097151)
          var n2 = "" + (4294967296 * e2 + t2);
        else
          ot() ? n2 = "" + (BigInt(e2) << BigInt(32) | BigInt(t2)) : (t2 = (16777215 & t2) + 6777216 * (n2 = 16777215 & (t2 >>> 24 | e2 << 8)) + 6710656 * (e2 = e2 >> 16 & 65535), n2 += 8147497 * e2, e2 *= 2, t2 >= 1e7 && (n2 += t2 / 1e7 >>> 0, t2 %= 1e7), n2 >= 1e7 && (e2 += n2 / 1e7 >>> 0, n2 %= 1e7), n2 = e2 + Ot(n2) + Ot(t2));
        return n2;
      }
      function Ot(t2) {
        return t2 = String(t2), "0000000".slice(t2.length) + t2;
      }
      function kt(t2) {
        if (t2.length < 16)
          xt(Number(t2));
        else if (ot())
          t2 = BigInt(t2), Et = Number(t2 & BigInt(4294967295)) >>> 0, It = Number(t2 >> BigInt(32) & BigInt(4294967295));
        else {
          const e2 = +("-" === t2[0]);
          It = Et = 0;
          const n2 = t2.length;
          for (let r2 = e2, i2 = (n2 - e2) % 6 + e2; i2 <= n2; r2 = i2, i2 += 6) {
            const e3 = Number(t2.slice(r2, i2));
            It *= 1e6, Et = 1e6 * Et + e3, Et >= 4294967296 && (It += Math.trunc(Et / 4294967296), It >>>= 0, Et >>>= 0);
          }
          if (e2) {
            const [t3, e3] = Ft(Et, It);
            Et = t3, It = e3;
          }
        }
      }
      function Ft(t2, e2) {
        return e2 = ~e2, t2 ? t2 = 1 + ~t2 : e2 += 1, [t2, e2];
      }
      var Nt = "function" == typeof BigInt ? BigInt.asIntN : void 0;
      var Vt = "function" == typeof BigInt ? BigInt.asUintN : void 0;
      var jt = Number.isSafeInteger;
      var Ct = Number.isFinite;
      var Mt = Math.trunc;
      function Gt(t2) {
        return null == t2 || "number" == typeof t2 ? t2 : "NaN" === t2 || "Infinity" === t2 || "-Infinity" === t2 ? Number(t2) : void 0;
      }
      function Dt(t2) {
        if (null != t2 && "boolean" != typeof t2) {
          var e2 = typeof t2;
          throw Error(`Expected boolean but got ${"object" != e2 ? e2 : t2 ? Array.isArray(t2) ? "array" : e2 : "null"}: ${t2}`);
        }
        return t2;
      }
      var $t = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
      function zt(t2) {
        switch (typeof t2) {
          case "bigint":
            return true;
          case "number":
            return Ct(t2);
          case "string":
            return $t.test(t2);
          default:
            return false;
        }
      }
      function Rt(t2) {
        if (null == t2)
          return t2;
        if ("string" == typeof t2 && t2)
          t2 = +t2;
        else if ("number" != typeof t2)
          return;
        return Ct(t2) ? 0 | t2 : void 0;
      }
      function Wt(t2) {
        if ("-" === t2[0])
          return false;
        const e2 = t2.length;
        return e2 < 20 || 20 === e2 && Number(t2.substring(0, 6)) < 184467;
      }
      function Ht(t2) {
        return t2 = Mt(t2), jt(t2) || (xt(t2), t2 = Bt(Et, It)), t2;
      }
      function qt(t2) {
        var e2 = Mt(Number(t2));
        if (jt(e2))
          return String(e2);
        if (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), e2 = t2.length, !("-" === t2[0] ? e2 < 20 || 20 === e2 && Number(t2.substring(0, 7)) > -922337 : e2 < 19 || 19 === e2 && Number(t2.substring(0, 6)) < 922337))
          if (kt(t2), t2 = Et, 2147483648 & (e2 = It))
            if (ot())
              t2 = "" + (BigInt(0 | e2) << BigInt(32) | BigInt(t2 >>> 0));
            else {
              const [n2, r2] = Ft(t2, e2);
              t2 = "-" + Lt(n2, r2);
            }
          else
            t2 = Lt(t2, e2);
        return t2;
      }
      function Kt(t2) {
        return null == t2 ? t2 : "bigint" == typeof t2 ? (mt(t2) ? t2 = Number(t2) : (t2 = Nt(64, t2), t2 = mt(t2) ? Number(t2) : String(t2)), t2) : zt(t2) ? "number" == typeof t2 ? Ht(t2) : qt(t2) : void 0;
      }
      function Xt(t2) {
        if (null == t2)
          return t2;
        var e2 = typeof t2;
        if ("bigint" === e2)
          return String(Vt(64, t2));
        if (zt(t2)) {
          if ("string" === e2)
            return e2 = Mt(Number(t2)), jt(e2) && e2 >= 0 ? t2 = String(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), Wt(t2) || (kt(t2), t2 = Lt(Et, It))), t2;
          if ("number" === e2)
            return (t2 = Mt(t2)) >= 0 && jt(t2) ? t2 : function(t3) {
              if (t3 < 0) {
                xt(t3);
                var e3 = Lt(Et, It);
                return t3 = Number(e3), jt(t3) ? t3 : e3;
              }
              return Wt(e3 = String(t3)) ? e3 : (xt(t3), Pt(Et, It));
            }(t2);
        }
      }
      function Jt(t2) {
        if ("string" != typeof t2)
          throw Error();
        return t2;
      }
      function Yt(t2) {
        if (null != t2 && "string" != typeof t2)
          throw Error();
        return t2;
      }
      function Qt(t2) {
        return null == t2 || "string" == typeof t2 ? t2 : void 0;
      }
      function Zt(t2, e2, n2) {
        if (null != t2 && "object" == typeof t2 && t2.B === ut)
          return t2;
        if (Array.isArray(t2)) {
          var r2 = 0 | t2[Q], i2 = r2;
          return 0 === i2 && (i2 |= 32 & n2), (i2 |= 2 & n2) !== r2 && nt(t2, i2), new e2(t2);
        }
      }
      function te(t2) {
        return t2;
      }
      function ee(t2, e2, n2, r2, i2) {
        if (null != t2) {
          if (Array.isArray(t2)) {
            const o2 = 0 | t2[Q];
            return 0 === t2.length && 1 & o2 ? void 0 : i2 && 2 & o2 ? t2 : ne(t2, e2, n2, void 0 !== r2, i2);
          }
          return e2(t2, r2);
        }
      }
      function ne(t2, e2, n2, r2, i2) {
        const o2 = r2 || n2 ? 0 | t2[Q] : 0, s2 = r2 ? !!(32 & o2) : void 0;
        let a2 = 0;
        const u2 = (r2 = st(t2)).length;
        for (let t3 = 0; t3 < u2; t3++) {
          var c2 = r2[t3];
          if (t3 === u2 - 1 && ct(c2)) {
            var l2 = e2, h2 = n2, f2 = s2, d2 = i2;
            let t4;
            for (let e3 in c2) {
              const n3 = ee(c2[e3], l2, h2, f2, d2);
              null != n3 && ((t4 ??= {})[e3] = n3);
            }
            c2 = t4;
          } else
            c2 = ee(r2[t3], e2, n2, s2, i2);
          r2[t3] = c2, null != c2 && (a2 = t3 + 1);
        }
        return a2 < u2 && (r2.length = a2), n2 && ((t2 = dt(t2)) && (r2[X] = st(t2)), n2(o2, r2)), r2;
      }
      function re2(t2) {
        switch (typeof t2) {
          case "number":
            return Number.isFinite(t2) ? t2 : "" + t2;
          case "bigint":
            return mt(t2) ? Number(t2) : "" + t2;
          case "boolean":
            return t2 ? 1 : 0;
          case "object":
            if (F(t2))
              return F(t2) && R(Y), P(t2);
            if (t2.B === ut)
              return ae(t2);
            if (t2 instanceof C) {
              const e2 = t2.g;
              return null == e2 ? "" : "string" == typeof e2 ? e2 : t2.g = P(e2);
            }
            return;
        }
        return t2;
      }
      var ie;
      var oe;
      var se;
      function ae(t2) {
        var e2 = t2.l;
        t2 = ne(e2, re2, void 0, void 0, false);
        var n2 = 0 | e2[Q];
        if ((e2 = t2.length) && !(512 & n2)) {
          var r2 = t2[e2 - 1], i2 = false;
          ct(r2) ? (e2--, i2 = true) : r2 = void 0;
          var o2 = e2 - (n2 = 512 & n2 ? 0 : -1), s2 = (ie ?? te)(o2, n2, t2, r2);
          if (r2 && (t2[e2] = void 0), o2 < s2 && r2) {
            for (var a2 in o2 = true, r2) {
              const u2 = +a2;
              u2 <= s2 ? (t2[i2 = u2 + n2] = r2[a2], e2 = Math.max(i2 + 1, e2), i2 = false, delete r2[a2]) : o2 = false;
            }
            o2 && (r2 = void 0);
          }
          for (o2 = e2 - 1; e2 > 0; o2 = e2 - 1)
            if (null == (a2 = t2[o2]))
              e2--, i2 = true;
            else {
              if (!((o2 -= n2) >= s2))
                break;
              (r2 ??= {})[o2] = a2, e2--, i2 = true;
            }
          i2 && (t2.length = e2), r2 && t2.push(r2);
        }
        return t2;
      }
      function ue(t2, e2, n2) {
        return t2 = ce(t2, e2[0], e2[1], n2 ? 1 : 2), e2 !== oe && n2 && et(t2, 8192), t2;
      }
      function ce(t2, e2, n2, r2) {
        if (null == t2) {
          var i2 = 96;
          n2 ? (t2 = [n2], i2 |= 512) : t2 = [], e2 && (i2 = -16760833 & i2 | (1023 & e2) << 14);
        } else {
          if (!Array.isArray(t2))
            throw Error("narr");
          if (8192 & (i2 = 0 | t2[Q]) || !(64 & i2) || 2 & i2 || R(J), 1024 & i2)
            throw Error("farr");
          if (64 & i2)
            return t2;
          if (1 === r2 || 2 === r2 || (i2 |= 64), n2 && (i2 |= 512, n2 !== t2[0]))
            throw Error("mid");
          t: {
            var o2 = (n2 = t2).length;
            if (o2) {
              var s2 = o2 - 1;
              if (ct(r2 = n2[s2])) {
                if ((s2 -= e2 = 512 & (i2 |= 256) ? 0 : -1) >= 1024)
                  throw Error("pvtlmt");
                for (var a2 in r2)
                  (o2 = +a2) < s2 && (n2[o2 + e2] = r2[a2], delete r2[a2]);
                i2 = -16760833 & i2 | (1023 & s2) << 14;
                break t;
              }
            }
            if (e2) {
              if ((a2 = Math.max(e2, o2 - (512 & i2 ? 0 : -1))) > 1024)
                throw Error("spvt");
              i2 = -16760833 & i2 | (1023 & a2) << 14;
            }
          }
        }
        return nt(t2, i2), t2;
      }
      function le(t2, e2, n2 = it) {
        if (null != t2) {
          if (x && t2 instanceof Uint8Array)
            return e2 ? t2 : new Uint8Array(t2);
          if (Array.isArray(t2)) {
            var r2 = 0 | t2[Q];
            return 2 & r2 ? t2 : (e2 &&= 0 === r2 || !!(32 & r2) && !(64 & r2 || !(16 & r2)), e2 ? (nt(t2, 34 | r2), 4 & r2 && Object.freeze(t2), t2) : ne(t2, le, 4 & r2 ? it : n2, true, true));
          }
          return t2.B === ut && (t2 = 2 & (r2 = 0 | (n2 = t2.l)[Q]) ? t2 : new t2.constructor(fe(n2, r2, true))), t2;
        }
      }
      function he(t2) {
        const e2 = t2.l;
        return new t2.constructor(fe(e2, 0 | e2[Q], false));
      }
      function fe(t2, e2, n2) {
        const r2 = n2 || 2 & e2 ? it : rt, i2 = !!(32 & e2);
        return t2 = function(t3, e3, n3) {
          const r3 = st(t3);
          var i3 = r3.length;
          const o2 = 256 & e3 ? r3[i3 - 1] : void 0;
          for (i3 += o2 ? -1 : 0, e3 = 512 & e3 ? 1 : 0; e3 < i3; e3++)
            r3[e3] = n3(r3[e3]);
          if (o2) {
            e3 = r3[e3] = {};
            for (const t4 in o2)
              e3[t4] = n3(o2[t4]);
          }
          return (t3 = dt(t3)) && (r3[X] = st(t3)), r3;
        }(t2, e2, (t3) => le(t3, i2, r2)), et(t2, 32 | (n2 ? 2 : 0)), t2;
      }
      function de(t2) {
        const e2 = t2.l, n2 = 0 | e2[Q];
        return 2 & n2 ? new t2.constructor(fe(e2, n2, false)) : t2;
      }
      function ge(t2, e2) {
        return pe(t2 = t2.l, 0 | t2[Q], e2);
      }
      function pe(t2, e2, n2) {
        if (-1 === n2)
          return null;
        const r2 = n2 + (512 & e2 ? 0 : -1), i2 = t2.length - 1;
        return r2 >= i2 && 256 & e2 ? t2[i2][n2] : r2 <= i2 ? t2[r2] : void 0;
      }
      function me(t2, e2, n2) {
        const r2 = t2.l;
        let i2 = 0 | r2[Q];
        return ft(i2), ye(r2, i2, e2, n2), t2;
      }
      function ye(t2, e2, n2, r2) {
        const i2 = 512 & e2 ? 0 : -1, o2 = n2 + i2;
        var s2 = t2.length - 1;
        return o2 >= s2 && 256 & e2 ? (t2[s2][n2] = r2, e2) : o2 <= s2 ? (t2[o2] = r2, e2) : (void 0 !== r2 && (n2 >= (s2 = e2 >> 14 & 1023 || 536870912) ? null != r2 && (t2[s2 + i2] = { [n2]: r2 }, nt(t2, e2 |= 256)) : t2[o2] = r2), e2);
      }
      function be(t2) {
        let e2 = 0 | (t2 = t2.l)[Q];
        const n2 = pe(t2, e2, 1), r2 = lt(n2, true);
        return null != r2 && r2 !== n2 && ye(t2, e2, 1, r2), r2;
      }
      function ve(t2, e2, n2, r2, i2) {
        const o2 = t2.l, s2 = 2 & (t2 = 0 | o2[Q]) ? 1 : r2;
        i2 = !!i2;
        let a2 = 0 | (r2 = we(o2, t2, e2))[Q];
        if (!(4 & a2)) {
          4 & a2 && (r2 = st(r2), a2 = je(a2, t2), t2 = ye(o2, t2, e2, r2));
          let i3 = 0, s3 = 0;
          for (; i3 < r2.length; i3++) {
            const t3 = n2(r2[i3]);
            null != t3 && (r2[s3++] = t3);
          }
          s3 < i3 && (r2.length = s3), a2 = _e(a2, t2), n2 = -2049 & (20 | a2), a2 = n2 &= -4097, nt(r2, a2), 2 & a2 && Object.freeze(r2);
        }
        return 1 === s2 || 4 === s2 && 32 & a2 ? Se(a2) || (i2 = a2, a2 |= 2, a2 !== i2 && nt(r2, a2), Object.freeze(r2)) : (2 === s2 && Se(a2) && (r2 = st(r2), a2 = je(a2, t2), a2 = Ce(a2, t2, i2), nt(r2, a2), t2 = ye(o2, t2, e2, r2)), Se(a2) || (e2 = a2, a2 = Ce(a2, t2, i2), a2 !== e2 && nt(r2, a2))), r2;
      }
      function we(t2, e2, n2) {
        return t2 = pe(t2, e2, n2), Array.isArray(t2) ? t2 : at;
      }
      function _e(t2, e2) {
        return 0 === t2 && (t2 = je(t2, e2)), 1 | t2;
      }
      function Se(t2) {
        return !!(2 & t2) && !!(4 & t2) || !!(1024 & t2);
      }
      function Ae(t2, e2, n2) {
        let r2 = 0 | (t2 = t2.l)[Q];
        if (ft(r2), null == n2)
          ye(t2, r2, e2);
        else {
          var i2 = 0 | n2[Q], o2 = i2, s2 = Se(i2), a2 = s2 || Object.isFrozen(n2);
          for (s2 || (i2 = 0), a2 || (n2 = st(n2), o2 = 0, i2 = Ce(i2 = je(i2, r2), r2, true), a2 = false), i2 |= 21, s2 = 0; s2 < n2.length; s2++) {
            const t3 = n2[s2], e3 = Jt(t3);
            Object.is(t3, e3) || (a2 && (n2 = st(n2), o2 = 0, i2 = Ce(i2 = je(i2, r2), r2, true), a2 = false), n2[s2] = e3);
          }
          i2 !== o2 && (a2 && (n2 = st(n2), i2 = Ce(i2 = je(i2, r2), r2, true)), nt(n2, i2)), ye(t2, r2, e2, n2);
        }
      }
      function Ee(t2, e2) {
        let n2 = 0 | (t2 = t2.l)[Q];
        ft(n2), ye(t2, n2, 2, "" === e2 ? void 0 : e2);
      }
      function Ie(t2, e2, n2, r2) {
        ft(e2);
        let i2 = we(t2, e2, n2);
        const o2 = i2 !== at;
        if (64 & e2 || !(8192 & e2) || !o2) {
          const s2 = o2 ? 0 | i2[Q] : 0;
          let a2 = s2;
          (!o2 || 2 & a2 || Se(a2) || 4 & a2 && !(32 & a2)) && (i2 = st(i2), a2 = je(a2, e2), e2 = ye(t2, e2, n2, i2)), a2 = -13 & _e(a2, e2), a2 = Ce(r2 ? -17 & a2 : 16 | a2, e2, true), a2 !== s2 && nt(i2, a2);
        }
        return i2;
      }
      function Te(t2, e2) {
        var n2 = ci;
        return Pe(xe(t2 = t2.l), t2, 0 | t2[Q], n2) === e2 ? e2 : -1;
      }
      function xe(t2) {
        if (W)
          return t2[K] ?? (t2[K] = /* @__PURE__ */ new Map());
        if (K in t2)
          return t2[K];
        const e2 = /* @__PURE__ */ new Map();
        return Object.defineProperty(t2, K, { value: e2 }), e2;
      }
      function Ue(t2, e2, n2, r2) {
        const i2 = xe(t2), o2 = Pe(i2, t2, e2, n2);
        return o2 !== r2 && (o2 && (e2 = ye(t2, e2, o2)), i2.set(n2, r2)), e2;
      }
      function Pe(t2, e2, n2, r2) {
        let i2 = t2.get(r2);
        if (null != i2)
          return i2;
        i2 = 0;
        for (let t3 = 0; t3 < r2.length; t3++) {
          const o2 = r2[t3];
          null != pe(e2, n2, o2) && (0 !== i2 && (n2 = ye(e2, n2, i2)), i2 = o2);
        }
        return t2.set(r2, i2), i2;
      }
      function Be(t2, e2, n2) {
        let r2 = 0 | t2[Q];
        const i2 = pe(t2, r2, n2);
        let o2;
        if (null != i2 && i2.B === ut)
          return (e2 = de(i2)) !== i2 && ye(t2, r2, n2, e2), e2.l;
        if (Array.isArray(i2)) {
          const t3 = 0 | i2[Q];
          o2 = 2 & t3 ? ue(fe(i2, t3, false), e2, true) : 64 & t3 ? i2 : ue(o2, e2, true);
        } else
          o2 = ue(void 0, e2, true);
        return o2 !== i2 && ye(t2, r2, n2, o2), o2;
      }
      function Le(t2, e2, n2) {
        let r2 = 0 | (t2 = t2.l)[Q];
        const i2 = pe(t2, r2, n2);
        return (e2 = Zt(i2, e2, r2)) !== i2 && null != e2 && ye(t2, r2, n2, e2), e2;
      }
      function Oe(t2, e2, n2) {
        if (null == (e2 = Le(t2, e2, n2)))
          return e2;
        let r2 = 0 | (t2 = t2.l)[Q];
        if (!(2 & r2)) {
          const i2 = de(e2);
          i2 !== e2 && ye(t2, r2, n2, e2 = i2);
        }
        return e2;
      }
      function ke(t2, e2, n2, r2, i2, o2) {
        t2 = t2.l;
        var s2 = !!(2 & e2);
        const a2 = s2 ? 1 : r2;
        i2 = !!i2, o2 &&= !s2;
        var u2 = 0 | (r2 = we(t2, e2, 1))[Q];
        if (!(s2 = !!(4 & u2))) {
          var c2 = r2, l2 = e2;
          const t3 = !!(2 & (u2 = _e(u2, e2)));
          t3 && (l2 |= 2);
          let i3 = !t3, o3 = true, s3 = 0, a3 = 0;
          for (; s3 < c2.length; s3++) {
            const e3 = Zt(c2[s3], n2, l2);
            if (e3 instanceof n2) {
              if (!t3) {
                const t4 = !!(2 & (0 | e3.l[Q]));
                i3 &&= !t4, o3 &&= t4;
              }
              c2[a3++] = e3;
            }
          }
          a3 < s3 && (c2.length = a3), u2 |= 4, u2 = o3 ? 16 | u2 : -17 & u2, nt(c2, u2 = i3 ? 8 | u2 : -9 & u2), t3 && Object.freeze(c2);
        }
        if (o2 && !(8 & u2 || !r2.length && (1 === a2 || 4 === a2 && 32 & u2))) {
          for (Se(u2) && (r2 = st(r2), u2 = je(u2, e2), e2 = ye(t2, e2, 1, r2)), n2 = r2, o2 = u2, c2 = 0; c2 < n2.length; c2++)
            (u2 = n2[c2]) !== (l2 = de(u2)) && (n2[c2] = l2);
          o2 |= 8, nt(n2, o2 = n2.length ? -17 & o2 : 16 | o2), u2 = o2;
        }
        return 1 === a2 || 4 === a2 && 32 & u2 ? Se(u2) || (e2 = u2, (u2 |= !r2.length || 16 & u2 && (!s2 || 32 & u2) ? 2 : 1024) !== e2 && nt(r2, u2), Object.freeze(r2)) : (2 === a2 && Se(u2) && (nt(r2 = st(r2), u2 = Ce(u2 = je(u2, e2), e2, i2)), e2 = ye(t2, e2, 1, r2)), Se(u2) || (t2 = u2, (u2 = Ce(u2, e2, i2)) !== t2 && nt(r2, u2))), r2;
      }
      function Fe(t2, e2) {
        const n2 = 0 | t2.l[Q];
        return ke(t2, n2, e2, void 0 === gt ? 2 : 4, false, !(2 & n2));
      }
      function Ne(t2, e2, n2, r2) {
        return null == r2 && (r2 = void 0), me(t2, n2, r2);
      }
      function Ve(t2, e2, n2) {
        var r2 = pi;
        null == n2 && (n2 = void 0);
        t: {
          let i2 = 0 | (t2 = t2.l)[Q];
          if (ft(i2), null == n2) {
            const n3 = xe(t2);
            if (Pe(n3, t2, i2, r2) !== e2)
              break t;
            n3.set(r2, 0);
          } else
            i2 = Ue(t2, i2, r2, e2);
          ye(t2, i2, e2, n2);
        }
      }
      function je(t2, e2) {
        return -1025 & (t2 = 32 | (2 & e2 ? 2 | t2 : -3 & t2));
      }
      function Ce(t2, e2, n2) {
        return 32 & e2 && n2 || (t2 &= -33), t2;
      }
      function Me(t2, e2, n2) {
        ft(0 | t2.l[Q]), ve(t2, e2, Qt, 2, true).push(Jt(n2));
      }
      function Ge(t2, e2) {
        var n2 = Xr;
        const r2 = 0 | t2.l[Q];
        ft(r2), t2 = ke(t2, r2, n2, 2, true), e2 = null != e2 ? e2 : new n2(), t2.push(e2), t2[Q] = 2 & (0 | e2.l[Q]) ? -9 & t2[Q] : -17 & t2[Q];
      }
      function De(t2, e2) {
        return Error(`Invalid wire type: ${t2} (at position ${e2})`);
      }
      function $e() {
        return Error("Failed to read varint, encoding is invalid.");
      }
      function ze(t2, e2) {
        return Error(`Tried to read past the end of the data ${e2} > ${t2}`);
      }
      function Re(t2) {
        if ("string" == typeof t2)
          return { buffer: k(t2), v: false };
        if (Array.isArray(t2))
          return { buffer: new Uint8Array(t2), v: false };
        if (t2.constructor === Uint8Array)
          return { buffer: t2, v: false };
        if (t2.constructor === ArrayBuffer)
          return { buffer: new Uint8Array(t2), v: false };
        if (t2.constructor === C)
          return { buffer: j(t2) || new Uint8Array(0), v: true };
        if (t2 instanceof Uint8Array)
          return { buffer: new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength), v: false };
        throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
      }
      function We(t2, e2) {
        let n2, r2 = 0, i2 = 0, o2 = 0;
        const s2 = t2.i;
        let a2 = t2.g;
        do {
          n2 = s2[a2++], r2 |= (127 & n2) << o2, o2 += 7;
        } while (o2 < 32 && 128 & n2);
        for (o2 > 32 && (i2 |= (127 & n2) >> 4), o2 = 3; o2 < 32 && 128 & n2; o2 += 7)
          n2 = s2[a2++], i2 |= (127 & n2) << o2;
        if (Ye(t2, a2), n2 < 128)
          return e2(r2 >>> 0, i2 >>> 0);
        throw $e();
      }
      function He(t2) {
        let e2 = 0, n2 = t2.g;
        const r2 = n2 + 10, i2 = t2.i;
        for (; n2 < r2; ) {
          const r3 = i2[n2++];
          if (e2 |= r3, 0 == (128 & r3))
            return Ye(t2, n2), !!(127 & e2);
        }
        throw $e();
      }
      function qe(t2) {
        const e2 = t2.i;
        let n2 = t2.g, r2 = e2[n2++], i2 = 127 & r2;
        if (128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 7, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 14, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 21, 128 & r2 && (r2 = e2[n2++], i2 |= r2 << 28, 128 & r2 && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++])))))
          throw $e();
        return Ye(t2, n2), i2;
      }
      function Ke(t2) {
        var e2 = t2.i;
        const n2 = t2.g;
        var r2 = e2[n2], i2 = e2[n2 + 1];
        const o2 = e2[n2 + 2];
        return e2 = e2[n2 + 3], Ye(t2, t2.g + 4), t2 = 2 * ((i2 = (r2 << 0 | i2 << 8 | o2 << 16 | e2 << 24) >>> 0) >> 31) + 1, r2 = i2 >>> 23 & 255, i2 &= 8388607, 255 == r2 ? i2 ? NaN : t2 * (1 / 0) : 0 == r2 ? 1401298464324817e-60 * t2 * i2 : t2 * Math.pow(2, r2 - 150) * (i2 + 8388608);
      }
      function Xe(t2) {
        return qe(t2);
      }
      function Je(t2, e2, { C: n2 = false } = {}) {
        t2.C = n2, e2 && (e2 = Re(e2), t2.i = e2.buffer, t2.m = e2.v, t2.u = 0, t2.j = t2.i.length, t2.g = t2.u);
      }
      function Ye(t2, e2) {
        if (t2.g = e2, e2 > t2.j)
          throw ze(t2.j, e2);
      }
      function Qe(t2, e2) {
        if (e2 < 0)
          throw Error(`Tried to read a negative byte length: ${e2}`);
        const n2 = t2.g, r2 = n2 + e2;
        if (r2 > t2.j)
          throw ze(e2, t2.j - n2);
        return t2.g = r2, n2;
      }
      function Ze(t2, e2) {
        if (0 == e2)
          return V();
        var n2 = Qe(t2, e2);
        return t2.C && t2.m ? n2 = t2.i.subarray(n2, n2 + e2) : (t2 = t2.i, n2 = n2 === (e2 = n2 + e2) ? new Uint8Array(0) : St ? t2.slice(n2, e2) : new Uint8Array(t2.subarray(n2, e2))), 0 == n2.length ? V() : new C(n2, N);
      }
      var tn = [];
      function en(t2) {
        var e2 = t2.g;
        if (e2.g == e2.j)
          return false;
        t2.j = t2.g.g;
        var n2 = qe(t2.g) >>> 0;
        if (e2 = n2 >>> 3, !((n2 &= 7) >= 0 && n2 <= 5))
          throw De(n2, t2.j);
        if (e2 < 1)
          throw Error(`Invalid field number: ${e2} (at position ${t2.j})`);
        return t2.m = e2, t2.i = n2, true;
      }
      function nn(t2) {
        switch (t2.i) {
          case 0:
            0 != t2.i ? nn(t2) : He(t2.g);
            break;
          case 1:
            Ye(t2 = t2.g, t2.g + 8);
            break;
          case 2:
            if (2 != t2.i)
              nn(t2);
            else {
              var e2 = qe(t2.g) >>> 0;
              Ye(t2 = t2.g, t2.g + e2);
            }
            break;
          case 5:
            Ye(t2 = t2.g, t2.g + 4);
            break;
          case 3:
            for (e2 = t2.m; ; ) {
              if (!en(t2))
                throw Error("Unmatched start-group tag: stream EOF");
              if (4 == t2.i) {
                if (t2.m != e2)
                  throw Error("Unmatched end-group tag");
                break;
              }
              nn(t2);
            }
            break;
          default:
            throw De(t2.i, t2.j);
        }
      }
      function rn(t2, e2, n2) {
        const r2 = t2.g.j, i2 = qe(t2.g) >>> 0, o2 = t2.g.g + i2;
        let s2 = o2 - r2;
        if (s2 <= 0 && (t2.g.j = o2, n2(e2, t2, void 0, void 0, void 0), s2 = o2 - t2.g.g), s2)
          throw Error(`Message parsing ended unexpectedly. Expected to read ${i2} bytes, instead read ${i2 - s2} bytes, either the data ended unexpectedly or the message misreported its own length`);
        t2.g.g = o2, t2.g.j = r2;
      }
      function on(t2) {
        var s2 = qe(t2.g) >>> 0, a2 = Qe(t2 = t2.g, s2);
        if (t2 = t2.i, o) {
          var u2, c2 = t2;
          (u2 = i) || (u2 = i = new TextDecoder("utf-8", { fatal: true })), s2 = a2 + s2, c2 = 0 === a2 && s2 === c2.length ? c2 : c2.subarray(a2, s2);
          try {
            var l2 = u2.decode(c2);
          } catch (t3) {
            if (void 0 === r) {
              try {
                u2.decode(new Uint8Array([128]));
              } catch (t4) {
              }
              try {
                u2.decode(new Uint8Array([97])), r = true;
              } catch (t4) {
                r = false;
              }
            }
            throw !r && (i = void 0), t3;
          }
        } else {
          s2 = (l2 = a2) + s2, a2 = [];
          let r2, i2 = null;
          for (; l2 < s2; ) {
            var h2 = t2[l2++];
            h2 < 128 ? a2.push(h2) : h2 < 224 ? l2 >= s2 ? e() : (r2 = t2[l2++], h2 < 194 || 128 != (192 & r2) ? (l2--, e()) : a2.push((31 & h2) << 6 | 63 & r2)) : h2 < 240 ? l2 >= s2 - 1 ? e() : (r2 = t2[l2++], 128 != (192 & r2) || 224 === h2 && r2 < 160 || 237 === h2 && r2 >= 160 || 128 != (192 & (u2 = t2[l2++])) ? (l2--, e()) : a2.push((15 & h2) << 12 | (63 & r2) << 6 | 63 & u2)) : h2 <= 244 ? l2 >= s2 - 2 ? e() : (r2 = t2[l2++], 128 != (192 & r2) || r2 - 144 + (h2 << 28) >> 30 != 0 || 128 != (192 & (u2 = t2[l2++])) || 128 != (192 & (c2 = t2[l2++])) ? (l2--, e()) : (h2 = (7 & h2) << 18 | (63 & r2) << 12 | (63 & u2) << 6 | 63 & c2, h2 -= 65536, a2.push(55296 + (h2 >> 10 & 1023), 56320 + (1023 & h2)))) : e(), a2.length >= 8192 && (i2 = n(i2, a2), a2.length = 0);
          }
          l2 = n(i2, a2);
        }
        return l2;
      }
      function sn(t2) {
        const e2 = qe(t2.g) >>> 0;
        return Ze(t2.g, e2);
      }
      function an(t2, e2, n2) {
        var r2 = qe(t2.g) >>> 0;
        for (r2 = t2.g.g + r2; t2.g.g < r2; )
          n2.push(e2(t2.g));
      }
      var un = [];
      function cn(t2, e2, n2) {
        e2.g ? e2.j(t2, e2.g, e2.i, n2) : e2.j(t2, e2.i, n2);
      }
      var ln = class {
        constructor(t2, e2) {
          this.l = ce(t2, e2);
        }
        toJSON() {
          try {
            var t2 = ae(this);
          } finally {
            ie = void 0;
          }
          return t2;
        }
        v() {
          return !!(2 & (0 | this.l[Q]));
        }
      };
      function hn(t2) {
        return t2 ? /^\d+$/.test(t2) ? (kt(t2), new fn(Et, It)) : null : dn ||= new fn(0, 0);
      }
      ln.prototype.B = ut, ln.prototype.toString = function() {
        return this.l.toString();
      };
      var fn = class {
        constructor(t2, e2) {
          this.i = t2 >>> 0, this.g = e2 >>> 0;
        }
      };
      var dn;
      function gn(t2) {
        return t2 ? /^-?\d+$/.test(t2) ? (kt(t2), new pn(Et, It)) : null : mn ||= new pn(0, 0);
      }
      var pn = class {
        constructor(t2, e2) {
          this.i = t2 >>> 0, this.g = e2 >>> 0;
        }
      };
      var mn;
      function yn(t2, e2, n2) {
        for (; n2 > 0 || e2 > 127; )
          t2.g.push(127 & e2 | 128), e2 = (e2 >>> 7 | n2 << 25) >>> 0, n2 >>>= 7;
        t2.g.push(e2);
      }
      function bn(t2, e2) {
        for (; e2 > 127; )
          t2.g.push(127 & e2 | 128), e2 >>>= 7;
        t2.g.push(e2);
      }
      function vn(t2, e2) {
        if (e2 >= 0)
          bn(t2, e2);
        else {
          for (let n2 = 0; n2 < 9; n2++)
            t2.g.push(127 & e2 | 128), e2 >>= 7;
          t2.g.push(1);
        }
      }
      function wn(t2) {
        var e2 = Et;
        t2.g.push(e2 >>> 0 & 255), t2.g.push(e2 >>> 8 & 255), t2.g.push(e2 >>> 16 & 255), t2.g.push(e2 >>> 24 & 255);
      }
      function _n(t2, e2) {
        0 !== e2.length && (t2.j.push(e2), t2.i += e2.length);
      }
      function Sn(t2, e2, n2) {
        bn(t2.g, 8 * e2 + n2);
      }
      function An(t2, e2) {
        return Sn(t2, e2, 2), e2 = t2.g.end(), _n(t2, e2), e2.push(t2.i), e2;
      }
      function En(t2, e2) {
        var n2 = e2.pop();
        for (n2 = t2.i + t2.g.length() - n2; n2 > 127; )
          e2.push(127 & n2 | 128), n2 >>>= 7, t2.i++;
        e2.push(n2), t2.i++;
      }
      function In(t2, e2, n2) {
        Sn(t2, e2, 2), bn(t2.g, n2.length), _n(t2, t2.g.end()), _n(t2, n2);
      }
      function Tn() {
        const t2 = class {
          constructor() {
            throw Error();
          }
        };
        return Object.setPrototypeOf(t2, t2.prototype), t2;
      }
      var xn = Tn();
      var Un = Tn();
      var Pn = Tn();
      var Bn = Tn();
      var Ln = Tn();
      var On = Tn();
      var kn = Tn();
      var Fn = Tn();
      var Nn = class {
        constructor(t2, e2, n2) {
          this.g = t2, this.i = e2, t2 = xn, this.j = !!t2 && n2 === t2 || false;
        }
      };
      function Vn(t2, e2) {
        return new Nn(t2, e2, xn);
      }
      function jn(t2, e2, n2, r2, i2) {
        null != (e2 = Kn(e2, r2)) && (n2 = An(t2, n2), i2(e2, t2), En(t2, n2));
      }
      var Cn = Vn(function(t2, e2, n2, r2, i2) {
        return 2 === t2.i && (rn(t2, Be(e2, r2, n2), i2), true);
      }, jn);
      var Mn = Vn(function(t2, e2, n2, r2, i2) {
        return 2 === t2.i && (rn(t2, Be(e2, r2, n2), i2), true);
      }, jn);
      var Gn = Symbol();
      var Dn = Symbol();
      var $n = Symbol();
      var zn = Symbol();
      var Rn;
      var Wn;
      function Hn(t2, e2, n2, r2) {
        var i2 = r2[t2];
        if (i2)
          return i2;
        (i2 = {}).N = r2, i2.A = function(t3) {
          switch (typeof t3) {
            case "boolean":
              return oe ||= [0, void 0, true];
            case "number":
              return t3 > 0 ? void 0 : 0 === t3 ? se ||= [0, void 0] : [-t3, void 0];
            case "string":
              return [0, t3];
            case "object":
              return t3;
          }
        }(r2[0]);
        var o2 = r2[1];
        let s2 = 1;
        o2 && o2.constructor === Object && (i2.F = o2, "function" == typeof (o2 = r2[++s2]) && (i2.G = true, Rn ??= o2, Wn ??= r2[s2 + 1], o2 = r2[s2 += 2]));
        const a2 = {};
        for (; o2 && Array.isArray(o2) && o2.length && "number" == typeof o2[0] && o2[0] > 0; ) {
          for (var u2 = 0; u2 < o2.length; u2++)
            a2[o2[u2]] = o2;
          o2 = r2[++s2];
        }
        for (u2 = 1; void 0 !== o2; ) {
          let t3;
          "number" == typeof o2 && (u2 += o2, o2 = r2[++s2]);
          var c2 = void 0;
          if (o2 instanceof Nn ? t3 = o2 : (t3 = Cn, s2--), t3?.j) {
            o2 = r2[++s2], c2 = r2;
            var l2 = s2;
            "function" == typeof o2 && (o2 = o2(), c2[l2] = o2), c2 = o2;
          }
          for (l2 = u2 + 1, "number" == typeof (o2 = r2[++s2]) && o2 < 0 && (l2 -= o2, o2 = r2[++s2]); u2 < l2; u2++) {
            const r3 = a2[u2];
            c2 ? n2(i2, u2, t3, c2, r3) : e2(i2, u2, t3, r3);
          }
        }
        return r2[t2] = i2;
      }
      function qn(t2) {
        return Array.isArray(t2) ? t2[0] instanceof Nn ? t2 : [Mn, t2] : [t2, void 0];
      }
      function Kn(t2, e2) {
        return t2 instanceof ln ? t2.l : Array.isArray(t2) ? ue(t2, e2, false) : void 0;
      }
      function Xn(t2, e2, n2, r2) {
        const i2 = n2.g;
        t2[e2] = r2 ? (t3, e3, n3) => i2(t3, e3, n3, r2) : i2;
      }
      function Jn(t2, e2, n2, r2, i2) {
        const o2 = n2.g;
        let s2, a2;
        t2[e2] = (t3, e3, n3) => o2(t3, e3, n3, a2 ||= Hn(Dn, Xn, Jn, r2).A, s2 ||= Yn(r2), i2);
      }
      function Yn(t2) {
        let e2 = t2[$n];
        if (null != e2)
          return e2;
        const n2 = Hn(Dn, Xn, Jn, t2);
        return e2 = n2.G ? (t3, e3) => Rn(t3, e3, n2) : (t3, e3) => {
          const r2 = 0 | t3[Q];
          for (; en(e3) && 4 != e3.i; ) {
            var i2 = e3.m, o2 = n2[i2];
            if (null == o2) {
              var s2 = n2.F;
              s2 && (s2 = s2[i2]) && (null != (s2 = Qn(s2)) && (o2 = n2[i2] = s2));
            }
            null != o2 && o2(e3, t3, i2) || (i2 = (o2 = e3).j, nn(o2), o2.D ? o2 = void 0 : (s2 = o2.g.g - i2, o2.g.g = i2, o2 = Ze(o2.g, s2)), i2 = t3, o2 && ((s2 = i2[X]) ? s2.push(o2) : i2[X] = [o2]));
          }
          return 8192 & r2 && et(t3, 34), true;
        }, t2[$n] = e2;
      }
      function Qn(t2) {
        const e2 = (t2 = qn(t2))[0].g;
        if (t2 = t2[1]) {
          const n2 = Yn(t2), r2 = Hn(Dn, Xn, Jn, t2).A;
          return (t3, i2, o2) => e2(t3, i2, o2, r2, n2);
        }
        return e2;
      }
      function Zn(t2, e2, n2) {
        t2[e2] = n2.i;
      }
      function tr(t2, e2, n2, r2) {
        let i2, o2;
        const s2 = n2.i;
        t2[e2] = (t3, e3, n3) => s2(t3, e3, n3, o2 ||= Hn(Gn, Zn, tr, r2).A, i2 ||= er(r2));
      }
      function er(t2) {
        let e2 = t2[zn];
        if (!e2) {
          const n2 = Hn(Gn, Zn, tr, t2);
          e2 = (t3, e3) => nr(t3, e3, n2), t2[zn] = e2;
        }
        return e2;
      }
      function nr(t2, e2, n2) {
        !function(t3, e3, n3) {
          const r2 = 512 & e3 ? 0 : -1, i2 = t3.length, o2 = i2 + ((e3 = 64 & e3 ? 256 & e3 : !!i2 && ct(t3[i2 - 1])) ? -1 : 0);
          for (let e4 = 0; e4 < o2; e4++)
            n3(e4 - r2, t3[e4]);
          if (e3) {
            t3 = t3[i2 - 1];
            for (const e4 in t3)
              !isNaN(e4) && n3(+e4, t3[e4]);
          }
        }(t2, 0 | t2[Q] | (n2.A[1] ? 512 : 0), (t3, r2) => {
          if (null != r2) {
            var i2 = function(t4, e3) {
              var n3 = t4[e3];
              if (n3)
                return n3;
              if ((n3 = t4.F) && (n3 = n3[e3])) {
                var r3 = (n3 = qn(n3))[0].i;
                if (n3 = n3[1]) {
                  const e4 = er(n3), i3 = Hn(Gn, Zn, tr, n3).A;
                  n3 = t4.G ? Wn(i3, e4) : (t5, n4, o2) => r3(t5, n4, o2, i3, e4);
                } else
                  n3 = r3;
                return t4[e3] = n3;
              }
            }(n2, t3);
            i2 && i2(e2, r2, t3);
          }
        }), (t2 = dt(t2)) && function(t3, e3) {
          _n(t3, t3.g.end());
          for (let n3 = 0; n3 < e3.length; n3++)
            _n(t3, j(e3[n3]) || new Uint8Array(0));
        }(e2, t2);
      }
      function rr(t2, e2) {
        if (Array.isArray(e2)) {
          var n2 = 0 | e2[Q];
          if (4 & n2)
            return e2;
          for (var r2 = 0, i2 = 0; r2 < e2.length; r2++) {
            const n3 = t2(e2[r2]);
            null != n3 && (e2[i2++] = n3);
          }
          return i2 < r2 && (e2.length = i2), nt(e2, -6145 & (5 | n2)), 2 & n2 && Object.freeze(e2), e2;
        }
      }
      function ir(t2, e2, n2) {
        return new Nn(t2, e2, n2);
      }
      function or(t2, e2, n2) {
        return new Nn(t2, e2, n2);
      }
      function sr(t2, e2, n2) {
        ye(t2, 0 | t2[Q], e2, n2);
      }
      function ar(t2, e2, n2) {
        if (e2 = function(t3) {
          if (null == t3)
            return t3;
          const e3 = typeof t3;
          if ("bigint" === e3)
            return String(Nt(64, t3));
          if (zt(t3)) {
            if ("string" === e3)
              return qt(t3);
            if ("number" === e3)
              return Ht(t3);
          }
        }(e2), null != e2) {
          if ("string" == typeof e2)
            gn(e2);
          if (null != e2)
            switch (Sn(t2, n2, 0), typeof e2) {
              case "number":
                t2 = t2.g, xt(e2), yn(t2, Et, It);
                break;
              case "bigint":
                n2 = BigInt.asUintN(64, e2), n2 = new pn(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), yn(t2.g, n2.i, n2.g);
                break;
              default:
                n2 = gn(e2), yn(t2.g, n2.i, n2.g);
            }
        }
      }
      function ur(t2, e2, n2) {
        null != (e2 = Rt(e2)) && null != e2 && (Sn(t2, n2, 0), vn(t2.g, e2));
      }
      function cr(t2, e2, n2) {
        null != (e2 = null == e2 || "boolean" == typeof e2 ? e2 : "number" == typeof e2 ? !!e2 : void 0) && (Sn(t2, n2, 0), t2.g.g.push(e2 ? 1 : 0));
      }
      function lr(t2, e2, n2) {
        null != (e2 = Qt(e2)) && In(t2, n2, u(e2));
      }
      function hr(t2, e2, n2, r2, i2) {
        null != (e2 = Kn(e2, r2)) && (n2 = An(t2, n2), i2(e2, t2), En(t2, n2));
      }
      function fr(t2, e2, n2) {
        null == e2 || "string" == typeof e2 || e2 instanceof C || (F(e2) ? F(e2) && R(Y) : e2 = void 0), null != e2 && In(t2, n2, Re(e2).buffer);
      }
      var dr = ir(function(t2, e2, n2) {
        return 5 === t2.i && (sr(e2, n2, Ke(t2.g)), true);
      }, function(t2, e2, n2) {
        null != (e2 = Gt(e2)) && (Sn(t2, n2, 5), t2 = t2.g, Ut(e2), wn(t2));
      }, On);
      var gr = or(function(t2, e2, n2) {
        return (5 === t2.i || 2 === t2.i) && (e2 = Ie(e2, 0 | e2[Q], n2, false), 2 == t2.i ? an(t2, Ke, e2) : e2.push(Ke(t2.g)), true);
      }, function(t2, e2, n2) {
        if (null != (e2 = rr(Gt, e2)) && e2.length) {
          Sn(t2, n2, 2), bn(t2.g, 4 * e2.length);
          for (let r2 = 0; r2 < e2.length; r2++)
            n2 = t2.g, Ut(e2[r2]), wn(n2);
        }
      }, On);
      var pr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, We(t2.g, Bt)), true);
      }, ar, Ln);
      var mr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, 0 === (t2 = We(t2.g, Bt)) ? void 0 : t2), true);
      }, ar, Ln);
      var yr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, We(t2.g, Pt)), true);
      }, function(t2, e2, n2) {
        if (null != (e2 = Xt(e2))) {
          if ("string" == typeof e2)
            hn(e2);
          if (null != e2)
            switch (Sn(t2, n2, 0), typeof e2) {
              case "number":
                t2 = t2.g, xt(e2), yn(t2, Et, It);
                break;
              case "bigint":
                n2 = BigInt.asUintN(64, e2), n2 = new fn(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), yn(t2.g, n2.i, n2.g);
                break;
              default:
                n2 = hn(e2), yn(t2.g, n2.i, n2.g);
            }
        }
      }, Tn());
      var br = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, qe(t2.g)), true);
      }, ur, Bn);
      var vr = or(function(t2, e2, n2) {
        return (0 === t2.i || 2 === t2.i) && (e2 = Ie(e2, 0 | e2[Q], n2, false), 2 == t2.i ? an(t2, qe, e2) : e2.push(qe(t2.g)), true);
      }, function(t2, e2, n2) {
        if (null != (e2 = rr(Rt, e2)) && e2.length) {
          n2 = An(t2, n2);
          for (let n3 = 0; n3 < e2.length; n3++)
            vn(t2.g, e2[n3]);
          En(t2, n2);
        }
      }, Bn);
      var wr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, 0 === (t2 = qe(t2.g)) ? void 0 : t2), true);
      }, ur, Bn);
      var _r = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, He(t2.g)), true);
      }, cr, Un);
      var Sr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, false === (t2 = He(t2.g)) ? void 0 : t2), true);
      }, cr, Un);
      var Ar = or(function(t2, e2, n2) {
        return 2 === t2.i && (t2 = on(t2), Ie(e2, 0 | e2[Q], n2, false).push(t2), true);
      }, function(t2, e2, n2) {
        if (null != (e2 = rr(Qt, e2)))
          for (let s2 = 0; s2 < e2.length; s2++) {
            var r2 = t2, i2 = n2, o2 = e2[s2];
            null != o2 && In(r2, i2, u(o2));
          }
      }, Pn);
      var Er = ir(function(t2, e2, n2) {
        return 2 === t2.i && (sr(e2, n2, "" === (t2 = on(t2)) ? void 0 : t2), true);
      }, lr, Pn);
      var Ir = ir(function(t2, e2, n2) {
        return 2 === t2.i && (sr(e2, n2, on(t2)), true);
      }, lr, Pn);
      var Tr = function(t2, e2, n2 = xn) {
        return new Nn(t2, e2, n2);
      }(function(t2, e2, n2, r2, i2) {
        return 2 === t2.i && (r2 = ue(void 0, r2, true), Ie(e2, 0 | e2[Q], n2, true).push(r2), rn(t2, r2, i2), true);
      }, function(t2, e2, n2, r2, i2) {
        if (Array.isArray(e2))
          for (let o2 = 0; o2 < e2.length; o2++)
            hr(t2, e2[o2], n2, r2, i2);
      });
      var xr = Vn(function(t2, e2, n2, r2, i2, o2) {
        return 2 === t2.i && (Ue(e2, 0 | e2[Q], o2, n2), rn(t2, e2 = Be(e2, r2, n2), i2), true);
      }, hr);
      var Ur = ir(function(t2, e2, n2) {
        return 2 === t2.i && (sr(e2, n2, sn(t2)), true);
      }, fr, kn);
      var Pr = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, 0 === (t2 = qe(t2.g) >>> 0) ? void 0 : t2), true);
      }, function(t2, e2, n2) {
        e2 = function(t3) {
          if (null == t3)
            return t3;
          if ("string" == typeof t3 && t3)
            t3 = +t3;
          else if ("number" != typeof t3)
            return;
          return Ct(t3) ? t3 >>> 0 : void 0;
        }(e2), null != e2 && null != e2 && (Sn(t2, n2, 0), bn(t2.g, e2));
      }, Tn());
      var Br = ir(function(t2, e2, n2) {
        return 0 === t2.i && (sr(e2, n2, qe(t2.g)), true);
      }, function(t2, e2, n2) {
        null != (e2 = Rt(e2)) && (e2 = parseInt(e2, 10), Sn(t2, n2, 0), vn(t2.g, e2));
      }, Fn);
      var Lr = class {
        constructor(t2, e2) {
          this.i = t2, this.g = e2, this.j = Ne, this.defaultValue = void 0;
        }
        register() {
          _(this);
        }
      };
      function Or(t2, e2) {
        return (n2, r2) => {
          if (un.length) {
            const t3 = un.pop();
            t3.o(r2), Je(t3.g, n2, r2), n2 = t3;
          } else
            n2 = new class {
              constructor(t3, e3) {
                if (tn.length) {
                  const n3 = tn.pop();
                  Je(n3, t3, e3), t3 = n3;
                } else
                  t3 = new class {
                    constructor(t4, e4) {
                      this.i = null, this.m = false, this.g = this.j = this.u = 0, Je(this, t4, e4);
                    }
                    clear() {
                      this.i = null, this.m = false, this.g = this.j = this.u = 0, this.C = false;
                    }
                  }(t3, e3);
                this.g = t3, this.j = this.g.g, this.i = this.m = -1, this.o(e3);
              }
              o({ D: t3 = false } = {}) {
                this.D = t3;
              }
            }(n2, r2);
          try {
            const r3 = new t2(), o2 = r3.l;
            Yn(e2)(o2, n2);
            var i2 = r3;
          } finally {
            n2.g.clear(), n2.m = -1, n2.i = -1, un.length < 100 && un.push(n2);
          }
          return i2;
        };
      }
      var kr = [0, Er, ir(function(t2, e2, n2) {
        return 2 === t2.i && (sr(e2, n2, (t2 = sn(t2)) === V() ? void 0 : t2), true);
      }, function(t2, e2, n2) {
        if (null != e2) {
          if (e2 instanceof ln) {
            const r2 = e2.O;
            return void (r2 && (e2 = r2(e2), null != e2 && In(t2, n2, Re(e2).buffer)));
          }
          if (Array.isArray(e2))
            return;
        }
        fr(t2, e2, n2);
      }, kn)];
      var Fr;
      var Nr = globalThis.trustedTypes;
      function Vr(t2) {
        void 0 === Fr && (Fr = function() {
          let t3 = null;
          if (!Nr)
            return t3;
          try {
            const e3 = (t4) => t4;
            t3 = Nr.createPolicy("goog#html", { createHTML: e3, createScript: e3, createScriptURL: e3 });
          } catch (t4) {
          }
          return t3;
        }());
        var e2 = Fr;
        return new class {
          constructor(t3) {
            this.g = t3;
          }
          toString() {
            return this.g + "";
          }
        }(e2 ? e2.createScriptURL(t2) : t2);
      }
      function jr(t2, ...e2) {
        if (0 === e2.length)
          return Vr(t2[0]);
        let n2 = t2[0];
        for (let r2 = 0; r2 < e2.length; r2++)
          n2 += encodeURIComponent(e2[r2]) + t2[r2 + 1];
        return Vr(n2);
      }
      var Cr = [0, br, Br, _r, -1, vr, Br, -1];
      var Mr = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var Gr = [0, _r, Ir, _r, Br, -1, or(function(t2, e2, n2) {
        return (0 === t2.i || 2 === t2.i) && (e2 = Ie(e2, 0 | e2[Q], n2, false), 2 == t2.i ? an(t2, Xe, e2) : e2.push(qe(t2.g)), true);
      }, function(t2, e2, n2) {
        if (null != (e2 = rr(Rt, e2)) && e2.length) {
          n2 = An(t2, n2);
          for (let n3 = 0; n3 < e2.length; n3++)
            vn(t2.g, e2[n3]);
          En(t2, n2);
        }
      }, Fn), Ir, -1, [0, _r, -1], Br, _r, -1];
      var Dr = [0, Ir, -2];
      var $r = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var zr = [0];
      var Rr = [0, br, _r, 1, _r, -3];
      var Wr = class extends ln {
        constructor(t2) {
          super(t2, 2);
        }
      };
      var Hr = {};
      Hr[336783863] = [0, Ir, _r, -1, br, [0, [1, 2, 3, 4, 5, 6, 7, 8, 9], xr, zr, xr, Gr, xr, Dr, xr, Rr, xr, Cr, xr, [0, Ir, -2], xr, [0, Ir, Br], xr, [0, Br, Ir, -1], xr, [0, Br, -1]], [0, Ir], _r, [0, [1, 3], [2, 4], xr, [0, vr], -1, xr, [0, Ar], -1, Tr, [0, Ir, -1]], Ir];
      var qr = [0, mr, -1, Sr, -3, mr, vr, Er, wr, mr, -1, Sr, wr, Sr, -2, Er];
      function Kr(t2) {
        Me(t2, 3, "TEXT:text_in");
      }
      var Xr = class extends ln {
        constructor(t2) {
          super(t2, 500);
        }
        o(t2) {
          return Ne(this, 0, 7, t2);
        }
      };
      var Jr = [-1, {}];
      var Yr = [0, Ir, 1, Jr];
      var Qr = [0, Ir, Ar, Jr];
      function Zr(t2) {
        Me(t2, 10, "text_in");
      }
      var ti;
      var ei = class extends ln {
        constructor(t2) {
          super(t2, 500);
        }
        o(t2) {
          return Ne(this, 0, 1001, t2);
        }
      };
      ei.prototype.g = (ti = [-500, Tr, [-500, Er, -1, Ar, -3, [-2, Hr, _r], Tr, kr, wr, -1, Yr, Qr, Tr, [0, Er, Sr], Er, qr, wr, Ar, 987, Ar], 4, Tr, [-500, Ir, -1, [-1, {}], 998, Ir], Tr, [-500, Ir, Ar, -1, [-2, {}, _r], 997, Ar, -1], wr, Tr, [-500, Ir, Ar, Jr, 998, Ar], Ar, wr, Yr, Qr, Tr, [0, Er, -1, Jr], Ar, -2, qr, Er, -1, Sr, [0, Sr, Pr], 978, Jr, Tr, kr], function() {
        const t2 = new class {
          constructor() {
            this.j = [], this.i = 0, this.g = new class {
              constructor() {
                this.g = [];
              }
              length() {
                return this.g.length;
              }
              end() {
                const t3 = this.g;
                return this.g = [], t3;
              }
            }();
          }
        }();
        nr(this.l, t2, Hn(Gn, Zn, tr, ti)), _n(t2, t2.g.end());
        const e2 = new Uint8Array(t2.i), n2 = t2.j, r2 = n2.length;
        let i2 = 0;
        for (let t3 = 0; t3 < r2; t3++) {
          const r3 = n2[t3];
          e2.set(r3, i2), i2 += r3.length;
        }
        return t2.j = [e2], e2;
      });
      var ni = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var ri = class extends ln {
        constructor(t2) {
          super(t2);
        }
        g() {
          return Fe(this, ni);
        }
      };
      var ii = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var oi = Or(class extends ln {
        constructor(t2) {
          super(t2);
        }
      }, [0, Tr, [0, 1, br, Ir, [0, Tr, [0, br, dr, Ir, -1]]], pr]);
      var si = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var ai = class extends ln {
        constructor(t2) {
          super(t2);
        }
        H() {
          const t2 = be(this);
          return null == t2 ? V() : t2;
        }
      };
      var ui = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var ci = [1, 2];
      var li = Or(class extends ln {
        constructor(t2) {
          super(t2);
        }
      }, [0, Tr, [0, ci, xr, [0, gr], xr, [0, Ur], br, Ir], pr]);
      var hi = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var fi = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var di = [0, _r, -1];
      var gi = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var pi = [1, 2, 3, 4, 5];
      var mi = class extends ln {
        constructor(t2) {
          super(t2);
        }
        g() {
          return null != be(this);
        }
        i() {
          return null != Qt(ge(this, 2));
        }
      };
      var yi = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var bi = [0, [0, Ur, Ir, [0, br, pr, -1], [0, yr, pr]], _r, [0, pi, xr, Rr, xr, Gr, xr, Cr, xr, zr, xr, Dr], Br];
      var vi = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var wi = new Lr(462704549, vi);
      Hr[462704549] = [0, bi, [0, Ir, br, dr, Ar, -1]];
      var _i = class extends ln {
        constructor(t2) {
          super(t2);
        }
      };
      var Si = new Lr(477589892, _i);
      function Ai(t2, e2) {
        if (e2 = e2 ? he(e2) : new hi(), void 0 !== t2.displayNamesLocale ? me(e2, 1, Yt(t2.displayNamesLocale)) : void 0 === t2.displayNamesLocale && me(e2, 1), void 0 !== t2.maxResults) {
          var n2 = t2.maxResults;
          if (null != n2) {
            if ("number" != typeof n2)
              throw z();
            if (!Ct(n2))
              throw z();
            n2 |= 0;
          }
          me(e2, 2, n2);
        } else
          "maxResults" in t2 && me(e2, 2);
        if (void 0 !== t2.scoreThreshold) {
          if (null != (n2 = t2.scoreThreshold) && "number" != typeof n2)
            throw Error(`Value of float/double field must be a number, found ${typeof n2}: ${n2}`);
          me(e2, 3, n2);
        } else
          "scoreThreshold" in t2 && me(e2, 3);
        return void 0 !== t2.categoryAllowlist ? Ae(e2, 4, t2.categoryAllowlist) : "categoryAllowlist" in t2 && me(e2, 4), void 0 !== t2.categoryDenylist ? Ae(e2, 5, t2.categoryDenylist) : "categoryDenylist" in t2 && me(e2, 5), e2;
      }
      function Ei(t2) {
        const e2 = { classifications: Fe(t2, ii).map((t3) => function(t4, e3 = -1, n2 = "") {
          return { categories: t4.map((t5) => {
            var e4 = Rt(ge(t5, 1)) ?? 0 ?? -1;
            const n3 = t5.l;
            let r2 = 0 | n3[Q];
            const i2 = pe(n3, r2, 2), o2 = Gt(i2);
            return null != o2 && o2 !== i2 && ye(n3, r2, 2, o2), { index: e4, score: o2 ?? 0 ?? 0, categoryName: Qt(ge(t5, 3)) ?? "" ?? "", displayName: Qt(ge(t5, 4)) ?? "" ?? "" };
          }), headIndex: e3, headName: n2 };
        }(Oe(t3, ri, 4)?.g() ?? [], Rt(ge(t3, 2)) ?? 0, Qt(ge(t3, 3)) ?? "")) };
        return null != Kt(ge(t2, 2)) && (e2.timestampMs = Kt(ge(t2, 2)) ?? 0), e2;
      }
      function Ii(t2) {
        return Array.from(t2, (t3) => t3 > 127 ? t3 - 256 : t3);
      }
      function Ti(t2, e2) {
        if (t2.length !== e2.length)
          throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t2.length} vs. ${e2.length}).`);
        let n2 = 0, r2 = 0, i2 = 0;
        for (let o2 = 0; o2 < t2.length; o2++)
          n2 += t2[o2] * e2[o2], r2 += t2[o2] * t2[o2], i2 += e2[o2] * e2[o2];
        if (r2 <= 0 || i2 <= 0)
          throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
        return n2 / Math.sqrt(r2 * i2);
      }
      var xi;
      Hr[477589892] = [0, bi, di];
      var Ui = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
      async function Pi() {
        if (void 0 === xi)
          try {
            await WebAssembly.instantiate(Ui), xi = true;
          } catch {
            xi = false;
          }
        return xi;
      }
      async function Bi(t2, e2 = jr``) {
        const n2 = await Pi() ? "wasm_internal" : "wasm_nosimd_internal";
        return { wasmLoaderPath: `${e2}/${t2}_${n2}.js`, wasmBinaryPath: `${e2}/${t2}_${n2}.wasm` };
      }
      var Li = class {
      };
      function Oi() {
        var t2 = navigator;
        return "undefined" != typeof OffscreenCanvas && (!function(t3 = navigator) {
          return (t3 = t3.userAgent).includes("Safari") && !t3.includes("Chrome");
        }(t2) || !!((t2 = t2.userAgent.match(/Version\/([\d]+).*Safari/)) && t2.length >= 1 && Number(t2[1]) >= 17));
      }
      async function ki(t2) {
        if ("function" != typeof importScripts) {
          const e2 = document.createElement("script");
          return e2.src = t2.toString(), e2.crossOrigin = "anonymous", new Promise((t3, n2) => {
            e2.addEventListener("load", () => {
              t3();
            }, false), e2.addEventListener("error", (t4) => {
              n2(t4);
            }, false), document.body.appendChild(e2);
          });
        }
        importScripts(t2.toString());
      }
      Li.forVisionTasks = function(t2) {
        return Bi("vision", t2);
      }, Li.forTextTasks = function(t2) {
        return Bi("text", t2);
      }, Li.forGenAiExperimentalTasks = function(t2) {
        return Bi("genai_experimental", t2);
      }, Li.forGenAiTasks = function(t2) {
        return Bi("genai", t2);
      }, Li.forAudioTasks = function(t2) {
        return Bi("audio", t2);
      }, Li.isSimdSupported = function() {
        return Pi();
      };
      function Fi(t2, e2, n2) {
        t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n2(e2 = t2.h.stringToNewUTF8(e2)), t2.h._free(e2);
      }
      function Ni(t2, e2, n2) {
        t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
        const r2 = new Uint32Array(e2.length);
        for (let n3 = 0; n3 < e2.length; n3++)
          r2[n3] = t2.h.stringToNewUTF8(e2[n3]);
        e2 = t2.h._malloc(4 * r2.length), t2.h.HEAPU32.set(r2, e2 >> 2), n2(e2);
        for (const e3 of r2)
          t2.h._free(e3);
        t2.h._free(e2);
      }
      function Vi(t2, e2, n2) {
        t2.h.simpleListeners = t2.h.simpleListeners || {}, t2.h.simpleListeners[e2] = n2;
      }
      function ji(t2, e2, n2) {
        let r2 = [];
        t2.h.simpleListeners = t2.h.simpleListeners || {}, t2.h.simpleListeners[e2] = (t3, e3, i2) => {
          e3 ? (n2(r2, i2), r2 = []) : r2.push(t3);
        };
      }
      var Ci = /* @__PURE__ */ function(t2) {
        return class extends t2 {
          M() {
            this.h._registerModelResourcesGraphService();
          }
        };
      }(class {
        constructor(t2, e2) {
          this.j = true, this.h = t2, this.g = null, this.i = 0, this.m = "function" == typeof this.h._addIntToInputStream, void 0 !== e2 ? this.h.canvas = e2 : Oi() ? this.h.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.h.canvas = document.createElement("canvas"));
        }
        async initializeGraph(t2) {
          const e2 = await (await fetch(t2)).arrayBuffer();
          t2 = !(t2.endsWith(".pbtxt") || t2.endsWith(".textproto")), this.setGraph(new Uint8Array(e2), t2);
        }
        setGraphFromString(t2) {
          this.setGraph(new TextEncoder().encode(t2), false);
        }
        setGraph(t2, e2) {
          const n2 = t2.length, r2 = this.h._malloc(n2);
          this.h.HEAPU8.set(t2, r2), e2 ? this.h._changeBinaryGraph(n2, r2) : this.h._changeTextGraph(n2, r2), this.h._free(r2);
        }
        configureAudio(t2, e2, n2, r2, i2) {
          this.h._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), Fi(this, r2 || "input_audio", (r3) => {
            Fi(this, i2 = i2 || "audio_header", (i3) => {
              this.h._configureAudio(r3, i3, t2, e2 ?? 0, n2);
            });
          });
        }
        setAutoResizeCanvas(t2) {
          this.j = t2;
        }
        setAutoRenderToScreen(t2) {
          this.h._setAutoRenderToScreen(t2);
        }
        setGpuBufferVerticalFlip(t2) {
          this.h.gpuOriginForWebTexturesIsBottomLeft = t2;
        }
        attachErrorListener(t2) {
          this.h.errorListener = t2;
        }
        attachEmptyPacketListener(t2, e2) {
          this.h.emptyPacketListeners = this.h.emptyPacketListeners || {}, this.h.emptyPacketListeners[t2] = e2;
        }
        addAudioToStream(t2, e2, n2) {
          this.addAudioToStreamWithShape(t2, 0, 0, e2, n2);
        }
        addAudioToStreamWithShape(t2, e2, n2, r2, i2) {
          const o2 = 4 * t2.length;
          this.i !== o2 && (this.g && this.h._free(this.g), this.g = this.h._malloc(o2), this.i = o2), this.h.HEAPF32.set(t2, this.g / 4), Fi(this, r2, (t3) => {
            this.h._addAudioToInputStream(this.g, e2, n2, t3, i2);
          });
        }
        addGpuBufferToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            if (!this.h.canvas)
              throw Error("No OpenGL canvas configured.");
            e3 ? this.h._bindTextureToStream(e3) : this.h._bindTextureToCanvas();
            const r2 = this.h.canvas.getContext("webgl2") || this.h.canvas.getContext("webgl");
            if (!r2)
              throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
            this.h.gpuOriginForWebTexturesIsBottomLeft && r2.pixelStorei(r2.UNPACK_FLIP_Y_WEBGL, true), r2.texImage2D(r2.TEXTURE_2D, 0, r2.RGBA, r2.RGBA, r2.UNSIGNED_BYTE, t2), this.h.gpuOriginForWebTexturesIsBottomLeft && r2.pixelStorei(r2.UNPACK_FLIP_Y_WEBGL, false);
            const [i2, o2] = void 0 !== t2.videoWidth ? [t2.videoWidth, t2.videoHeight] : void 0 !== t2.naturalWidth ? [t2.naturalWidth, t2.naturalHeight] : void 0 !== t2.displayWidth ? [t2.displayWidth, t2.displayHeight] : [t2.width, t2.height];
            !this.j || i2 === this.h.canvas.width && o2 === this.h.canvas.height || (this.h.canvas.width = i2, this.h.canvas.height = o2);
            const [s2, a2] = [i2, o2];
            this.h._addBoundTextureToStream(e3, s2, a2, n2);
          });
        }
        addBoolToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            this.h._addBoolToInputStream(t2, e3, n2);
          });
        }
        addDoubleToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            this.h._addDoubleToInputStream(t2, e3, n2);
          });
        }
        addFloatToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            this.h._addFloatToInputStream(t2, e3, n2);
          });
        }
        addIntToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            this.h._addIntToInputStream(t2, e3, n2);
          });
        }
        addUintToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            this.h._addUintToInputStream(t2, e3, n2);
          });
        }
        addStringToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            Fi(this, t2, (t3) => {
              this.h._addStringToInputStream(t3, e3, n2);
            });
          });
        }
        addStringRecordToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            Ni(this, Object.keys(t2), (r2) => {
              Ni(this, Object.values(t2), (i2) => {
                this.h._addFlatHashMapToInputStream(r2, i2, Object.keys(t2).length, e3, n2);
              });
            });
          });
        }
        addProtoToStream(t2, e2, n2, r2) {
          Fi(this, n2, (n3) => {
            Fi(this, e2, (e3) => {
              const i2 = this.h._malloc(t2.length);
              this.h.HEAPU8.set(t2, i2), this.h._addProtoToInputStream(i2, t2.length, e3, n3, r2), this.h._free(i2);
            });
          });
        }
        addEmptyPacketToStream(t2, e2) {
          Fi(this, t2, (t3) => {
            this.h._addEmptyPacketToInputStream(t3, e2);
          });
        }
        addBoolVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateBoolVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e4 of t2)
              this.h._addBoolVectorEntry(r2, e4);
            this.h._addBoolVectorToInputStream(r2, e3, n2);
          });
        }
        addDoubleVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateDoubleVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e4 of t2)
              this.h._addDoubleVectorEntry(r2, e4);
            this.h._addDoubleVectorToInputStream(r2, e3, n2);
          });
        }
        addFloatVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateFloatVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e4 of t2)
              this.h._addFloatVectorEntry(r2, e4);
            this.h._addFloatVectorToInputStream(r2, e3, n2);
          });
        }
        addIntVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateIntVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e4 of t2)
              this.h._addIntVectorEntry(r2, e4);
            this.h._addIntVectorToInputStream(r2, e3, n2);
          });
        }
        addUintVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateUintVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new unsigned int vector on heap.");
            for (const e4 of t2)
              this.h._addUintVectorEntry(r2, e4);
            this.h._addUintVectorToInputStream(r2, e3, n2);
          });
        }
        addStringVectorToStream(t2, e2, n2) {
          Fi(this, e2, (e3) => {
            const r2 = this.h._allocateStringVector(t2.length);
            if (!r2)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e4 of t2)
              Fi(this, e4, (t3) => {
                this.h._addStringVectorEntry(r2, t3);
              });
            this.h._addStringVectorToInputStream(r2, e3, n2);
          });
        }
        addBoolToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            this.h._addBoolToInputSidePacket(t2, e3);
          });
        }
        addDoubleToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            this.h._addDoubleToInputSidePacket(t2, e3);
          });
        }
        addFloatToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            this.h._addFloatToInputSidePacket(t2, e3);
          });
        }
        addIntToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            this.h._addIntToInputSidePacket(t2, e3);
          });
        }
        addUintToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            this.h._addUintToInputSidePacket(t2, e3);
          });
        }
        addStringToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            Fi(this, t2, (t3) => {
              this.h._addStringToInputSidePacket(t3, e3);
            });
          });
        }
        addProtoToInputSidePacket(t2, e2, n2) {
          Fi(this, n2, (n3) => {
            Fi(this, e2, (e3) => {
              const r2 = this.h._malloc(t2.length);
              this.h.HEAPU8.set(t2, r2), this.h._addProtoToInputSidePacket(r2, t2.length, e3, n3), this.h._free(r2);
            });
          });
        }
        addBoolVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateBoolVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new bool vector on heap.");
            for (const e4 of t2)
              this.h._addBoolVectorEntry(n2, e4);
            this.h._addBoolVectorToInputSidePacket(n2, e3);
          });
        }
        addDoubleVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateDoubleVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new double vector on heap.");
            for (const e4 of t2)
              this.h._addDoubleVectorEntry(n2, e4);
            this.h._addDoubleVectorToInputSidePacket(n2, e3);
          });
        }
        addFloatVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateFloatVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new float vector on heap.");
            for (const e4 of t2)
              this.h._addFloatVectorEntry(n2, e4);
            this.h._addFloatVectorToInputSidePacket(n2, e3);
          });
        }
        addIntVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateIntVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new int vector on heap.");
            for (const e4 of t2)
              this.h._addIntVectorEntry(n2, e4);
            this.h._addIntVectorToInputSidePacket(n2, e3);
          });
        }
        addUintVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateUintVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new unsigned int vector on heap.");
            for (const e4 of t2)
              this.h._addUintVectorEntry(n2, e4);
            this.h._addUintVectorToInputSidePacket(n2, e3);
          });
        }
        addStringVectorToInputSidePacket(t2, e2) {
          Fi(this, e2, (e3) => {
            const n2 = this.h._allocateStringVector(t2.length);
            if (!n2)
              throw Error("Unable to allocate new string vector on heap.");
            for (const e4 of t2)
              Fi(this, e4, (t3) => {
                this.h._addStringVectorEntry(n2, t3);
              });
            this.h._addStringVectorToInputSidePacket(n2, e3);
          });
        }
        attachBoolListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachBoolListener(t3);
          });
        }
        attachBoolVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachBoolVectorListener(t3);
          });
        }
        attachIntListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachIntListener(t3);
          });
        }
        attachIntVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachIntVectorListener(t3);
          });
        }
        attachUintListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachUintListener(t3);
          });
        }
        attachUintVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachUintVectorListener(t3);
          });
        }
        attachDoubleListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachDoubleListener(t3);
          });
        }
        attachDoubleVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachDoubleVectorListener(t3);
          });
        }
        attachFloatListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachFloatListener(t3);
          });
        }
        attachFloatVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachFloatVectorListener(t3);
          });
        }
        attachStringListener(t2, e2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachStringListener(t3);
          });
        }
        attachStringVectorListener(t2, e2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachStringVectorListener(t3);
          });
        }
        attachProtoListener(t2, e2, n2) {
          Vi(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachProtoListener(t3, n2 || false);
          });
        }
        attachProtoVectorListener(t2, e2, n2) {
          ji(this, t2, e2), Fi(this, t2, (t3) => {
            this.h._attachProtoVectorListener(t3, n2 || false);
          });
        }
        attachAudioListener(t2, e2, n2) {
          this.h._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), Vi(this, t2, (t3, n3) => {
            t3 = new Float32Array(t3.buffer, t3.byteOffset, t3.length / 4), e2(t3, n3);
          }), Fi(this, t2, (t3) => {
            this.h._attachAudioListener(t3, n2 || false);
          });
        }
        finishProcessing() {
          this.h._waitUntilIdle();
        }
        closeGraph() {
          this.h._closeGraph(), this.h.simpleListeners = void 0, this.h.emptyPacketListeners = void 0;
        }
      });
      var Mi = class extends Ci {
      };
      async function Gi(t2, e2, n2) {
        return t2 = await (async (t3, e3, n3, r2) => {
          if (e3 && await ki(e3), !self.ModuleFactory)
            throw Error("ModuleFactory not set.");
          if (n3 && (await ki(n3), !self.ModuleFactory))
            throw Error("ModuleFactory not set.");
          return self.Module && r2 && ((e3 = self.Module).locateFile = r2.locateFile, r2.mainScriptUrlOrBlob && (e3.mainScriptUrlOrBlob = r2.mainScriptUrlOrBlob)), r2 = await self.ModuleFactory(self.Module || r2), self.ModuleFactory = self.Module = void 0, new t3(r2, null);
        })(t2, e2.wasmLoaderPath, e2.assetLoaderPath, { locateFile: (t3) => t3.endsWith(".wasm") ? e2.wasmBinaryPath.toString() : e2.assetBinaryPath && t3.endsWith(".data") ? e2.assetBinaryPath.toString() : t3 }), await t2.o(n2), t2;
      }
      async function Di(t2, e2, n2) {
        return Gi(t2, e2, n2);
      }
      function $i(t2, e2) {
        const n2 = Oe(t2.baseOptions, mi, 1) || new mi();
        "string" == typeof e2 ? (me(n2, 2, Yt(e2)), me(n2, 1)) : e2 instanceof Uint8Array && (me(n2, 1, lt(e2, false)), me(n2, 2)), Ne(t2.baseOptions, 0, 1, n2);
      }
      function zi(t2, e2) {
        const n2 = e2.baseOptions || {};
        if (e2.baseOptions?.modelAssetBuffer && e2.baseOptions?.modelAssetPath)
          throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
        if (!(Oe(t2.baseOptions, mi, 1)?.g() || Oe(t2.baseOptions, mi, 1)?.i() || e2.baseOptions?.modelAssetBuffer || e2.baseOptions?.modelAssetPath))
          throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
        if (function(t3, e3) {
          let n3 = Oe(t3.baseOptions, gi, 3);
          if (!n3) {
            var r2 = n3 = new gi();
            Ve(r2, 4, new $r());
          }
          "delegate" in e3 && ("GPU" === e3.delegate ? Ve(e3 = n3, 2, r2 = new Mr()) : Ve(e3 = n3, 4, r2 = new $r())), Ne(t3.baseOptions, 0, 3, n3);
        }(t2, n2), n2.modelAssetPath)
          return fetch(n2.modelAssetPath.toString()).then((t3) => {
            if (t3.ok)
              return t3.arrayBuffer();
            throw Error(`Failed to fetch model: ${n2.modelAssetPath} (${t3.status})`);
          }).then((e3) => {
            try {
              t2.g.h.FS_unlink("/model.dat");
            } catch {
            }
            t2.g.h.FS_createDataFile("/", "model.dat", new Uint8Array(e3), true, false, false), $i(t2, "/model.dat"), t2.u();
          });
        if (n2.modelAssetBuffer instanceof Uint8Array)
          $i(t2, n2.modelAssetBuffer);
        else if (n2.modelAssetBuffer)
          return async function(t3) {
            const e3 = [];
            for (var n3 = 0; ; ) {
              const { done: r2, value: i2 } = await t3.read();
              if (r2)
                break;
              e3.push(i2), n3 += i2.length;
            }
            if (0 === e3.length)
              return new Uint8Array(0);
            if (1 === e3.length)
              return e3[0];
            t3 = new Uint8Array(n3), n3 = 0;
            for (const r2 of e3)
              t3.set(r2, n3), n3 += r2.length;
            return t3;
          }(n2.modelAssetBuffer).then((e3) => {
            $i(t2, e3), t2.u();
          });
        return t2.u(), Promise.resolve();
      }
      function Ri(t2) {
        try {
          const e2 = t2.m.length;
          if (1 === e2)
            throw Error(t2.m[0].message);
          if (e2 > 1)
            throw Error("Encountered multiple errors: " + t2.m.map((t3) => t3.message).join(", "));
        } finally {
          t2.m = [];
        }
      }
      function Wi(t2, e2) {
        t2.j = Math.max(t2.j, e2);
      }
      var Hi = class {
        constructor(t2) {
          this.g = t2, this.m = [], this.j = 0, this.g.setAutoRenderToScreen(false);
        }
        setGraph(t2, e2) {
          this.g.attachErrorListener((t3, e3) => {
            this.m.push(Error(e3));
          }), this.g.M(), this.g.setGraph(t2, e2), Ri(this);
        }
        finishProcessing() {
          this.g.finishProcessing(), Ri(this);
        }
        close() {
          this.g.closeGraph();
        }
      };
      Hi.prototype.close = Hi.prototype.close;
      var qi = class extends Hi {
        constructor(t2, e2) {
          super(new Mi(t2, e2)), this.s = { languages: [] }, Ne(t2 = this.i = new vi(), 0, 1, e2 = new yi());
        }
        o(t2) {
          return Ne(this.i, 0, 2, Ai(t2, Oe(this.i, hi, 2))), zi(this, t2);
        }
        get baseOptions() {
          return Oe(this.i, yi, 1);
        }
        set baseOptions(t2) {
          Ne(this.i, 0, 1, t2);
        }
        J(t2) {
          return this.s = { languages: [] }, this.g.addStringToStream(t2, "text_in", this.j + 1), this.finishProcessing(), this.s;
        }
        u() {
          var t2 = new ei();
          Zr(t2), Me(t2, 15, "classifications_out");
          const e2 = new Wr();
          cn(e2, wi, this.i);
          const n2 = new Xr();
          Ee(n2, Yt("mediapipe.tasks.text.text_classifier.TextClassifierGraph")), Kr(n2), Me(n2, 4, "CLASSIFICATIONS:classifications_out"), n2.o(e2), Ge(t2, n2), this.g.attachProtoListener("classifications_out", (t3, e3) => {
            if ({ classifications: t3 } = Ei(oi(t3)), 1 !== t3.length)
              throw Error(`Expected 1 classification head, got ${t3.length}`);
            this.s.languages = t3[0].categories.map((t4) => ({ languageCode: t4.categoryName, probability: t4.score })), Wi(this, e3);
          }), this.g.attachEmptyPacketListener("classifications_out", (t3) => {
            Wi(this, t3);
          }), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
        }
      };
      qi.prototype.detect = qi.prototype.J, qi.prototype.setOptions = qi.prototype.o, qi.createFromModelPath = function(t2, e2) {
        return Di(qi, t2, { baseOptions: { modelAssetPath: e2 } });
      }, qi.createFromModelBuffer = function(t2, e2) {
        return Di(qi, t2, { baseOptions: { modelAssetBuffer: e2 } });
      }, qi.createFromOptions = function(t2, e2) {
        return Di(qi, t2, e2);
      };
      var Ki = class extends Hi {
        constructor(t2, e2) {
          super(new Mi(t2, e2)), this.s = { classifications: [] }, Ne(t2 = this.i = new vi(), 0, 1, e2 = new yi());
        }
        o(t2) {
          return Ne(this.i, 0, 2, Ai(t2, Oe(this.i, hi, 2))), zi(this, t2);
        }
        get baseOptions() {
          return Oe(this.i, yi, 1);
        }
        set baseOptions(t2) {
          Ne(this.i, 0, 1, t2);
        }
        I(t2) {
          return this.s = { classifications: [] }, this.g.addStringToStream(t2, "text_in", this.j + 1), this.finishProcessing(), this.s;
        }
        u() {
          var t2 = new ei();
          Zr(t2), Me(t2, 15, "classifications_out");
          const e2 = new Wr();
          cn(e2, wi, this.i);
          const n2 = new Xr();
          Ee(n2, Yt("mediapipe.tasks.text.text_classifier.TextClassifierGraph")), Kr(n2), Me(n2, 4, "CLASSIFICATIONS:classifications_out"), n2.o(e2), Ge(t2, n2), this.g.attachProtoListener("classifications_out", (t3, e3) => {
            this.s = Ei(oi(t3)), Wi(this, e3);
          }), this.g.attachEmptyPacketListener("classifications_out", (t3) => {
            Wi(this, t3);
          }), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
        }
      };
      Ki.prototype.classify = Ki.prototype.I, Ki.prototype.setOptions = Ki.prototype.o, Ki.createFromModelPath = function(t2, e2) {
        return Di(Ki, t2, { baseOptions: { modelAssetPath: e2 } });
      }, Ki.createFromModelBuffer = function(t2, e2) {
        return Di(Ki, t2, { baseOptions: { modelAssetBuffer: e2 } });
      }, Ki.createFromOptions = function(t2, e2) {
        return Di(Ki, t2, e2);
      };
      var Xi = class extends Hi {
        constructor(t2, e2) {
          super(new Mi(t2, e2)), this.s = { embeddings: [] }, Ne(t2 = this.i = new _i(), 0, 1, e2 = new yi());
        }
        o(t2) {
          var e2 = this.i, n2 = Oe(this.i, fi, 2);
          return n2 = n2 ? he(n2) : new fi(), void 0 !== t2.l2Normalize ? me(n2, 1, Dt(t2.l2Normalize)) : "l2Normalize" in t2 && me(n2, 1), void 0 !== t2.quantize ? me(n2, 2, Dt(t2.quantize)) : "quantize" in t2 && me(n2, 2), Ne(e2, 0, 2, n2), zi(this, t2);
        }
        get baseOptions() {
          return Oe(this.i, yi, 1);
        }
        set baseOptions(t2) {
          Ne(this.i, 0, 1, t2);
        }
        K(t2) {
          return this.g.addStringToStream(t2, "text_in", this.j + 1), this.finishProcessing(), this.s;
        }
        u() {
          var t2 = new ei();
          Zr(t2), Me(t2, 15, "embeddings_out");
          const e2 = new Wr();
          cn(e2, Si, this.i);
          const n2 = new Xr();
          Ee(n2, Yt("mediapipe.tasks.text.text_embedder.TextEmbedderGraph")), Kr(n2), Me(n2, 4, "EMBEDDINGS:embeddings_out"), n2.o(e2), Ge(t2, n2), this.g.attachProtoListener("embeddings_out", (t3, e3) => {
            t3 = li(t3), this.s = function(t4) {
              return { embeddings: Fe(t4, ui).map((t5) => {
                const e4 = { headIndex: Rt(ge(t5, 3)) ?? 0 ?? -1, headName: Qt(ge(t5, 4)) ?? "" ?? "" };
                if (void 0 !== Le(t5, si, Te(t5, 1)))
                  e4.floatEmbedding = ve(Oe(t5, si, Te(t5, 1)), 1, Gt, void 0 === gt ? 2 : 4).slice();
                else {
                  const n3 = new Uint8Array(0);
                  e4.quantizedEmbedding = Oe(t5, ai, Te(t5, 2))?.H()?.i() ?? n3;
                }
                return e4;
              }), timestampMs: Kt(ge(t4, 2)) ?? 0 };
            }(t3), Wi(this, e3);
          }), this.g.attachEmptyPacketListener("embeddings_out", (t3) => {
            Wi(this, t3);
          }), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
        }
      };
      Xi.cosineSimilarity = function(t2, e2) {
        if (t2.floatEmbedding && e2.floatEmbedding)
          t2 = Ti(t2.floatEmbedding, e2.floatEmbedding);
        else {
          if (!t2.quantizedEmbedding || !e2.quantizedEmbedding)
            throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
          t2 = Ti(Ii(t2.quantizedEmbedding), Ii(e2.quantizedEmbedding));
        }
        return t2;
      }, Xi.prototype.embed = Xi.prototype.K, Xi.prototype.setOptions = Xi.prototype.o, Xi.createFromModelPath = function(t2, e2) {
        return Di(Xi, t2, { baseOptions: { modelAssetPath: e2 } });
      }, Xi.createFromModelBuffer = function(t2, e2) {
        return Di(Xi, t2, { baseOptions: { modelAssetBuffer: e2 } });
      }, Xi.createFromOptions = function(t2, e2) {
        return Di(Xi, t2, e2);
      }, exports.FilesetResolver = Li, exports.LanguageDetector = qi, exports.TaskRunner = Hi, exports.TextClassifier = Ki, exports.TextEmbedder = Xi;
    }
  });

  // node_modules/@built-in-ai/core/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@built-in-ai/core/dist/index.js"(exports, module) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name16 in all)
          __defProp3(target, name16, { get: all[name16], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod);
      var index_exports = {};
      __export3(index_exports, {
        BuiltInAIChatLanguageModel: () => BuiltInAIChatLanguageModel,
        BuiltInAIEmbeddingModel: () => BuiltInAIEmbeddingModel,
        builtInAI: () => builtInAI2,
        createBuiltInAI: () => createBuiltInAI,
        doesBrowserSupportBuiltInAI: () => doesBrowserSupportBuiltInAI,
        isBuiltInAIModelAvailable: () => isBuiltInAIModelAvailable
      });
      module.exports = __toCommonJS(index_exports);
      var import_provider27 = require_dist();
      var import_provider28 = require_dist();
      function convertBase64ToUint8Array2(base643) {
        try {
          const binaryString = atob(base643);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes;
        } catch (error46) {
          throw new Error(`Failed to convert base64 to Uint8Array: ${error46}`);
        }
      }
      function convertFileData(data, mediaType) {
        if (data instanceof URL) {
          return data.toString();
        }
        if (data instanceof Uint8Array) {
          return data;
        }
        if (typeof data === "string") {
          return convertBase64ToUint8Array2(data);
        }
        console.warn(`Unexpected data type for ${mediaType}:`, typeof data);
        return data;
      }
      function convertToBuiltInAIMessages(prompt) {
        let systemMessage;
        const messages = [];
        for (const message of prompt) {
          switch (message.role) {
            case "system": {
              systemMessage = message.content;
              break;
            }
            case "user": {
              messages.push({
                role: "user",
                content: message.content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return {
                        type: "text",
                        value: part.text
                      };
                    }
                    case "file": {
                      const { mediaType, data, filename } = part;
                      if (mediaType?.startsWith("image/")) {
                        const convertedData = convertFileData(data, mediaType);
                        return {
                          type: "image",
                          value: convertedData
                        };
                      } else if (mediaType?.startsWith("audio/")) {
                        const convertedData = convertFileData(data, mediaType);
                        return {
                          type: "audio",
                          value: convertedData
                        };
                      } else {
                        throw new import_provider28.UnsupportedFunctionalityError({
                          functionality: `file type: ${mediaType}`
                        });
                      }
                    }
                    default: {
                      throw new import_provider28.UnsupportedFunctionalityError({
                        functionality: `content type: ${part.type}`
                      });
                    }
                  }
                })
              });
              break;
            }
            case "assistant": {
              let text2 = "";
              for (const part of message.content) {
                switch (part.type) {
                  case "text": {
                    text2 += part.text;
                    break;
                  }
                  case "tool-call": {
                    throw new import_provider28.UnsupportedFunctionalityError({
                      functionality: "tool calls"
                    });
                  }
                }
              }
              messages.push({
                role: "assistant",
                content: text2
              });
              break;
            }
            case "tool": {
              throw new import_provider28.UnsupportedFunctionalityError({
                functionality: "tool messages"
              });
            }
            default: {
              throw new Error(`Unsupported role: ${message.role}`);
            }
          }
        }
        return { systemMessage, messages };
      }
      function doesBrowserSupportBuiltInAI() {
        return typeof LanguageModel !== "undefined";
      }
      function isBuiltInAIModelAvailable() {
        return typeof LanguageModel !== "undefined";
      }
      function hasMultimodalContent(prompt) {
        for (const message of prompt) {
          if (message.role === "user") {
            for (const part of message.content) {
              if (part.type === "file") {
                return true;
              }
            }
          }
        }
        return false;
      }
      function getExpectedInputs(prompt) {
        const inputs = /* @__PURE__ */ new Set();
        for (const message of prompt) {
          if (message.role === "user") {
            for (const part of message.content) {
              if (part.type === "file") {
                if (part.mediaType?.startsWith("image/")) {
                  inputs.add("image");
                } else if (part.mediaType?.startsWith("audio/")) {
                  inputs.add("audio");
                }
              }
            }
          }
        }
        return Array.from(inputs).map((type) => ({ type }));
      }
      var BuiltInAIChatLanguageModel = class {
        constructor(modelId, options = {}) {
          this.specificationVersion = "v2";
          this.provider = "browser-ai";
          this.supportedUrls = {
            "image/*": [/^https?:\/\/.+$/],
            "audio/*": [/^https?:\/\/.+$/]
          };
          this.modelId = modelId;
          this.config = {
            provider: this.provider,
            modelId,
            options
          };
        }
        async getSession(options, expectedInputs, systemMessage, onDownloadProgress) {
          if (typeof LanguageModel === "undefined") {
            throw new import_provider27.LoadSettingError({
              message: "Prompt API is not available. This library requires Chrome or Edge browser with built-in AI capabilities."
            });
          }
          if (this.session)
            return this.session;
          const availability = await LanguageModel.availability();
          if (availability === "unavailable") {
            throw new import_provider27.LoadSettingError({ message: "Built-in model not available" });
          }
          const mergedOptions = {
            ...this.config.options,
            ...options
          };
          if (systemMessage) {
            mergedOptions.initialPrompts = [
              { role: "system", content: systemMessage }
            ];
          }
          if (expectedInputs && expectedInputs.length > 0) {
            mergedOptions.expectedInputs = expectedInputs;
          }
          if (onDownloadProgress) {
            mergedOptions.monitor = (m) => {
              m.addEventListener("downloadprogress", (e) => {
                onDownloadProgress(e.loaded);
              });
            };
          }
          this.session = await LanguageModel.create(mergedOptions);
          return this.session;
        }
        getArgs({
          prompt,
          maxOutputTokens,
          temperature,
          topP,
          topK,
          frequencyPenalty,
          presencePenalty,
          stopSequences,
          responseFormat,
          seed,
          tools
        }) {
          const warnings = [];
          if (tools && tools.length > 0) {
            warnings.push({
              type: "unsupported-setting",
              setting: "tools",
              details: "Tool calling is not yet supported by Prompt API"
            });
          }
          if (maxOutputTokens != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "maxOutputTokens",
              details: "maxOutputTokens is not supported by Prompt API"
            });
          }
          if (stopSequences != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "stopSequences",
              details: "stopSequences is not supported by Prompt API"
            });
          }
          if (topP != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "topP",
              details: "topP is not supported by Prompt API"
            });
          }
          if (presencePenalty != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "presencePenalty",
              details: "presencePenalty is not supported by Prompt API"
            });
          }
          if (frequencyPenalty != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "frequencyPenalty",
              details: "frequencyPenalty is not supported by Prompt API"
            });
          }
          if (seed != null) {
            warnings.push({
              type: "unsupported-setting",
              setting: "seed",
              details: "seed is not supported by Prompt API"
            });
          }
          const hasMultiModalInput = hasMultimodalContent(prompt);
          const { systemMessage, messages } = convertToBuiltInAIMessages(prompt);
          const promptOptions = {};
          if (responseFormat?.type === "json") {
            promptOptions.responseConstraint = responseFormat.schema;
          }
          if (temperature !== void 0) {
            promptOptions.temperature = temperature;
          }
          if (topK !== void 0) {
            promptOptions.topK = topK;
          }
          return {
            systemMessage,
            messages,
            warnings,
            promptOptions,
            hasMultiModalInput,
            expectedInputs: hasMultiModalInput ? getExpectedInputs(prompt) : void 0
          };
        }
        /**
         * Generates a complete text response using the browser's built-in Prompt API
         * @param options
         * @returns Promise resolving to the generated content with finish reason, usage stats, and any warnings
         * @throws {LoadSettingError} When the Prompt API is not available or model needs to be downloaded
         * @throws {UnsupportedFunctionalityError} When unsupported features like file input are used
         */
        async doGenerate(options) {
          const converted = this.getArgs(options);
          const { systemMessage, messages, warnings, promptOptions, expectedInputs } = converted;
          const session = await this.getSession(
            void 0,
            expectedInputs,
            systemMessage
          );
          const text2 = await session.prompt(messages, promptOptions);
          const content = [
            {
              type: "text",
              text: text2
            }
          ];
          return {
            content,
            finishReason: "stop",
            usage: {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            },
            request: { body: { messages, options: promptOptions } },
            warnings
          };
        }
        /**
         * Check the availability of the built-in AI model
         * @returns Promise resolving to "unavailable", "available", or "available-after-download"
         */
        async availability() {
          if (typeof LanguageModel === "undefined") {
            return "unavailable";
          }
          return LanguageModel.availability();
        }
        /**
         * Creates a session with download progress monitoring.
         *
         * @example
         * ```typescript
         * const session = await model.createSessionWithProgress(
         *   (progress) => {
         *     console.log(`Download progress: ${Math.round(progress * 100)}%`);
         *   }
         * );
         * ```
         *
         * @param onDownloadProgress Optional callback receiving progress values 0-1 during model download
         * @returns Promise resolving to a configured LanguageModel session
         * @throws {LoadSettingError} When the Prompt API is not available or model is unavailable
         */
        async createSessionWithProgress(onDownloadProgress) {
          return this.getSession(void 0, void 0, void 0, onDownloadProgress);
        }
        /**
         * Generates a streaming text response using the browser's built-in Prompt API
         * @param options
         * @returns Promise resolving to a readable stream of text chunks and request metadata
         * @throws {LoadSettingError} When the Prompt API is not available or model needs to be downloaded
         * @throws {UnsupportedFunctionalityError} When unsupported features like file input are used
         */
        async doStream(options) {
          const converted = this.getArgs(options);
          const {
            systemMessage,
            messages,
            warnings,
            promptOptions,
            expectedInputs,
            hasMultiModalInput
          } = converted;
          const session = await this.getSession(
            void 0,
            expectedInputs,
            systemMessage
          );
          const streamOptions = {
            ...promptOptions,
            signal: options.abortSignal
          };
          const promptStream = session.promptStreaming(messages, streamOptions);
          let isFirstChunk = true;
          const textId = "text-0";
          const stream = promptStream.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({
                  type: "stream-start",
                  warnings
                });
                if (options.abortSignal) {
                  options.abortSignal.addEventListener("abort", () => {
                    controller.terminate();
                  });
                }
              },
              transform(chunk, controller) {
                if (isFirstChunk) {
                  controller.enqueue({
                    type: "text-start",
                    id: textId
                  });
                  isFirstChunk = false;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: textId,
                  delta: chunk
                });
              },
              flush(controller) {
                controller.enqueue({
                  type: "text-end",
                  id: textId
                });
                controller.enqueue({
                  type: "finish",
                  finishReason: "stop",
                  usage: {
                    inputTokens: session.inputUsage,
                    outputTokens: void 0,
                    totalTokens: void 0
                  }
                });
              }
            })
          );
          return {
            stream,
            request: { body: { messages, options: promptOptions } }
          };
        }
      };
      var import_tasks_text = require_text_bundle();
      var BuiltInAIEmbeddingModel = class {
        constructor(settings = {}) {
          this.specificationVersion = "v2";
          this.provider = "google-mediapipe";
          this.modelId = "embedding";
          this.supportsParallelCalls = true;
          this.maxEmbeddingsPerCall = void 0;
          this.settings = {
            wasmLoaderPath: "https://pub-ddcfe353995744e89b8002f16bf98575.r2.dev/text_wasm_internal.js",
            wasmBinaryPath: "https://pub-ddcfe353995744e89b8002f16bf98575.r2.dev/text_wasm_internal.wasm",
            modelAssetPath: "https://pub-ddcfe353995744e89b8002f16bf98575.r2.dev/universal_sentence_encoder.tflite",
            l2Normalize: false,
            quantize: false
          };
          this.getTextEmbedder = async () => {
            return import_tasks_text.TextEmbedder.createFromOptions(
              {
                wasmBinaryPath: this.settings.wasmBinaryPath,
                wasmLoaderPath: this.settings.wasmLoaderPath
              },
              {
                baseOptions: {
                  modelAssetBuffer: await this.modelAssetBuffer,
                  delegate: this.settings.delegate
                },
                l2Normalize: this.settings.l2Normalize,
                quantize: this.settings.quantize
              }
            );
          };
          this.doEmbed = async (options) => {
            if (options.abortSignal?.aborted) {
              throw new Error("Operation was aborted");
            }
            const embedder = await this.textEmbedder;
            const embeddings = options.values.map((text2) => {
              const embedderResult = embedder.embed(text2);
              const [embedding] = embedderResult.embeddings;
              return embedding?.floatEmbedding ?? [];
            });
            return {
              embeddings,
              rawResponse: {
                model: "universal_sentence_encoder",
                provider: "google-mediapipe",
                processed_texts: options.values.length
              }
            };
          };
          this.settings = { ...this.settings, ...settings };
          this.modelAssetBuffer = fetch(this.settings.modelAssetPath).then(
            (response) => response.body.getReader()
          );
          this.textEmbedder = this.getTextEmbedder();
        }
      };
      var import_provider32 = require_dist();
      function createBuiltInAI(options = {}) {
        const createChatModel = (modelId, settings) => {
          return new BuiltInAIChatLanguageModel(modelId, settings);
        };
        const createEmbeddingModel = (modelId, settings) => {
          return new BuiltInAIEmbeddingModel(settings);
        };
        const provider = function(modelId = "text", settings) {
          if (new.target) {
            throw new Error(
              "The BuiltInAI model function cannot be called with the new keyword."
            );
          }
          return createChatModel(modelId, settings);
        };
        provider.languageModel = createChatModel;
        provider.chat = createChatModel;
        provider.textEmbedding = createEmbeddingModel;
        provider.textEmbeddingModel = createEmbeddingModel;
        provider.imageModel = (modelId) => {
          throw new import_provider32.NoSuchModelError({ modelId, modelType: "imageModel" });
        };
        provider.speechModel = (modelId) => {
          throw new import_provider32.NoSuchModelError({ modelId, modelType: "speechModel" });
        };
        provider.transcriptionModel = (modelId) => {
          throw new import_provider32.NoSuchModelError({ modelId, modelType: "transcriptionModel" });
        };
        return provider;
      }
      var builtInAI2 = createBuiltInAI();
    }
  });

  // node_modules/@ai-sdk/provider/dist/index.mjs
  var marker = "vercel.ai.error";
  var symbol = Symbol.for(marker);
  var _a;
  var _AISDKError = class _AISDKError2 extends Error {
    /**
     * Creates an AI SDK Error.
     *
     * @param {Object} params - The parameters for creating the error.
     * @param {string} params.name - The name of the error.
     * @param {string} params.message - The error message.
     * @param {unknown} [params.cause] - The underlying cause of the error.
     */
    constructor({
      name: name143,
      message,
      cause
    }) {
      super(message);
      this[_a] = true;
      this.name = name143;
      this.cause = cause;
    }
    /**
     * Checks if the given error is an AI SDK Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
     */
    static isInstance(error46) {
      return _AISDKError2.hasMarker(error46, marker);
    }
    static hasMarker(error46, marker153) {
      const markerSymbol = Symbol.for(marker153);
      return error46 != null && typeof error46 === "object" && markerSymbol in error46 && typeof error46[markerSymbol] === "boolean" && error46[markerSymbol] === true;
    }
  };
  _a = symbol;
  var AISDKError = _AISDKError;
  var name = "AI_APICallError";
  var marker2 = `vercel.ai.error.${name}`;
  var symbol2 = Symbol.for(marker2);
  var _a2;
  var APICallError = class extends AISDKError {
    constructor({
      message,
      url: url2,
      requestBodyValues,
      statusCode,
      responseHeaders,
      responseBody,
      cause,
      isRetryable = statusCode != null && (statusCode === 408 || // request timeout
      statusCode === 409 || // conflict
      statusCode === 429 || // too many requests
      statusCode >= 500),
      // server error
      data
    }) {
      super({ name, message, cause });
      this[_a2] = true;
      this.url = url2;
      this.requestBodyValues = requestBodyValues;
      this.statusCode = statusCode;
      this.responseHeaders = responseHeaders;
      this.responseBody = responseBody;
      this.isRetryable = isRetryable;
      this.data = data;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker2);
    }
  };
  _a2 = symbol2;
  var name2 = "AI_EmptyResponseBodyError";
  var marker3 = `vercel.ai.error.${name2}`;
  var symbol3 = Symbol.for(marker3);
  var _a3;
  var EmptyResponseBodyError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}) {
      super({ name: name2, message });
      this[_a3] = true;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker3);
    }
  };
  _a3 = symbol3;
  function getErrorMessage(error46) {
    if (error46 == null) {
      return "unknown error";
    }
    if (typeof error46 === "string") {
      return error46;
    }
    if (error46 instanceof Error) {
      return error46.message;
    }
    return JSON.stringify(error46);
  }
  var name3 = "AI_InvalidArgumentError";
  var marker4 = `vercel.ai.error.${name3}`;
  var symbol4 = Symbol.for(marker4);
  var _a4;
  var InvalidArgumentError = class extends AISDKError {
    constructor({
      message,
      cause,
      argument
    }) {
      super({ name: name3, message, cause });
      this[_a4] = true;
      this.argument = argument;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker4);
    }
  };
  _a4 = symbol4;
  var name4 = "AI_InvalidPromptError";
  var marker5 = `vercel.ai.error.${name4}`;
  var symbol5 = Symbol.for(marker5);
  var _a5;
  var InvalidPromptError = class extends AISDKError {
    constructor({
      prompt,
      message,
      cause
    }) {
      super({ name: name4, message: `Invalid prompt: ${message}`, cause });
      this[_a5] = true;
      this.prompt = prompt;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker5);
    }
  };
  _a5 = symbol5;
  var name5 = "AI_InvalidResponseDataError";
  var marker6 = `vercel.ai.error.${name5}`;
  var symbol6 = Symbol.for(marker6);
  var _a6;
  _a6 = symbol6;
  var name6 = "AI_JSONParseError";
  var marker7 = `vercel.ai.error.${name6}`;
  var symbol7 = Symbol.for(marker7);
  var _a7;
  var JSONParseError = class extends AISDKError {
    constructor({ text: text2, cause }) {
      super({
        name: name6,
        message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a7] = true;
      this.text = text2;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker7);
    }
  };
  _a7 = symbol7;
  var name7 = "AI_LoadAPIKeyError";
  var marker8 = `vercel.ai.error.${name7}`;
  var symbol8 = Symbol.for(marker8);
  var _a8;
  _a8 = symbol8;
  var name8 = "AI_LoadSettingError";
  var marker9 = `vercel.ai.error.${name8}`;
  var symbol9 = Symbol.for(marker9);
  var _a9;
  _a9 = symbol9;
  var name9 = "AI_NoContentGeneratedError";
  var marker10 = `vercel.ai.error.${name9}`;
  var symbol10 = Symbol.for(marker10);
  var _a10;
  _a10 = symbol10;
  var name10 = "AI_NoSuchModelError";
  var marker11 = `vercel.ai.error.${name10}`;
  var symbol11 = Symbol.for(marker11);
  var _a11;
  _a11 = symbol11;
  var name11 = "AI_TooManyEmbeddingValuesForCallError";
  var marker12 = `vercel.ai.error.${name11}`;
  var symbol12 = Symbol.for(marker12);
  var _a12;
  _a12 = symbol12;
  var name12 = "AI_TypeValidationError";
  var marker13 = `vercel.ai.error.${name12}`;
  var symbol13 = Symbol.for(marker13);
  var _a13;
  var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
    constructor({ value, cause }) {
      super({
        name: name12,
        message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a13] = true;
      this.value = value;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker13);
    }
    /**
     * Wraps an error into a TypeValidationError.
     * If the cause is already a TypeValidationError with the same value, it returns the cause.
     * Otherwise, it creates a new TypeValidationError.
     *
     * @param {Object} params - The parameters for wrapping the error.
     * @param {unknown} params.value - The value that failed validation.
     * @param {unknown} params.cause - The original error or cause of the validation failure.
     * @returns {TypeValidationError} A TypeValidationError instance.
     */
    static wrap({
      value,
      cause
    }) {
      return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
    }
  };
  _a13 = symbol13;
  var TypeValidationError = _TypeValidationError;
  var name13 = "AI_UnsupportedFunctionalityError";
  var marker14 = `vercel.ai.error.${name13}`;
  var symbol14 = Symbol.for(marker14);
  var _a14;
  _a14 = symbol14;

  // node_modules/eventsource-parser/dist/index.js
  var ParseError = class extends Error {
    constructor(message, options) {
      super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
  };
  function noop(_arg) {
  }
  function createParser(callbacks) {
    if (typeof callbacks == "function")
      throw new TypeError(
        "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
      );
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
      const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
      for (const line of complete)
        parseLine(line);
      incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
      if (line === "") {
        dispatchEvent();
        return;
      }
      if (line.startsWith(":")) {
        onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
        return;
      }
      const fieldSeparatorIndex = line.indexOf(":");
      if (fieldSeparatorIndex !== -1) {
        const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
        processField(field, value, line);
        return;
      }
      processField(line, "", line);
    }
    function processField(field, value, line) {
      switch (field) {
        case "event":
          eventType = value;
          break;
        case "data":
          data = `${data}${value}
`;
          break;
        case "id":
          id = value.includes("\0") ? void 0 : value;
          break;
        case "retry":
          /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
            new ParseError(`Invalid \`retry\` value: "${value}"`, {
              type: "invalid-retry",
              value,
              line
            })
          );
          break;
        default:
          onError(
            new ParseError(
              `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
              { type: "unknown-field", field, value, line }
            )
          );
          break;
      }
    }
    function dispatchEvent() {
      data.length > 0 && onEvent({
        id,
        event: eventType || void 0,
        // If the data buffer's last character is a U+000A LINE FEED (LF) character,
        // then remove the last character from the data buffer.
        data: data.endsWith(`
`) ? data.slice(0, -1) : data
      }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
      incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return { feed, reset };
  }
  function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for (; searchIndex < chunk.length; ) {
      const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
      let lineEnd = -1;
      if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
        incompleteLine = chunk.slice(searchIndex);
        break;
      } else {
        const line = chunk.slice(searchIndex, lineEnd);
        lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
      }
    }
    return [lines, incompleteLine];
  }

  // node_modules/eventsource-parser/dist/stream.js
  var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}) {
      let parser;
      super({
        start(controller) {
          parser = createParser({
            onEvent: (event) => {
              controller.enqueue(event);
            },
            onError(error46) {
              onError === "terminate" ? controller.error(error46) : typeof onError == "function" && onError(error46);
            },
            onRetry,
            onComment
          });
        },
        transform(chunk) {
          parser.feed(chunk);
        }
      });
    }
  };

  // node_modules/zod/v4/classic/external.js
  var external_exports = {};
  __export(external_exports, {
    $brand: () => $brand,
    $input: () => $input,
    $output: () => $output,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFile: () => ZodFile,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRealError: () => ZodRealError,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    clone: () => clone,
    codec: () => codec,
    coerce: () => coerce_exports,
    config: () => config,
    core: () => core_exports2,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    decode: () => decode2,
    decodeAsync: () => decodeAsync2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    encode: () => encode2,
    encodeAsync: () => encodeAsync2,
    endsWith: () => _endsWith,
    enum: () => _enum2,
    file: () => file,
    flattenError: () => flattenError,
    float32: () => float32,
    float64: () => float64,
    formatError: () => formatError,
    function: () => _function,
    getErrorMap: () => getErrorMap,
    globalRegistry: () => globalRegistry,
    gt: () => _gt,
    gte: () => _gte,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    includes: () => _includes,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    iso: () => iso_exports,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    length: () => _length,
    literal: () => literal,
    locales: () => locales_exports,
    looseObject: () => looseObject,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    map: () => map,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    negative: () => _negative,
    never: () => never,
    nonnegative: () => _nonnegative,
    nonoptional: () => nonoptional,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    overwrite: () => _overwrite,
    parse: () => parse2,
    parseAsync: () => parseAsync2,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    positive: () => _positive,
    prefault: () => prefault,
    preprocess: () => preprocess,
    prettifyError: () => prettifyError,
    promise: () => promise,
    property: () => _property,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    regex: () => _regex,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode2,
    safeDecodeAsync: () => safeDecodeAsync2,
    safeEncode: () => safeEncode2,
    safeEncodeAsync: () => safeEncodeAsync2,
    safeParse: () => safeParse2,
    safeParseAsync: () => safeParseAsync2,
    set: () => set,
    setErrorMap: () => setErrorMap,
    size: () => _size,
    startsWith: () => _startsWith,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol15,
    templateLiteral: () => templateLiteral,
    toJSONSchema: () => toJSONSchema,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    transform: () => transform,
    treeifyError: () => treeifyError,
    trim: () => _trim,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    uppercase: () => _uppercase,
    url: () => url,
    util: () => util_exports,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2
  });

  // node_modules/zod/v4/core/index.js
  var core_exports2 = {};
  __export(core_exports2, {
    $ZodAny: () => $ZodAny,
    $ZodArray: () => $ZodArray,
    $ZodAsyncError: () => $ZodAsyncError,
    $ZodBase64: () => $ZodBase64,
    $ZodBase64URL: () => $ZodBase64URL,
    $ZodBigInt: () => $ZodBigInt,
    $ZodBigIntFormat: () => $ZodBigIntFormat,
    $ZodBoolean: () => $ZodBoolean,
    $ZodCIDRv4: () => $ZodCIDRv4,
    $ZodCIDRv6: () => $ZodCIDRv6,
    $ZodCUID: () => $ZodCUID,
    $ZodCUID2: () => $ZodCUID2,
    $ZodCatch: () => $ZodCatch,
    $ZodCheck: () => $ZodCheck,
    $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
    $ZodCheckEndsWith: () => $ZodCheckEndsWith,
    $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
    $ZodCheckIncludes: () => $ZodCheckIncludes,
    $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
    $ZodCheckLessThan: () => $ZodCheckLessThan,
    $ZodCheckLowerCase: () => $ZodCheckLowerCase,
    $ZodCheckMaxLength: () => $ZodCheckMaxLength,
    $ZodCheckMaxSize: () => $ZodCheckMaxSize,
    $ZodCheckMimeType: () => $ZodCheckMimeType,
    $ZodCheckMinLength: () => $ZodCheckMinLength,
    $ZodCheckMinSize: () => $ZodCheckMinSize,
    $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
    $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
    $ZodCheckOverwrite: () => $ZodCheckOverwrite,
    $ZodCheckProperty: () => $ZodCheckProperty,
    $ZodCheckRegex: () => $ZodCheckRegex,
    $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
    $ZodCheckStartsWith: () => $ZodCheckStartsWith,
    $ZodCheckStringFormat: () => $ZodCheckStringFormat,
    $ZodCheckUpperCase: () => $ZodCheckUpperCase,
    $ZodCodec: () => $ZodCodec,
    $ZodCustom: () => $ZodCustom,
    $ZodCustomStringFormat: () => $ZodCustomStringFormat,
    $ZodDate: () => $ZodDate,
    $ZodDefault: () => $ZodDefault,
    $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
    $ZodE164: () => $ZodE164,
    $ZodEmail: () => $ZodEmail,
    $ZodEmoji: () => $ZodEmoji,
    $ZodEncodeError: () => $ZodEncodeError,
    $ZodEnum: () => $ZodEnum,
    $ZodError: () => $ZodError,
    $ZodFile: () => $ZodFile,
    $ZodFunction: () => $ZodFunction,
    $ZodGUID: () => $ZodGUID,
    $ZodIPv4: () => $ZodIPv4,
    $ZodIPv6: () => $ZodIPv6,
    $ZodISODate: () => $ZodISODate,
    $ZodISODateTime: () => $ZodISODateTime,
    $ZodISODuration: () => $ZodISODuration,
    $ZodISOTime: () => $ZodISOTime,
    $ZodIntersection: () => $ZodIntersection,
    $ZodJWT: () => $ZodJWT,
    $ZodKSUID: () => $ZodKSUID,
    $ZodLazy: () => $ZodLazy,
    $ZodLiteral: () => $ZodLiteral,
    $ZodMap: () => $ZodMap,
    $ZodNaN: () => $ZodNaN,
    $ZodNanoID: () => $ZodNanoID,
    $ZodNever: () => $ZodNever,
    $ZodNonOptional: () => $ZodNonOptional,
    $ZodNull: () => $ZodNull,
    $ZodNullable: () => $ZodNullable,
    $ZodNumber: () => $ZodNumber,
    $ZodNumberFormat: () => $ZodNumberFormat,
    $ZodObject: () => $ZodObject,
    $ZodObjectJIT: () => $ZodObjectJIT,
    $ZodOptional: () => $ZodOptional,
    $ZodPipe: () => $ZodPipe,
    $ZodPrefault: () => $ZodPrefault,
    $ZodPromise: () => $ZodPromise,
    $ZodReadonly: () => $ZodReadonly,
    $ZodRealError: () => $ZodRealError,
    $ZodRecord: () => $ZodRecord,
    $ZodRegistry: () => $ZodRegistry,
    $ZodSet: () => $ZodSet,
    $ZodString: () => $ZodString,
    $ZodStringFormat: () => $ZodStringFormat,
    $ZodSuccess: () => $ZodSuccess,
    $ZodSymbol: () => $ZodSymbol,
    $ZodTemplateLiteral: () => $ZodTemplateLiteral,
    $ZodTransform: () => $ZodTransform,
    $ZodTuple: () => $ZodTuple,
    $ZodType: () => $ZodType,
    $ZodULID: () => $ZodULID,
    $ZodURL: () => $ZodURL,
    $ZodUUID: () => $ZodUUID,
    $ZodUndefined: () => $ZodUndefined,
    $ZodUnion: () => $ZodUnion,
    $ZodUnknown: () => $ZodUnknown,
    $ZodVoid: () => $ZodVoid,
    $ZodXID: () => $ZodXID,
    $brand: () => $brand,
    $constructor: () => $constructor,
    $input: () => $input,
    $output: () => $output,
    Doc: () => Doc,
    JSONSchema: () => json_schema_exports,
    JSONSchemaGenerator: () => JSONSchemaGenerator,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    _any: () => _any,
    _array: () => _array,
    _base64: () => _base64,
    _base64url: () => _base64url,
    _bigint: () => _bigint,
    _boolean: () => _boolean,
    _catch: () => _catch,
    _check: () => _check,
    _cidrv4: () => _cidrv4,
    _cidrv6: () => _cidrv6,
    _coercedBigint: () => _coercedBigint,
    _coercedBoolean: () => _coercedBoolean,
    _coercedDate: () => _coercedDate,
    _coercedNumber: () => _coercedNumber,
    _coercedString: () => _coercedString,
    _cuid: () => _cuid,
    _cuid2: () => _cuid2,
    _custom: () => _custom,
    _date: () => _date,
    _decode: () => _decode,
    _decodeAsync: () => _decodeAsync,
    _default: () => _default,
    _discriminatedUnion: () => _discriminatedUnion,
    _e164: () => _e164,
    _email: () => _email,
    _emoji: () => _emoji2,
    _encode: () => _encode,
    _encodeAsync: () => _encodeAsync,
    _endsWith: () => _endsWith,
    _enum: () => _enum,
    _file: () => _file,
    _float32: () => _float32,
    _float64: () => _float64,
    _gt: () => _gt,
    _gte: () => _gte,
    _guid: () => _guid,
    _includes: () => _includes,
    _int: () => _int,
    _int32: () => _int32,
    _int64: () => _int64,
    _intersection: () => _intersection,
    _ipv4: () => _ipv4,
    _ipv6: () => _ipv6,
    _isoDate: () => _isoDate,
    _isoDateTime: () => _isoDateTime,
    _isoDuration: () => _isoDuration,
    _isoTime: () => _isoTime,
    _jwt: () => _jwt,
    _ksuid: () => _ksuid,
    _lazy: () => _lazy,
    _length: () => _length,
    _literal: () => _literal,
    _lowercase: () => _lowercase,
    _lt: () => _lt,
    _lte: () => _lte,
    _map: () => _map,
    _max: () => _lte,
    _maxLength: () => _maxLength,
    _maxSize: () => _maxSize,
    _mime: () => _mime,
    _min: () => _gte,
    _minLength: () => _minLength,
    _minSize: () => _minSize,
    _multipleOf: () => _multipleOf,
    _nan: () => _nan,
    _nanoid: () => _nanoid,
    _nativeEnum: () => _nativeEnum,
    _negative: () => _negative,
    _never: () => _never,
    _nonnegative: () => _nonnegative,
    _nonoptional: () => _nonoptional,
    _nonpositive: () => _nonpositive,
    _normalize: () => _normalize,
    _null: () => _null2,
    _nullable: () => _nullable,
    _number: () => _number,
    _optional: () => _optional,
    _overwrite: () => _overwrite,
    _parse: () => _parse,
    _parseAsync: () => _parseAsync,
    _pipe: () => _pipe,
    _positive: () => _positive,
    _promise: () => _promise,
    _property: () => _property,
    _readonly: () => _readonly,
    _record: () => _record,
    _refine: () => _refine,
    _regex: () => _regex,
    _safeDecode: () => _safeDecode,
    _safeDecodeAsync: () => _safeDecodeAsync,
    _safeEncode: () => _safeEncode,
    _safeEncodeAsync: () => _safeEncodeAsync,
    _safeParse: () => _safeParse,
    _safeParseAsync: () => _safeParseAsync,
    _set: () => _set,
    _size: () => _size,
    _startsWith: () => _startsWith,
    _string: () => _string,
    _stringFormat: () => _stringFormat,
    _stringbool: () => _stringbool,
    _success: () => _success,
    _superRefine: () => _superRefine,
    _symbol: () => _symbol,
    _templateLiteral: () => _templateLiteral,
    _toLowerCase: () => _toLowerCase,
    _toUpperCase: () => _toUpperCase,
    _transform: () => _transform,
    _trim: () => _trim,
    _tuple: () => _tuple,
    _uint32: () => _uint32,
    _uint64: () => _uint64,
    _ulid: () => _ulid,
    _undefined: () => _undefined2,
    _union: () => _union,
    _unknown: () => _unknown,
    _uppercase: () => _uppercase,
    _url: () => _url,
    _uuid: () => _uuid,
    _uuidv4: () => _uuidv4,
    _uuidv6: () => _uuidv6,
    _uuidv7: () => _uuidv7,
    _void: () => _void,
    _xid: () => _xid,
    clone: () => clone,
    config: () => config,
    decode: () => decode,
    decodeAsync: () => decodeAsync,
    encode: () => encode,
    encodeAsync: () => encodeAsync,
    flattenError: () => flattenError,
    formatError: () => formatError,
    globalConfig: () => globalConfig,
    globalRegistry: () => globalRegistry,
    isValidBase64: () => isValidBase64,
    isValidBase64URL: () => isValidBase64URL,
    isValidJWT: () => isValidJWT,
    locales: () => locales_exports,
    parse: () => parse,
    parseAsync: () => parseAsync,
    prettifyError: () => prettifyError,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode,
    safeDecodeAsync: () => safeDecodeAsync,
    safeEncode: () => safeEncode,
    safeEncodeAsync: () => safeEncodeAsync,
    safeParse: () => safeParse,
    safeParseAsync: () => safeParseAsync,
    toDotPath: () => toDotPath,
    toJSONSchema: () => toJSONSchema,
    treeifyError: () => treeifyError,
    util: () => util_exports,
    version: () => version
  });

  // node_modules/zod/v4/core/core.js
  var NEVER = Object.freeze({
    status: "aborted"
  });
  // @__NO_SIDE_EFFECTS__
  function $constructor(name16, initializer3, params) {
    function init(inst, def) {
      var _a17;
      Object.defineProperty(inst, "_zod", {
        value: inst._zod ?? {},
        enumerable: false
      });
      (_a17 = inst._zod).traits ?? (_a17.traits = /* @__PURE__ */ new Set());
      inst._zod.traits.add(name16);
      initializer3(inst, def);
      for (const k in _.prototype) {
        if (!(k in inst))
          Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
      }
      inst._zod.constr = _;
      inst._zod.def = def;
    }
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name16 });
    function _(def) {
      var _a17;
      const inst = params?.Parent ? new Definition() : this;
      init(inst, def);
      (_a17 = inst._zod).deferred ?? (_a17.deferred = []);
      for (const fn of inst._zod.deferred) {
        fn();
      }
      return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
      value: (inst) => {
        if (params?.Parent && inst instanceof params.Parent)
          return true;
        return inst?._zod?.traits?.has(name16);
      }
    });
    Object.defineProperty(_, "name", { value: name16 });
    return _;
  }
  var $brand = Symbol("zod_brand");
  var $ZodAsyncError = class extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  var $ZodEncodeError = class extends Error {
    constructor(name16) {
      super(`Encountered unidirectional transform during encode: ${name16}`);
      this.name = "ZodEncodeError";
    }
  };
  var globalConfig = {};
  function config(newConfig) {
    if (newConfig)
      Object.assign(globalConfig, newConfig);
    return globalConfig;
  }

  // node_modules/zod/v4/core/util.js
  var util_exports = {};
  __export(util_exports, {
    BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
    Class: () => Class,
    NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
    aborted: () => aborted,
    allowsEval: () => allowsEval,
    assert: () => assert,
    assertEqual: () => assertEqual,
    assertIs: () => assertIs,
    assertNever: () => assertNever,
    assertNotEqual: () => assertNotEqual,
    assignProp: () => assignProp,
    base64ToUint8Array: () => base64ToUint8Array,
    base64urlToUint8Array: () => base64urlToUint8Array,
    cached: () => cached,
    captureStackTrace: () => captureStackTrace,
    cleanEnum: () => cleanEnum,
    cleanRegex: () => cleanRegex,
    clone: () => clone,
    cloneDef: () => cloneDef,
    createTransparentProxy: () => createTransparentProxy,
    defineLazy: () => defineLazy,
    esc: () => esc,
    escapeRegex: () => escapeRegex,
    extend: () => extend,
    finalizeIssue: () => finalizeIssue,
    floatSafeRemainder: () => floatSafeRemainder,
    getElementAtPath: () => getElementAtPath,
    getEnumValues: () => getEnumValues,
    getLengthableOrigin: () => getLengthableOrigin,
    getParsedType: () => getParsedType,
    getSizableOrigin: () => getSizableOrigin,
    hexToUint8Array: () => hexToUint8Array,
    isObject: () => isObject,
    isPlainObject: () => isPlainObject,
    issue: () => issue,
    joinValues: () => joinValues,
    jsonStringifyReplacer: () => jsonStringifyReplacer,
    merge: () => merge,
    mergeDefs: () => mergeDefs,
    normalizeParams: () => normalizeParams,
    nullish: () => nullish,
    numKeys: () => numKeys,
    objectClone: () => objectClone,
    omit: () => omit,
    optionalKeys: () => optionalKeys,
    partial: () => partial,
    pick: () => pick,
    prefixIssues: () => prefixIssues,
    primitiveTypes: () => primitiveTypes,
    promiseAllObject: () => promiseAllObject,
    propertyKeyTypes: () => propertyKeyTypes,
    randomString: () => randomString,
    required: () => required,
    safeExtend: () => safeExtend,
    shallowClone: () => shallowClone,
    stringifyPrimitive: () => stringifyPrimitive,
    uint8ArrayToBase64: () => uint8ArrayToBase64,
    uint8ArrayToBase64url: () => uint8ArrayToBase64url,
    uint8ArrayToHex: () => uint8ArrayToHex,
    unwrapMessage: () => unwrapMessage
  });
  function assertEqual(val) {
    return val;
  }
  function assertNotEqual(val) {
    return val;
  }
  function assertIs(_arg) {
  }
  function assertNever(_x) {
    throw new Error();
  }
  function assert(_) {
  }
  function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
    return values;
  }
  function joinValues(array2, separator = "|") {
    return array2.map((val) => stringifyPrimitive(val)).join(separator);
  }
  function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  function cached(getter) {
    const set2 = false;
    return {
      get value() {
        if (!set2) {
          const value = getter();
          Object.defineProperty(this, "value", { value });
          return value;
        }
        throw new Error("cached value already set");
      }
    };
  }
  function nullish(input) {
    return input === null || input === void 0;
  }
  function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
      const match = stepString.match(/\d?e-(\d?)/);
      if (match?.[1]) {
        stepDecCount = Number.parseInt(match[1]);
      }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var EVALUATING = Symbol("evaluating");
  function defineLazy(object3, key, getter) {
    let value = void 0;
    Object.defineProperty(object3, key, {
      get() {
        if (value === EVALUATING) {
          return void 0;
        }
        if (value === void 0) {
          value = EVALUATING;
          value = getter();
        }
        return value;
      },
      set(v) {
        Object.defineProperty(object3, key, {
          value: v
          // configurable: true,
        });
      },
      configurable: true
    });
  }
  function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  }
  function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  }
  function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
      const descriptors = Object.getOwnPropertyDescriptors(def);
      Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
  }
  function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
  }
  function getElementAtPath(obj, path) {
    if (!path)
      return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
  }
  function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
      const resolvedObj = {};
      for (let i = 0; i < keys.length; i++) {
        resolvedObj[keys[i]] = results[i];
      }
      return resolvedObj;
    });
  }
  function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
      str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
  }
  function esc(str) {
    return JSON.stringify(str);
  }
  var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
  };
  function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
  }
  var allowsEval = cached(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  function isPlainObject(o) {
    if (isObject(o) === false)
      return false;
    const ctor = o.constructor;
    if (ctor === void 0)
      return true;
    const prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  function shallowClone(o) {
    if (isPlainObject(o))
      return { ...o };
    if (Array.isArray(o))
      return [...o];
    return o;
  }
  function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        keyCount++;
      }
    }
    return keyCount;
  }
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(data) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return "promise";
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return "map";
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return "set";
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return "date";
        }
        if (typeof File !== "undefined" && data instanceof File) {
          return "file";
        }
        return "object";
      default:
        throw new Error(`Unknown data type: ${t}`);
    }
  };
  var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
  var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
      cl._zod.parent = inst;
    return cl;
  }
  function normalizeParams(_params) {
    const params = _params;
    if (!params)
      return {};
    if (typeof params === "string")
      return { error: () => params };
    if (params?.message !== void 0) {
      if (params?.error !== void 0)
        throw new Error("Cannot specify both `message` and `error` params");
      params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
      return { ...params, error: () => params.error };
    return params;
  }
  function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
      get(_, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      }
    });
  }
  function stringifyPrimitive(value) {
    if (typeof value === "bigint")
      return value.toString() + "n";
    if (typeof value === "string")
      return `"${value}"`;
    return `${value}`;
  }
  function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
      return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
  }
  var NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  var BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
  function pick(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = {};
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          newShape[key] = currDef.shape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function omit(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = { ...schema._zod.def.shape };
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          delete newShape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function extend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = {
      ...schema._zod.def,
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      checks: schema._zod.def.checks
    };
    return clone(schema, def);
  }
  function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
      get shape() {
        const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      get catchall() {
        return b._zod.def.catchall;
      },
      checks: []
      // delete existing checks
    });
    return clone(a, def);
  }
  function partial(Class2, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in oldShape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        } else {
          for (const key in oldShape) {
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function required(Class2, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        } else {
          for (const key in oldShape) {
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function aborted(x, startIndex = 0) {
    if (x.aborted === true)
      return true;
    for (let i = startIndex; i < x.issues.length; i++) {
      if (x.issues[i]?.continue !== true) {
        return true;
      }
    }
    return false;
  }
  function prefixIssues(path, issues) {
    return issues.map((iss) => {
      var _a17;
      (_a17 = iss).path ?? (_a17.path = []);
      iss.path.unshift(path);
      return iss;
    });
  }
  function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
  }
  function finalizeIssue(iss, ctx, config2) {
    const full = { ...iss, path: iss.path ?? [] };
    if (!iss.message) {
      const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
      full.message = message;
    }
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
      delete full.input;
    }
    return full;
  }
  function getSizableOrigin(input) {
    if (input instanceof Set)
      return "set";
    if (input instanceof Map)
      return "map";
    if (input instanceof File)
      return "file";
    return "unknown";
  }
  function getLengthableOrigin(input) {
    if (Array.isArray(input))
      return "array";
    if (typeof input === "string")
      return "string";
    return "unknown";
  }
  function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
      return {
        message: iss,
        code: "custom",
        input,
        inst
      };
    }
    return { ...iss };
  }
  function cleanEnum(obj) {
    return Object.entries(obj).filter(([k, _]) => {
      return Number.isNaN(Number.parseInt(k, 10));
    }).map((el) => el[1]);
  }
  function base64ToUint8Array(base643) {
    const binaryString = atob(base643);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
      binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
  }
  function base64urlToUint8Array(base64url3) {
    const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - base643.length % 4) % 4);
    return base64ToUint8Array(base643 + padding);
  }
  function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function hexToUint8Array(hex3) {
    const cleanHex = hex3.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
      throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
      bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
  }
  function uint8ArrayToHex(bytes) {
    return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  var Class = class {
    constructor(..._args) {
    }
  };

  // node_modules/zod/v4/core/errors.js
  var initializer = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
      value: inst._zod,
      enumerable: false
    });
    Object.defineProperty(inst, "issues", {
      value: def,
      enumerable: false
    });
    inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
      value: () => inst.message,
      enumerable: false
    });
  };
  var $ZodError = $constructor("$ZodError", initializer);
  var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  function flattenError(error46, mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error46.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  function formatError(error46, mapper = (issue2) => issue2.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error47) => {
      for (const issue2 of error47.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues });
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues });
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(error46);
    return fieldErrors;
  }
  function treeifyError(error46, mapper = (issue2) => issue2.message) {
    const result = { errors: [] };
    const processError = (error47, path = []) => {
      var _a17, _b8;
      for (const issue2 of error47.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }, issue2.path));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues }, issue2.path);
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues }, issue2.path);
        } else {
          const fullpath = [...path, ...issue2.path];
          if (fullpath.length === 0) {
            result.errors.push(mapper(issue2));
            continue;
          }
          let curr = result;
          let i = 0;
          while (i < fullpath.length) {
            const el = fullpath[i];
            const terminal = i === fullpath.length - 1;
            if (typeof el === "string") {
              curr.properties ?? (curr.properties = {});
              (_a17 = curr.properties)[el] ?? (_a17[el] = { errors: [] });
              curr = curr.properties[el];
            } else {
              curr.items ?? (curr.items = []);
              (_b8 = curr.items)[el] ?? (_b8[el] = { errors: [] });
              curr = curr.items[el];
            }
            if (terminal) {
              curr.errors.push(mapper(issue2));
            }
            i++;
          }
        }
      }
    };
    processError(error46);
    return result;
  }
  function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
    for (const seg of path) {
      if (typeof seg === "number")
        segs.push(`[${seg}]`);
      else if (typeof seg === "symbol")
        segs.push(`[${JSON.stringify(String(seg))}]`);
      else if (/[^\w$]/.test(seg))
        segs.push(`[${JSON.stringify(seg)}]`);
      else {
        if (segs.length)
          segs.push(".");
        segs.push(seg);
      }
    }
    return segs.join("");
  }
  function prettifyError(error46) {
    const lines = [];
    const issues = [...error46.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    for (const issue2 of issues) {
      lines.push(`\u2716 ${issue2.message}`);
      if (issue2.path?.length)
        lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
    }
    return lines.join("\n");
  }

  // node_modules/zod/v4/core/parse.js
  var _parse = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    if (result.issues.length) {
      const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, _params?.callee);
      throw e;
    }
    return result.value;
  };
  var parse = /* @__PURE__ */ _parse($ZodRealError);
  var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    if (result.issues.length) {
      const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, params?.callee);
      throw e;
    }
    return result.value;
  };
  var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  var _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    return result.issues.length ? {
      success: false,
      error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    return result.issues.length ? {
      success: false,
      error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  var _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse(_Err)(schema, value, ctx);
  };
  var encode = /* @__PURE__ */ _encode($ZodRealError);
  var _decode = (_Err) => (schema, value, _ctx) => {
    return _parse(_Err)(schema, value, _ctx);
  };
  var decode = /* @__PURE__ */ _decode($ZodRealError);
  var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
  };
  var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
  };
  var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  var _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
  };
  var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  var _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
  };
  var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
  };
  var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
  };
  var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

  // node_modules/zod/v4/core/regexes.js
  var regexes_exports = {};
  __export(regexes_exports, {
    base64: () => base64,
    base64url: () => base64url,
    bigint: () => bigint,
    boolean: () => boolean,
    browserEmail: () => browserEmail,
    cidrv4: () => cidrv4,
    cidrv6: () => cidrv6,
    cuid: () => cuid,
    cuid2: () => cuid2,
    date: () => date,
    datetime: () => datetime,
    domain: () => domain,
    duration: () => duration,
    e164: () => e164,
    email: () => email,
    emoji: () => emoji,
    extendedDuration: () => extendedDuration,
    guid: () => guid,
    hex: () => hex,
    hostname: () => hostname,
    html5Email: () => html5Email,
    idnEmail: () => idnEmail,
    integer: () => integer,
    ipv4: () => ipv4,
    ipv6: () => ipv6,
    ksuid: () => ksuid,
    lowercase: () => lowercase,
    md5_base64: () => md5_base64,
    md5_base64url: () => md5_base64url,
    md5_hex: () => md5_hex,
    nanoid: () => nanoid,
    null: () => _null,
    number: () => number,
    rfc5322Email: () => rfc5322Email,
    sha1_base64: () => sha1_base64,
    sha1_base64url: () => sha1_base64url,
    sha1_hex: () => sha1_hex,
    sha256_base64: () => sha256_base64,
    sha256_base64url: () => sha256_base64url,
    sha256_hex: () => sha256_hex,
    sha384_base64: () => sha384_base64,
    sha384_base64url: () => sha384_base64url,
    sha384_hex: () => sha384_hex,
    sha512_base64: () => sha512_base64,
    sha512_base64url: () => sha512_base64url,
    sha512_hex: () => sha512_hex,
    string: () => string,
    time: () => time,
    ulid: () => ulid,
    undefined: () => _undefined,
    unicodeEmail: () => unicodeEmail,
    uppercase: () => uppercase,
    uuid: () => uuid,
    uuid4: () => uuid4,
    uuid6: () => uuid6,
    uuid7: () => uuid7,
    xid: () => xid
  });
  var cuid = /^[cC][^\s-]{8,}$/;
  var cuid2 = /^[0-9a-z]+$/;
  var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  var xid = /^[0-9a-vA-V]{20}$/;
  var ksuid = /^[A-Za-z0-9]{27}$/;
  var nanoid = /^[a-zA-Z0-9_-]{21}$/;
  var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  var uuid = (version2) => {
    if (!version2)
      return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
  };
  var uuid4 = /* @__PURE__ */ uuid(4);
  var uuid6 = /* @__PURE__ */ uuid(6);
  var uuid7 = /* @__PURE__ */ uuid(7);
  var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  var idnEmail = unicodeEmail;
  var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  function emoji() {
    return new RegExp(_emoji, "u");
  }
  var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  var base64url = /^[A-Za-z0-9_-]*$/;
  var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
  var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
  var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
  }
  function time(args) {
    return new RegExp(`^${timeSource(args)}$`);
  }
  function datetime(args) {
    const time3 = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
      opts.push("");
    if (args.offset)
      opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex2 = `${time3}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
  }
  var string = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
  };
  var bigint = /^-?\d+n?$/;
  var integer = /^-?\d+$/;
  var number = /^-?\d+(?:\.\d+)?/;
  var boolean = /^(?:true|false)$/i;
  var _null = /^null$/i;
  var _undefined = /^undefined$/i;
  var lowercase = /^[^A-Z]*$/;
  var uppercase = /^[^a-z]*$/;
  var hex = /^[0-9a-fA-F]*$/;
  function fixedBase64(bodyLength, padding) {
    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
  }
  function fixedBase64url(length) {
    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
  }
  var md5_hex = /^[0-9a-fA-F]{32}$/;
  var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  var sha1_hex = /^[0-9a-fA-F]{40}$/;
  var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  var sha256_hex = /^[0-9a-fA-F]{64}$/;
  var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  var sha384_hex = /^[0-9a-fA-F]{96}$/;
  var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  var sha512_hex = /^[0-9a-fA-F]{128}$/;
  var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

  // node_modules/zod/v4/core/checks.js
  var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a17;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a17 = inst._zod).onattach ?? (_a17.onattach = []);
  });
  var numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a17;
      (_a17 = inst2._zod.bag).multipleOf ?? (_a17.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a17;
    $ZodCheck.init(inst, def);
    (_a17 = inst._zod.def).when ?? (_a17.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a17, _b8;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a17 = inst._zod).check ?? (_a17.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b8 = inst._zod).check ?? (_b8.check = () => {
      });
  });
  var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function handleCheckPropertyResult(result, payload, property) {
    if (result.issues.length) {
      payload.issues.push(...prefixIssues(property, result.issues));
    }
  }
  var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });

  // node_modules/zod/v4/core/doc.js
  var Doc = class {
    constructor(args = []) {
      this.content = [];
      this.indent = 0;
      if (this)
        this.args = args;
    }
    indented(fn) {
      this.indent += 1;
      fn(this);
      this.indent -= 1;
    }
    write(arg) {
      if (typeof arg === "function") {
        arg(this, { execution: "sync" });
        arg(this, { execution: "async" });
        return;
      }
      const content = arg;
      const lines = content.split("\n").filter((x) => x);
      const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
      const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
      for (const line of dedented) {
        this.content.push(line);
      }
    }
    compile() {
      const F = Function;
      const args = this?.args;
      const content = this?.content ?? [``];
      const lines = [...content.map((x) => `  ${x}`)];
      return new F(...args, lines.join("\n"));
    }
  };

  // node_modules/zod/v4/core/versions.js
  var version = {
    major: 4,
    minor: 1,
    patch: 12
  };

  // node_modules/zod/v4/core/schemas.js
  var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a17;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a17 = inst._zod).deferred ?? (_a17.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted2 = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted2) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError();
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted2)
                isAborted2 = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    inst["~standard"] = {
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    };
  });
  var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {
        }
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === void 0)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid(v));
    } else
      def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url2 = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url2.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv4`;
    });
  });
  var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error();
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error();
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error();
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error();
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  function isValidBase64(data) {
    if (data === "")
      return true;
    if (data.length % 4 !== 0)
      return false;
    try {
      atob(data);
      return true;
    } catch {
      return false;
    }
  }
  var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function isValidBase64URL(data) {
    if (!base64url.test(data))
      return false;
    const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
    const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
    return isValidBase64(padded);
  }
  var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  function isValidJWT(token, algorithm = null) {
    try {
      const tokensParts = token.split(".");
      if (tokensParts.length !== 3)
        return false;
      const [header] = tokensParts;
      if (!header)
        return false;
      const parsedHeader = JSON.parse(atob(header));
      if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
        return false;
      if (!parsedHeader.alg)
        return false;
      if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
        return false;
      return true;
    } catch {
      return false;
    }
  }
  var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {
        }
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = /* @__PURE__ */ new Set([void 0]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = /* @__PURE__ */ new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {
        }
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  function handleArrayResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0; i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  function handlePropertyResult(result, final, key, input) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      }
    } else {
      final.value[key] = result.value;
    }
  }
  function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      ...def,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  }
  function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  }
  var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject2 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
        } else {
          handlePropertyResult(r, payload, key, input);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = /* @__PURE__ */ Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc(key);
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject2 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
      if (result.issues.length === 0) {
        final.value = result.value;
        return final;
      }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
      final.value = nonaborted[0].value;
      return nonaborted[0];
    }
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
    return final;
  }
  var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return void 0;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = /* @__PURE__ */ new Set();
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map2 = /* @__PURE__ */ new Map();
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map2.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map2.set(v, o);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  function mergeValues(a, b) {
    if (a === b) {
      return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
      return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      const bKeys = Object.keys(b);
      const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
          };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return { valid: false, mergeErrorPath: [] };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
          };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
  }
  function handleIntersectionResults(result, left, right) {
    if (left.issues.length) {
      result.issues.push(...left.issues);
    }
    if (right.issues.length) {
      result.issues.push(...right.issues);
    }
    if (aborted(result))
      return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
      throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
  }
  var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleTupleResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      if (def.keyType._zod.values) {
        const values = def.keyType._zod.values;
        payload.value = {};
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!values.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (keyResult.issues.length) {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
            payload.value[keyResult.value] = keyResult.value;
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Map();
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
    if (keyResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, keyResult.issues));
      } else {
        final.issues.push({
          code: "invalid_key",
          origin: "map",
          input,
          inst,
          issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    if (valueResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, valueResult.issues));
      } else {
        final.issues.push({
          origin: "map",
          code: "invalid_element",
          input,
          inst,
          key,
          issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    final.value.set(keyResult.value, valueResult.value);
  }
  var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Set();
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleSetResult(result, final) {
    if (result.issues.length) {
      final.issues.push(...result.issues);
    }
    final.value.add(result.value);
  }
  var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    inst._zod.values = new Set(def.values);
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (inst._zod.values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError();
      }
      payload.value = _out;
      return payload;
    };
  });
  function handleOptionalResult(result, input) {
    if (result.issues.length && input === void 0) {
      return { issues: [], value: void 0 };
    }
    return result;
  }
  var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === void 0) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  function handleDefaultResult(payload, def) {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return payload;
  }
  var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === void 0) {
      payload.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: payload.value,
        inst
      });
    }
    return payload;
  }
  var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
  }
  var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  function handleCodecAResult(result, def, ctx) {
    if (result.issues.length) {
      result.aborted = true;
      return result;
    }
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const transformed = def.transform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
      }
      return handleCodecTxResult(result, transformed, def.out, ctx);
    } else {
      const transformed = def.reverseTransform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
      }
      return handleCodecTxResult(result, transformed, def.in, ctx);
    }
  }
  function handleCodecTxResult(left, value, nextSchema, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
  }
  var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
  }
  var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "template_literal",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
  function handleRefineResult(result, payload, input, inst) {
    if (!result) {
      const _iss = {
        code: "custom",
        input,
        inst,
        // incorporates params.error into issue reporting
        path: [...inst._zod.def.path ?? []],
        // incorporates params.error into issue reporting
        continue: !inst._zod.def.abort
        // params: inst._zod.def.params,
      };
      if (inst._zod.def.params)
        _iss.params = inst._zod.def.params;
      payload.issues.push(issue(_iss));
    }
  }

  // node_modules/zod/v4/locales/index.js
  var locales_exports = {};
  __export(locales_exports, {
    ar: () => ar_default,
    az: () => az_default,
    be: () => be_default,
    bg: () => bg_default,
    ca: () => ca_default,
    cs: () => cs_default,
    da: () => da_default,
    de: () => de_default,
    en: () => en_default,
    eo: () => eo_default,
    es: () => es_default,
    fa: () => fa_default,
    fi: () => fi_default,
    fr: () => fr_default,
    frCA: () => fr_CA_default,
    he: () => he_default,
    hu: () => hu_default,
    id: () => id_default,
    is: () => is_default,
    it: () => it_default,
    ja: () => ja_default,
    ka: () => ka_default,
    kh: () => kh_default,
    km: () => km_default,
    ko: () => ko_default,
    lt: () => lt_default,
    mk: () => mk_default,
    ms: () => ms_default,
    nl: () => nl_default,
    no: () => no_default,
    ota: () => ota_default,
    pl: () => pl_default,
    ps: () => ps_default,
    pt: () => pt_default,
    ru: () => ru_default,
    sl: () => sl_default,
    sv: () => sv_default,
    ta: () => ta_default,
    th: () => th_default,
    tr: () => tr_default,
    ua: () => ua_default,
    uk: () => uk_default,
    ur: () => ur_default,
    vi: () => vi_default,
    yo: () => yo_default,
    zhCN: () => zh_CN_default,
    zhTW: () => zh_TW_default
  });

  // node_modules/zod/v4/locales/ar.js
  var error = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0645\u062F\u062E\u0644",
      email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
      url: "\u0631\u0627\u0628\u0637",
      emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
      ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
      cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
      cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
      base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
      base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
      json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
      e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
      jwt: "JWT",
      template_literal: "\u0645\u062F\u062E\u0644"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
          return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
        }
        case "not_multiple_of":
          return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        case "invalid_union":
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        case "invalid_element":
          return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        default:
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      }
    };
  };
  function ar_default() {
    return {
      localeError: error()
    };
  }

  // node_modules/zod/v4/locales/az.js
  var error2 = () => {
    const Sizable = {
      string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "element", verb: "olmal\u0131d\u0131r" },
      set: { unit: "element", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
          return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
          if (_issue.format === "ends_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
          if (_issue.format === "includes")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
          if (_issue.format === "regex")
            return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
          return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
        case "invalid_union":
          return "Yanl\u0131\u015F d\u0259y\u0259r";
        case "invalid_element":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
        default:
          return `Yanl\u0131\u015F d\u0259y\u0259r`;
      }
    };
  };
  function az_default() {
    return {
      localeError: error2()
    };
  }

  // node_modules/zod/v4/locales/be.js
  function getBelarusianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error3 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0456\u043C\u0432\u0430\u043B",
          few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
          many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u044B",
          many: "\u0431\u0430\u0439\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0456\u045E";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0443\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0430\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0447\u0430\u0441",
      duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
      cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
      base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
      json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
      e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0443\u0432\u043E\u0434"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
        case "invalid_element":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
        default:
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
      }
    };
  };
  function be_default() {
    return {
      localeError: error3()
    };
  }

  // node_modules/zod/v4/locales/bg.js
  var parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  var error4 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "\u0432\u0445\u043E\u0434",
      email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      json_string: "JSON \u043D\u0438\u0437",
      e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u043E\u0434"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
          let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
          if (_issue.format === "emoji")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "datetime")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "date")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          if (_issue.format === "time")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "duration")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
      }
    };
  };
  function bg_default() {
    return {
      localeError: error4()
    };
  }

  // node_modules/zod/v4/locales/ca.js
  var error5 = () => {
    const Sizable = {
      string: { unit: "car\xE0cters", verb: "contenir" },
      file: { unit: "bytes", verb: "contenir" },
      array: { unit: "elements", verb: "contenir" },
      set: { unit: "elements", verb: "contenir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "entrada",
      email: "adre\xE7a electr\xF2nica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adre\xE7a IPv4",
      ipv6: "adre\xE7a IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
          return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clau inv\xE0lida a ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE0lida";
        case "invalid_element":
          return `Element inv\xE0lid a ${issue2.origin}`;
        default:
          return `Entrada inv\xE0lida`;
      }
    };
  };
  function ca_default() {
    return {
      localeError: error5()
    };
  }

  // node_modules/zod/v4/locales/cs.js
  var error6 = () => {
    const Sizable = {
      string: { unit: "znak\u016F", verb: "m\xEDt" },
      file: { unit: "bajt\u016F", verb: "m\xEDt" },
      array: { unit: "prvk\u016F", verb: "m\xEDt" },
      set: { unit: "prvk\u016F", verb: "m\xEDt" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
        }
        case "string": {
          return "\u0159et\u011Bzec";
        }
        case "boolean": {
          return "boolean";
        }
        case "bigint": {
          return "bigint";
        }
        case "function": {
          return "funkce";
        }
        case "symbol": {
          return "symbol";
        }
        case "undefined": {
          return "undefined";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "pole";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "regul\xE1rn\xED v\xFDraz",
      email: "e-mailov\xE1 adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a \u010Das ve form\xE1tu ISO",
      date: "datum ve form\xE1tu ISO",
      time: "\u010Das ve form\xE1tu ISO",
      duration: "doba trv\xE1n\xED ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
      base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
      json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
      e164: "\u010D\xEDslo E.164",
      jwt: "JWT",
      template_literal: "vstup"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
          return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
          return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neplatn\xFD vstup";
        case "invalid_element":
          return `Neplatn\xE1 hodnota v ${issue2.origin}`;
        default:
          return `Neplatn\xFD vstup`;
      }
    };
  };
  function cs_default() {
    return {
      localeError: error6()
    };
  }

  // node_modules/zod/v4/locales/da.js
  var error7 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "havde" },
      file: { unit: "bytes", verb: "havde" },
      array: { unit: "elementer", verb: "indeholdt" },
      set: { unit: "elementer", verb: "indeholdt" }
    };
    const TypeNames = {
      string: "streng",
      number: "tal",
      boolean: "boolean",
      array: "liste",
      object: "objekt",
      set: "s\xE6t",
      file: "fil"
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    function getTypeName(type) {
      return TypeNames[type] ?? type;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "tal";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "liste";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
          return "objekt";
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "e-mailadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkesl\xE6t",
      date: "ISO-dato",
      time: "ISO-klokkesl\xE6t",
      duration: "ISO-varighed",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodet streng",
      base64url: "base64url-kodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = getTypeName(issue2.origin);
          if (sizing)
            return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = getTypeName(issue2.origin);
          if (sizing) {
            return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8gle i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldigt input: matcher ingen af de tilladte typer";
        case "invalid_element":
          return `Ugyldig v\xE6rdi i ${issue2.origin}`;
        default:
          return `Ugyldigt input`;
      }
    };
  };
  function da_default() {
    return {
      localeError: error7()
    };
  }

  // node_modules/zod/v4/locales/de.js
  var error8 = () => {
    const Sizable = {
      string: { unit: "Zeichen", verb: "zu haben" },
      file: { unit: "Bytes", verb: "zu haben" },
      array: { unit: "Elemente", verb: "zu haben" },
      set: { unit: "Elemente", verb: "zu haben" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "Zahl";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "Array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
          }
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
          if (_issue.format === "ends_with")
            return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
          if (_issue.format === "includes")
            return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
          if (_issue.format === "regex")
            return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
          return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
        case "invalid_union":
          return "Ung\xFCltige Eingabe";
        case "invalid_element":
          return `Ung\xFCltiger Wert in ${issue2.origin}`;
        default:
          return `Ung\xFCltige Eingabe`;
      }
    };
  };
  function de_default() {
    return {
      localeError: error8()
    };
  }

  // node_modules/zod/v4/locales/en.js
  var parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  var error9 = () => {
    const Sizable = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Invalid string: must start with "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Invalid string: must end with "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Invalid string: must include "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Invalid string: must match pattern ${_issue.pattern}`;
          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${issue2.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${issue2.origin}`;
        default:
          return `Invalid input`;
      }
    };
  };
  function en_default() {
    return {
      localeError: error9()
    };
  }

  // node_modules/zod/v4/locales/eo.js
  var parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombro";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabelo";
        }
        if (data === null) {
          return "senvalora";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  var error10 = () => {
    const Sizable = {
      string: { unit: "karaktrojn", verb: "havi" },
      file: { unit: "bajtojn", verb: "havi" },
      array: { unit: "elementojn", verb: "havi" },
      set: { unit: "elementojn", verb: "havi" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "enigo",
      email: "retadreso",
      url: "URL",
      emoji: "emo\u011Dio",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datotempo",
      date: "ISO-dato",
      time: "ISO-tempo",
      duration: "ISO-da\u016Dro",
      ipv4: "IPv4-adreso",
      ipv6: "IPv6-adreso",
      cidrv4: "IPv4-rango",
      cidrv6: "IPv6-rango",
      base64: "64-ume kodita karaktraro",
      base64url: "URL-64-ume kodita karaktraro",
      json_string: "JSON-karaktraro",
      e164: "E.164-nombro",
      jwt: "JWT",
      template_literal: "enigo"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
          return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
          return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nevalida \u015Dlosilo en ${issue2.origin}`;
        case "invalid_union":
          return "Nevalida enigo";
        case "invalid_element":
          return `Nevalida valoro en ${issue2.origin}`;
        default:
          return `Nevalida enigo`;
      }
    };
  };
  function eo_default() {
    return {
      localeError: error10()
    };
  }

  // node_modules/zod/v4/locales/es.js
  var error11 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "tener" },
      file: { unit: "bytes", verb: "tener" },
      array: { unit: "elementos", verb: "tener" },
      set: { unit: "elementos", verb: "tener" }
    };
    const TypeNames = {
      string: "texto",
      number: "n\xFAmero",
      boolean: "booleano",
      array: "arreglo",
      object: "objeto",
      set: "conjunto",
      file: "archivo",
      date: "fecha",
      bigint: "n\xFAmero grande",
      symbol: "s\xEDmbolo",
      undefined: "indefinido",
      null: "nulo",
      function: "funci\xF3n",
      map: "mapa",
      record: "registro",
      tuple: "tupla",
      enum: "enumeraci\xF3n",
      union: "uni\xF3n",
      literal: "literal",
      promise: "promesa",
      void: "vac\xEDo",
      never: "nunca",
      unknown: "desconocido",
      any: "cualquiera"
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    function getTypeName(type) {
      return TypeNames[type] ?? type;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype) {
            return data.constructor.name;
          }
          return "object";
        }
      }
      return t;
    };
    const Nouns = {
      regex: "entrada",
      email: "direcci\xF3n de correo electr\xF3nico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duraci\xF3n ISO",
      ipv4: "direcci\xF3n IPv4",
      ipv6: "direcci\xF3n IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = getTypeName(issue2.origin);
          if (sizing)
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = getTypeName(issue2.origin);
          if (sizing) {
            return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
          return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
        default:
          return `Entrada inv\xE1lida`;
      }
    };
  };
  function es_default() {
    return {
      localeError: error11()
    };
  }

  // node_modules/zod/v4/locales/fa.js
  var error12 = () => {
    const Sizable = {
      string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u0622\u0631\u0627\u06CC\u0647";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0648\u0631\u0648\u062F\u06CC",
      email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
      url: "URL",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
      time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      ipv4: "IPv4 \u0622\u062F\u0631\u0633",
      ipv6: "IPv6 \u0622\u062F\u0631\u0633",
      cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
      cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
      base64: "base64-encoded \u0631\u0634\u062A\u0647",
      base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
      json_string: "JSON \u0631\u0634\u062A\u0647",
      e164: "E.164 \u0639\u062F\u062F",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u06CC"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          }
          return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
          }
          if (_issue.format === "ends_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
          }
          if (_issue.format === "includes") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
          }
          if (_issue.format === "regex") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
          }
          return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
        case "not_multiple_of":
          return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
        case "unrecognized_keys":
          return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
        case "invalid_union":
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        case "invalid_element":
          return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
        default:
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
    };
  };
  function fa_default() {
    return {
      localeError: error12()
    };
  }

  // node_modules/zod/v4/locales/fi.js
  var error13 = () => {
    const Sizable = {
      string: { unit: "merkki\xE4", subject: "merkkijonon" },
      file: { unit: "tavua", subject: "tiedoston" },
      array: { unit: "alkiota", subject: "listan" },
      set: { unit: "alkiota", subject: "joukon" },
      number: { unit: "", subject: "luvun" },
      bigint: { unit: "", subject: "suuren kokonaisluvun" },
      int: { unit: "", subject: "kokonaisluvun" },
      date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "s\xE4\xE4nn\xF6llinen lauseke",
      email: "s\xE4hk\xF6postiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
          return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
          if (_issue.format === "regex") {
            return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
          }
          return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Virheellinen avain tietueessa";
        case "invalid_union":
          return "Virheellinen unioni";
        case "invalid_element":
          return "Virheellinen arvo joukossa";
        default:
          return `Virheellinen sy\xF6te`;
      }
    };
  };
  function fi_default() {
    return {
      localeError: error13()
    };
  }

  // node_modules/zod/v4/locales/fr.js
  var error14 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombre";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tableau";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "entr\xE9e",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} re\xE7u`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
          return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
          return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_default() {
    return {
      localeError: error14()
    };
  }

  // node_modules/zod/v4/locales/fr-CA.js
  var error15 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "entr\xE9e",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
          return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u2264" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u2265" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_CA_default() {
    return {
      localeError: error15()
    };
  }

  // node_modules/zod/v4/locales/he.js
  var error16 = () => {
    const Sizable = {
      string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
      file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
      array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
      set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u05E7\u05DC\u05D8",
      email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
      url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
      emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
      date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
      time: "\u05D6\u05DE\u05DF ISO",
      duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
      ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
      ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
      cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
      cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
      base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
      base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
      json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
      e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
      jwt: "JWT",
      template_literal: "\u05E7\u05DC\u05D8"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
        case "not_multiple_of":
          return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
        case "invalid_union":
          return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
        case "invalid_element":
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
        default:
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
    };
  };
  function he_default() {
    return {
      localeError: error16()
    };
  }

  // node_modules/zod/v4/locales/hu.js
  var error17 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "legyen" },
      file: { unit: "byte", verb: "legyen" },
      array: { unit: "elem", verb: "legyen" },
      set: { unit: "elem", verb: "legyen" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "sz\xE1m";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "t\xF6mb";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "bemenet",
      email: "email c\xEDm",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO id\u0151b\xE9lyeg",
      date: "ISO d\xE1tum",
      time: "ISO id\u0151",
      duration: "ISO id\u0151intervallum",
      ipv4: "IPv4 c\xEDm",
      ipv6: "IPv6 c\xEDm",
      cidrv4: "IPv4 tartom\xE1ny",
      cidrv6: "IPv6 tartom\xE1ny",
      base64: "base64-k\xF3dolt string",
      base64url: "base64url-k\xF3dolt string",
      json_string: "JSON string",
      e164: "E.164 sz\xE1m",
      jwt: "JWT",
      template_literal: "bemenet"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
          return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
          if (_issue.format === "ends_with")
            return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
          if (_issue.format === "includes")
            return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
          if (_issue.format === "regex")
            return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
          return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
        case "unrecognized_keys":
          return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
        case "invalid_union":
          return "\xC9rv\xE9nytelen bemenet";
        case "invalid_element":
          return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
        default:
          return `\xC9rv\xE9nytelen bemenet`;
      }
    };
  };
  function hu_default() {
    return {
      localeError: error17()
    };
  }

  // node_modules/zod/v4/locales/id.js
  var error18 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "memiliki" },
      file: { unit: "byte", verb: "memiliki" },
      array: { unit: "item", verb: "memiliki" },
      set: { unit: "item", verb: "memiliki" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak valid: harus menyertakan "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
        }
        case "not_multiple_of":
          return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak valid di ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak valid";
        case "invalid_element":
          return `Nilai tidak valid di ${issue2.origin}`;
        default:
          return `Input tidak valid`;
      }
    };
  };
  function id_default() {
    return {
      localeError: error18()
    };
  }

  // node_modules/zod/v4/locales/is.js
  var parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmer";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "fylki";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  var error19 = () => {
    const Sizable = {
      string: { unit: "stafi", verb: "a\xF0 hafa" },
      file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
      array: { unit: "hluti", verb: "a\xF0 hafa" },
      set: { unit: "hluti", verb: "a\xF0 hafa" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "gildi",
      email: "netfang",
      url: "vefsl\xF3\xF0",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dagsetning og t\xEDmi",
      date: "ISO dagsetning",
      time: "ISO t\xEDmi",
      duration: "ISO t\xEDmalengd",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded strengur",
      base64url: "base64url-encoded strengur",
      json_string: "JSON strengur",
      e164: "E.164 t\xF6lugildi",
      jwt: "JWT",
      template_literal: "gildi"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
          return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
          return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Rangur lykill \xED ${issue2.origin}`;
        case "invalid_union":
          return "Rangt gildi";
        case "invalid_element":
          return `Rangt gildi \xED ${issue2.origin}`;
        default:
          return `Rangt gildi`;
      }
    };
  };
  function is_default() {
    return {
      localeError: error19()
    };
  }

  // node_modules/zod/v4/locales/it.js
  var error20 = () => {
    const Sizable = {
      string: { unit: "caratteri", verb: "avere" },
      file: { unit: "byte", verb: "avere" },
      array: { unit: "elementi", verb: "avere" },
      set: { unit: "elementi", verb: "avere" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "numero";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "vettore";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
          return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
          return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Stringa non valida: deve includere "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chiave non valida in ${issue2.origin}`;
        case "invalid_union":
          return "Input non valido";
        case "invalid_element":
          return `Valore non valido in ${issue2.origin}`;
        default:
          return `Input non valido`;
      }
    };
  };
  function it_default() {
    return {
      localeError: error20()
    };
  }

  // node_modules/zod/v4/locales/ja.js
  var error21 = () => {
    const Sizable = {
      string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
      file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
      array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
      set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u914D\u5217";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u5165\u529B\u5024",
      email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
      url: "URL",
      emoji: "\u7D75\u6587\u5B57",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u6642",
      date: "ISO\u65E5\u4ED8",
      time: "ISO\u6642\u523B",
      duration: "ISO\u671F\u9593",
      ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
      ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
      cidrv4: "IPv4\u7BC4\u56F2",
      cidrv6: "IPv6\u7BC4\u56F2",
      base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      json_string: "JSON\u6587\u5B57\u5217",
      e164: "E.164\u756A\u53F7",
      jwt: "JWT",
      template_literal: "\u5165\u529B\u5024"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
          return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "ends_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "includes")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "regex")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "unrecognized_keys":
          return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
        case "invalid_union":
          return "\u7121\u52B9\u306A\u5165\u529B";
        case "invalid_element":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
        default:
          return `\u7121\u52B9\u306A\u5165\u529B`;
      }
    };
  };
  function ja_default() {
    return {
      localeError: error21()
    };
  }

  // node_modules/zod/v4/locales/ka.js
  var parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    const typeMap = {
      string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
      undefined: "undefined",
      bigint: "bigint",
      symbol: "symbol",
      function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
    };
    return typeMap[t] ?? t;
  };
  var error22 = () => {
    const Sizable = {
      string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
      email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      url: "URL",
      emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
      date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
      time: "\u10D3\u10E0\u10DD",
      duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
      ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
      jwt: "JWT",
      template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
          }
          if (_issue.format === "ends_with")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
          if (_issue.format === "includes")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
          if (_issue.format === "regex")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
        case "unrecognized_keys":
          return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
        case "invalid_union":
          return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
        case "invalid_element":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
        default:
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
      }
    };
  };
  function ka_default() {
    return {
      localeError: error22()
    };
  }

  // node_modules/zod/v4/locales/km.js
  var error23 = () => {
    const Sizable = {
      string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u17A2\u17B6\u179A\u17C1 (Array)";
          }
          if (data === null) {
            return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
      email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
      url: "URL",
      emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
      date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
      time: "\u1798\u17C9\u17C4\u1784 ISO",
      duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
      ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
      base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
      json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
      e164: "\u179B\u17C1\u1781 E.164",
      jwt: "JWT",
      template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
          return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
          return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        case "invalid_union":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        case "invalid_element":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        default:
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      }
    };
  };
  function km_default() {
    return {
      localeError: error23()
    };
  }

  // node_modules/zod/v4/locales/kh.js
  function kh_default() {
    return km_default();
  }

  // node_modules/zod/v4/locales/ko.js
  var error24 = () => {
    const Sizable = {
      string: { unit: "\uBB38\uC790", verb: "to have" },
      file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
      array: { unit: "\uAC1C", verb: "to have" },
      set: { unit: "\uAC1C", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\uC785\uB825",
      email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
      url: "URL",
      emoji: "\uC774\uBAA8\uC9C0",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
      date: "ISO \uB0A0\uC9DC",
      time: "ISO \uC2DC\uAC04",
      duration: "ISO \uAE30\uAC04",
      ipv4: "IPv4 \uC8FC\uC18C",
      ipv6: "IPv6 \uC8FC\uC18C",
      cidrv4: "IPv4 \uBC94\uC704",
      cidrv6: "IPv6 \uBC94\uC704",
      base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      json_string: "JSON \uBB38\uC790\uC5F4",
      e164: "E.164 \uBC88\uD638",
      jwt: "JWT",
      template_literal: "\uC785\uB825"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue2.input)}\uC785\uB2C8\uB2E4`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "too_big": {
          const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
          const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing)
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
          const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing) {
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
          }
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
          }
          if (_issue.format === "ends_with")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "includes")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "regex")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "unrecognized_keys":
          return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
        case "invalid_union":
          return `\uC798\uBABB\uB41C \uC785\uB825`;
        case "invalid_element":
          return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
        default:
          return `\uC798\uBABB\uB41C \uC785\uB825`;
      }
    };
  };
  function ko_default() {
    return {
      localeError: error24()
    };
  }

  // node_modules/zod/v4/locales/lt.js
  var parsedType6 = (data) => {
    const t = typeof data;
    return parsedTypeFromType(t, data);
  };
  var parsedTypeFromType = (t, data = void 0) => {
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
      }
      case "bigint": {
        return "sveikasis skai\u010Dius";
      }
      case "string": {
        return "eilut\u0117";
      }
      case "boolean": {
        return "login\u0117 reik\u0161m\u0117";
      }
      case "undefined":
      case "void": {
        return "neapibr\u0117\u017Eta reik\u0161m\u0117";
      }
      case "function": {
        return "funkcija";
      }
      case "symbol": {
        return "simbolis";
      }
      case "object": {
        if (data === void 0)
          return "ne\u017Einomas objektas";
        if (data === null)
          return "nulin\u0117 reik\u0161m\u0117";
        if (Array.isArray(data))
          return "masyvas";
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objektas";
      }
      case "null": {
        return "nulin\u0117 reik\u0161m\u0117";
      }
    }
    return t;
  };
  var capitalizeFirstCharacter = (text2) => {
    return text2.charAt(0).toUpperCase() + text2.slice(1);
  };
  function getUnitTypeFromNumber(number4) {
    const abs = Math.abs(number4);
    const last = abs % 10;
    const last2 = abs % 100;
    if (last2 >= 11 && last2 <= 19 || last === 0)
      return "many";
    if (last === 1)
      return "one";
    return "few";
  }
  var error25 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "simbolis",
          few: "simboliai",
          many: "simboli\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
            notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
            notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
          }
        }
      },
      file: {
        unit: {
          one: "baitas",
          few: "baitai",
          many: "bait\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne didesnis kaip",
            notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
            notInclusive: "turi b\u016Bti didesnis kaip"
          }
        }
      },
      array: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      },
      set: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      }
    };
    function getSizing(origin, unitType, inclusive, targetShouldBe) {
      const result = Sizable[origin] ?? null;
      if (result === null)
        return result;
      return {
        unit: result.unit[unitType],
        verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
      };
    }
    const Nouns = {
      regex: "\u012Fvestis",
      email: "el. pa\u0161to adresas",
      url: "URL",
      emoji: "jaustukas",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO data ir laikas",
      date: "ISO data",
      time: "ISO laikas",
      duration: "ISO trukm\u0117",
      ipv4: "IPv4 adresas",
      ipv6: "IPv6 adresas",
      cidrv4: "IPv4 tinklo prefiksas (CIDR)",
      cidrv6: "IPv6 tinklo prefiksas (CIDR)",
      base64: "base64 u\u017Ekoduota eilut\u0117",
      base64url: "base64url u\u017Ekoduota eilut\u0117",
      json_string: "JSON eilut\u0117",
      e164: "E.164 numeris",
      jwt: "JWT",
      template_literal: "\u012Fvestis"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
          return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
        case "too_big": {
          const origin = parsedTypeFromType(issue2.origin);
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
        }
        case "too_small": {
          const origin = parsedTypeFromType(issue2.origin);
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
          return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
        case "unrecognized_keys":
          return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Rastas klaidingas raktas";
        case "invalid_union":
          return "Klaidinga \u012Fvestis";
        case "invalid_element": {
          const origin = parsedTypeFromType(issue2.origin);
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
        }
        default:
          return "Klaidinga \u012Fvestis";
      }
    };
  };
  function lt_default() {
    return {
      localeError: error25()
    };
  }

  // node_modules/zod/v4/locales/mk.js
  var error26 = () => {
    const Sizable = {
      string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043D\u0438\u0437\u0430";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0432\u043D\u0435\u0441",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u045F\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0443\u043C",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
      cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
      cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
      base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      json_string: "JSON \u043D\u0438\u0437\u0430",
      e164: "E.164 \u0431\u0440\u043E\u0458",
      jwt: "JWT",
      template_literal: "\u0432\u043D\u0435\u0441"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
          return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
        case "invalid_union":
          return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
        case "invalid_element":
          return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
        default:
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
      }
    };
  };
  function mk_default() {
    return {
      localeError: error26()
    };
  }

  // node_modules/zod/v4/locales/ms.js
  var error27 = () => {
    const Sizable = {
      string: { unit: "aksara", verb: "mempunyai" },
      file: { unit: "bait", verb: "mempunyai" },
      array: { unit: "elemen", verb: "mempunyai" },
      set: { unit: "elemen", verb: "mempunyai" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombor";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
        }
        case "not_multiple_of":
          return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak sah dalam ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak sah";
        case "invalid_element":
          return `Nilai tidak sah dalam ${issue2.origin}`;
        default:
          return `Input tidak sah`;
      }
    };
  };
  function ms_default() {
    return {
      localeError: error27()
    };
  }

  // node_modules/zod/v4/locales/nl.js
  var error28 = () => {
    const Sizable = {
      string: { unit: "tekens" },
      file: { unit: "bytes" },
      array: { unit: "elementen" },
      set: { unit: "elementen" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "getal";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "invoer",
      email: "emailadres",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum en tijd",
      date: "ISO datum",
      time: "ISO tijd",
      duration: "ISO duur",
      ipv4: "IPv4-adres",
      ipv6: "IPv6-adres",
      cidrv4: "IPv4-bereik",
      cidrv6: "IPv6-bereik",
      base64: "base64-gecodeerde tekst",
      base64url: "base64 URL-gecodeerde tekst",
      json_string: "JSON string",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "invoer"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
          return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
          }
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
          }
          if (_issue.format === "ends_with")
            return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
          if (_issue.format === "includes")
            return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
          if (_issue.format === "regex")
            return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
          return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
        case "unrecognized_keys":
          return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ongeldige key in ${issue2.origin}`;
        case "invalid_union":
          return "Ongeldige invoer";
        case "invalid_element":
          return `Ongeldige waarde in ${issue2.origin}`;
        default:
          return `Ongeldige invoer`;
      }
    };
  };
  function nl_default() {
    return {
      localeError: error28()
    };
  }

  // node_modules/zod/v4/locales/no.js
  var error29 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "\xE5 ha" },
      file: { unit: "bytes", verb: "\xE5 ha" },
      array: { unit: "elementer", verb: "\xE5 inneholde" },
      set: { unit: "elementer", verb: "\xE5 inneholde" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "tall";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "liste";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8kkel i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldig input";
        case "invalid_element":
          return `Ugyldig verdi i ${issue2.origin}`;
        default:
          return `Ugyldig input`;
      }
    };
  };
  function no_default() {
    return {
      localeError: error29()
    };
  }

  // node_modules/zod/v4/locales/ota.js
  var error30 = () => {
    const Sizable = {
      string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
      set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "numara";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "saf";
          }
          if (data === null) {
            return "gayb";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "giren",
      email: "epostag\xE2h",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO heng\xE2m\u0131",
      date: "ISO tarihi",
      time: "ISO zaman\u0131",
      duration: "ISO m\xFCddeti",
      ipv4: "IPv4 ni\u015F\xE2n\u0131",
      ipv6: "IPv6 ni\u015F\xE2n\u0131",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-\u015Fifreli metin",
      base64url: "base64url-\u015Fifreli metin",
      json_string: "JSON metin",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "giren"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
          return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
          }
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
          if (_issue.format === "ends_with")
            return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
          if (_issue.format === "includes")
            return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
          if (_issue.format === "regex")
            return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
          return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
        case "invalid_union":
          return "Giren tan\u0131namad\u0131.";
        case "invalid_element":
          return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
        default:
          return `K\u0131ymet tan\u0131namad\u0131.`;
      }
    };
  };
  function ota_default() {
    return {
      localeError: error30()
    };
  }

  // node_modules/zod/v4/locales/ps.js
  var error31 = () => {
    const Sizable = {
      string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
      array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u0627\u0631\u06D0";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0648\u0631\u0648\u062F\u064A",
      email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
      date: "\u0646\u06D0\u067C\u0647",
      time: "\u0648\u062E\u062A",
      duration: "\u0645\u0648\u062F\u0647",
      ipv4: "\u062F IPv4 \u067E\u062A\u0647",
      ipv6: "\u062F IPv6 \u067E\u062A\u0647",
      cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
      cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
      base64: "base64-encoded \u0645\u062A\u0646",
      base64url: "base64url-encoded \u0645\u062A\u0646",
      json_string: "JSON \u0645\u062A\u0646",
      e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u064A"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
          }
          return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
          }
          if (_issue.format === "ends_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
          }
          if (_issue.format === "includes") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
          }
          if (_issue.format === "regex") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
          }
          return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
        }
        case "not_multiple_of":
          return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
        case "unrecognized_keys":
          return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        case "invalid_union":
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        case "invalid_element":
          return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        default:
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      }
    };
  };
  function ps_default() {
    return {
      localeError: error31()
    };
  }

  // node_modules/zod/v4/locales/pl.js
  var error32 = () => {
    const Sizable = {
      string: { unit: "znak\xF3w", verb: "mie\u0107" },
      file: { unit: "bajt\xF3w", verb: "mie\u0107" },
      array: { unit: "element\xF3w", verb: "mie\u0107" },
      set: { unit: "element\xF3w", verb: "mie\u0107" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "liczba";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tablica";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "wyra\u017Cenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
      base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
      json_string: "ci\u0105g znak\xF3w w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wej\u015Bcie"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
          return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
          return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
        case "invalid_union":
          return "Nieprawid\u0142owe dane wej\u015Bciowe";
        case "invalid_element":
          return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
        default:
          return `Nieprawid\u0142owe dane wej\u015Bciowe`;
      }
    };
  };
  function pl_default() {
    return {
      localeError: error32()
    };
  }

  // node_modules/zod/v4/locales/pt.js
  var error33 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "ter" },
      file: { unit: "bytes", verb: "ter" },
      array: { unit: "itens", verb: "ter" },
      set: { unit: "itens", verb: "ter" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\xFAmero";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "nulo";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "padr\xE3o",
      email: "endere\xE7o de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "dura\xE7\xE3o ISO",
      ipv4: "endere\xE7o IPv4",
      ipv6: "endere\xE7o IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
          return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chave inv\xE1lida em ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido em ${issue2.origin}`;
        default:
          return `Campo inv\xE1lido`;
      }
    };
  };
  function pt_default() {
    return {
      localeError: error33()
    };
  }

  // node_modules/zod/v4/locales/ru.js
  function getRussianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error34 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0438\u043C\u0432\u043E\u043B",
          few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
          many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u0430",
          many: "\u0431\u0430\u0439\u0442"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0441\u0438\u0432";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0432\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u044F",
      duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
      base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
      json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0432\u043E\u0434"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
      }
    };
  };
  function ru_default() {
    return {
      localeError: error34()
    };
  }

  // node_modules/zod/v4/locales/sl.js
  var error35 = () => {
    const Sizable = {
      string: { unit: "znakov", verb: "imeti" },
      file: { unit: "bajtov", verb: "imeti" },
      array: { unit: "elementov", verb: "imeti" },
      set: { unit: "elementov", verb: "imeti" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabela";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "vnos",
      email: "e-po\u0161tni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in \u010Das",
      date: "ISO datum",
      time: "ISO \u010Das",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 \u0161tevilka",
      jwt: "JWT",
      template_literal: "vnos"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
          return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
          return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neveljaven klju\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neveljaven vnos";
        case "invalid_element":
          return `Neveljavna vrednost v ${issue2.origin}`;
        default:
          return "Neveljaven vnos";
      }
    };
  };
  function sl_default() {
    return {
      localeError: error35()
    };
  }

  // node_modules/zod/v4/locales/sv.js
  var error36 = () => {
    const Sizable = {
      string: { unit: "tecken", verb: "att ha" },
      file: { unit: "bytes", verb: "att ha" },
      array: { unit: "objekt", verb: "att inneh\xE5lla" },
      set: { unit: "objekt", verb: "att inneh\xE5lla" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "antal";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "lista";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "regulj\xE4rt uttryck",
      email: "e-postadress",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datum och tid",
      date: "ISO-datum",
      time: "ISO-tid",
      duration: "ISO-varaktighet",
      ipv4: "IPv4-intervall",
      ipv6: "IPv6-intervall",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodad str\xE4ng",
      base64url: "base64url-kodad str\xE4ng",
      json_string: "JSON-str\xE4ng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "mall-literal"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
          return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          }
          return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
          return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
        case "invalid_union":
          return "Ogiltig input";
        case "invalid_element":
          return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
        default:
          return `Ogiltig input`;
      }
    };
  };
  function sv_default() {
    return {
      localeError: error36()
    };
  }

  // node_modules/zod/v4/locales/ta.js
  var error37 = () => {
    const Sizable = {
      string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u0B85\u0BA3\u0BBF";
          }
          if (data === null) {
            return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
      email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
      time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
      ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
      e164: "E.164 \u0B8E\u0BA3\u0BCD",
      jwt: "JWT",
      template_literal: "input"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "ends_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "includes")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "regex")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        case "unrecognized_keys":
          return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
        case "invalid_union":
          return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
        case "invalid_element":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
        default:
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
      }
    };
  };
  function ta_default() {
    return {
      localeError: error37()
    };
  }

  // node_modules/zod/v4/locales/th.js
  var error38 = () => {
    const Sizable = {
      string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
          }
          if (data === null) {
            return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
      email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
      url: "URL",
      emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
      time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
      ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
      cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
      cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
      base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
      base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
      json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
      e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
      jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
      template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
          if (_issue.format === "regex")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
        case "unrecognized_keys":
          return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        case "invalid_union":
          return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
        case "invalid_element":
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        default:
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
      }
    };
  };
  function th_default() {
    return {
      localeError: error38()
    };
  }

  // node_modules/zod/v4/locales/tr.js
  var parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  var error39 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "olmal\u0131" },
      file: { unit: "bayt", verb: "olmal\u0131" },
      array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
      set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const Nouns = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO s\xFCre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aral\u0131\u011F\u0131",
      cidrv6: "IPv6 aral\u0131\u011F\u0131",
      base64: "base64 ile \u015Fifrelenmi\u015F metin",
      base64url: "base64url ile \u015Fifrelenmi\u015F metin",
      json_string: "JSON dizesi",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "\u015Eablon dizesi"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
          return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
          if (_issue.format === "ends_with")
            return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
          if (_issue.format === "includes")
            return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
          if (_issue.format === "regex")
            return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
          return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
        case "invalid_union":
          return "Ge\xE7ersiz de\u011Fer";
        case "invalid_element":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
        default:
          return `Ge\xE7ersiz de\u011Fer`;
      }
    };
  };
  function tr_default() {
    return {
      localeError: error39()
    };
  }

  // node_modules/zod/v4/locales/uk.js
  var error40 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0438\u0432";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
      date: "\u0434\u0430\u0442\u0430 ISO",
      time: "\u0447\u0430\u0441 ISO",
      duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
      ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
      ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
      cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
      cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
      base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
      base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
      json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
        case "invalid_element":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
      }
    };
  };
  function uk_default() {
    return {
      localeError: error40()
    };
  }

  // node_modules/zod/v4/locales/ua.js
  function ua_default() {
    return uk_default();
  }

  // node_modules/zod/v4/locales/ur.js
  var error41 = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
      file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
      array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
      set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u0622\u0631\u06D2";
          }
          if (data === null) {
            return "\u0646\u0644";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0627\u0646 \u067E\u0679",
      email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
      uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
      nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
      ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
      xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
      ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
      date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
      time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
      duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
      ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
      cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
      base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
      e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
      jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
      template_literal: "\u0627\u0646 \u067E\u0679"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          }
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          }
          if (_issue.format === "ends_with")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "includes")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "regex")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        case "unrecognized_keys":
          return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
        case "invalid_union":
          return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
        case "invalid_element":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
        default:
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
      }
    };
  };
  function ur_default() {
    return {
      localeError: error41()
    };
  }

  // node_modules/zod/v4/locales/vi.js
  var error42 = () => {
    const Sizable = {
      string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
      file: { unit: "byte", verb: "c\xF3" },
      array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
      set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "s\u1ED1";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "m\u1EA3ng";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u0111\u1EA7u v\xE0o",
      email: "\u0111\u1ECBa ch\u1EC9 email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ng\xE0y gi\u1EDD ISO",
      date: "ng\xE0y ISO",
      time: "gi\u1EDD ISO",
      duration: "kho\u1EA3ng th\u1EDDi gian ISO",
      ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
      ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
      cidrv4: "d\u1EA3i IPv4",
      cidrv6: "d\u1EA3i IPv6",
      base64: "chu\u1ED7i m\xE3 h\xF3a base64",
      base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
      json_string: "chu\u1ED7i JSON",
      e164: "s\u1ED1 E.164",
      jwt: "JWT",
      template_literal: "\u0111\u1EA7u v\xE0o"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
          return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
          return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
        }
        case "not_multiple_of":
          return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        case "invalid_union":
          return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
        case "invalid_element":
          return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        default:
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
      }
    };
  };
  function vi_default() {
    return {
      localeError: error42()
    };
  }

  // node_modules/zod/v4/locales/zh-CN.js
  var error43 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
      file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
      array: { unit: "\u9879", verb: "\u5305\u542B" },
      set: { unit: "\u9879", verb: "\u5305\u542B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u6570\u7EC4";
          }
          if (data === null) {
            return "\u7A7A\u503C(null)";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u8F93\u5165",
      email: "\u7535\u5B50\u90AE\u4EF6",
      url: "URL",
      emoji: "\u8868\u60C5\u7B26\u53F7",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u671F\u65F6\u95F4",
      date: "ISO\u65E5\u671F",
      time: "ISO\u65F6\u95F4",
      duration: "ISO\u65F6\u957F",
      ipv4: "IPv4\u5730\u5740",
      ipv6: "IPv6\u5730\u5740",
      cidrv4: "IPv4\u7F51\u6BB5",
      cidrv6: "IPv6\u7F51\u6BB5",
      base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
      base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
      json_string: "JSON\u5B57\u7B26\u4E32",
      e164: "E.164\u53F7\u7801",
      jwt: "JWT",
      template_literal: "\u8F93\u5165"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
          return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
          if (_issue.format === "ends_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
          if (_issue.format === "includes")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
          return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
        case "unrecognized_keys":
          return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
        case "invalid_union":
          return "\u65E0\u6548\u8F93\u5165";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
        default:
          return `\u65E0\u6548\u8F93\u5165`;
      }
    };
  };
  function zh_CN_default() {
    return {
      localeError: error43()
    };
  }

  // node_modules/zod/v4/locales/zh-TW.js
  var error44 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
      file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
      array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
      set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u8F38\u5165",
      email: "\u90F5\u4EF6\u5730\u5740",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u65E5\u671F\u6642\u9593",
      date: "ISO \u65E5\u671F",
      time: "ISO \u6642\u9593",
      duration: "ISO \u671F\u9593",
      ipv4: "IPv4 \u4F4D\u5740",
      ipv6: "IPv6 \u4F4D\u5740",
      cidrv4: "IPv4 \u7BC4\u570D",
      cidrv6: "IPv6 \u7BC4\u570D",
      base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
      base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
      json_string: "JSON \u5B57\u4E32",
      e164: "E.164 \u6578\u503C",
      jwt: "JWT",
      template_literal: "\u8F38\u5165"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
          return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
          }
          if (_issue.format === "ends_with")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
          if (_issue.format === "includes")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
          return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
        case "unrecognized_keys":
          return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
        case "invalid_union":
          return "\u7121\u6548\u7684\u8F38\u5165\u503C";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
        default:
          return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
      }
    };
  };
  function zh_TW_default() {
    return {
      localeError: error44()
    };
  }

  // node_modules/zod/v4/locales/yo.js
  var error45 = () => {
    const Sizable = {
      string: { unit: "\xE0mi", verb: "n\xED" },
      file: { unit: "bytes", verb: "n\xED" },
      array: { unit: "nkan", verb: "n\xED" },
      set: { unit: "nkan", verb: "n\xED" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const parsedType8 = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "akop\u1ECD";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    const Nouns = {
      regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
      email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\xE0k\xF3k\xF2 ISO",
      date: "\u1ECDj\u1ECD\u0301 ISO",
      time: "\xE0k\xF3k\xF2 ISO",
      duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
      ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
      ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
      cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
      cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
      base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
      base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
      json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
      e164: "n\u1ECD\u0301mb\xE0 E.164",
      jwt: "JWT",
      template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type":
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
          return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
        case "unrecognized_keys":
          return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        case "invalid_union":
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        case "invalid_element":
          return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        default:
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      }
    };
  };
  function yo_default() {
    return {
      localeError: error45()
    };
  }

  // node_modules/zod/v4/core/registries.js
  var $output = Symbol("ZodOutput");
  var $input = Symbol("ZodInput");
  var $ZodRegistry = class {
    constructor() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
    }
    add(schema, ..._meta) {
      const meta = _meta[0];
      this._map.set(schema, meta);
      if (meta && typeof meta === "object" && "id" in meta) {
        if (this._idmap.has(meta.id)) {
          throw new Error(`ID ${meta.id} already exists in the registry`);
        }
        this._idmap.set(meta.id, schema);
      }
      return this;
    }
    clear() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
      return this;
    }
    remove(schema) {
      const meta = this._map.get(schema);
      if (meta && typeof meta === "object" && "id" in meta) {
        this._idmap.delete(meta.id);
      }
      this._map.delete(schema);
      return this;
    }
    get(schema) {
      const p = schema._zod.parent;
      if (p) {
        const pm = { ...this.get(p) ?? {} };
        delete pm.id;
        const f = { ...pm, ...this._map.get(schema) };
        return Object.keys(f).length ? f : void 0;
      }
      return this._map.get(schema);
    }
    has(schema) {
      return this._map.has(schema);
    }
  };
  function registry() {
    return new $ZodRegistry();
  }
  var globalRegistry = /* @__PURE__ */ registry();

  // node_modules/zod/v4/core/api.js
  function _string(Class2, params) {
    return new Class2({
      type: "string",
      ...normalizeParams(params)
    });
  }
  function _coercedString(Class2, params) {
    return new Class2({
      type: "string",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  function _email(Class2, params) {
    return new Class2({
      type: "string",
      format: "email",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _guid(Class2, params) {
    return new Class2({
      type: "string",
      format: "guid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _uuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _uuidv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v4",
      ...normalizeParams(params)
    });
  }
  function _uuidv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v6",
      ...normalizeParams(params)
    });
  }
  function _uuidv7(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v7",
      ...normalizeParams(params)
    });
  }
  function _url(Class2, params) {
    return new Class2({
      type: "string",
      format: "url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _emoji2(Class2, params) {
    return new Class2({
      type: "string",
      format: "emoji",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _nanoid(Class2, params) {
    return new Class2({
      type: "string",
      format: "nanoid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _cuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _cuid2(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid2",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _ulid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ulid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _xid(Class2, params) {
    return new Class2({
      type: "string",
      format: "xid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _ksuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ksuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _ipv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _ipv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _cidrv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _cidrv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _base64(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _base64url(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _e164(Class2, params) {
    return new Class2({
      type: "string",
      format: "e164",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  function _jwt(Class2, params) {
    return new Class2({
      type: "string",
      format: "jwt",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  var TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
  function _isoDateTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "datetime",
      check: "string_format",
      offset: false,
      local: false,
      precision: null,
      ...normalizeParams(params)
    });
  }
  function _isoDate(Class2, params) {
    return new Class2({
      type: "string",
      format: "date",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  function _isoTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "time",
      check: "string_format",
      precision: null,
      ...normalizeParams(params)
    });
  }
  function _isoDuration(Class2, params) {
    return new Class2({
      type: "string",
      format: "duration",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  function _number(Class2, params) {
    return new Class2({
      type: "number",
      checks: [],
      ...normalizeParams(params)
    });
  }
  function _coercedNumber(Class2, params) {
    return new Class2({
      type: "number",
      coerce: true,
      checks: [],
      ...normalizeParams(params)
    });
  }
  function _int(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "safeint",
      ...normalizeParams(params)
    });
  }
  function _float32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float32",
      ...normalizeParams(params)
    });
  }
  function _float64(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float64",
      ...normalizeParams(params)
    });
  }
  function _int32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "int32",
      ...normalizeParams(params)
    });
  }
  function _uint32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "uint32",
      ...normalizeParams(params)
    });
  }
  function _boolean(Class2, params) {
    return new Class2({
      type: "boolean",
      ...normalizeParams(params)
    });
  }
  function _coercedBoolean(Class2, params) {
    return new Class2({
      type: "boolean",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  function _bigint(Class2, params) {
    return new Class2({
      type: "bigint",
      ...normalizeParams(params)
    });
  }
  function _coercedBigint(Class2, params) {
    return new Class2({
      type: "bigint",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  function _int64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "int64",
      ...normalizeParams(params)
    });
  }
  function _uint64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "uint64",
      ...normalizeParams(params)
    });
  }
  function _symbol(Class2, params) {
    return new Class2({
      type: "symbol",
      ...normalizeParams(params)
    });
  }
  function _undefined2(Class2, params) {
    return new Class2({
      type: "undefined",
      ...normalizeParams(params)
    });
  }
  function _null2(Class2, params) {
    return new Class2({
      type: "null",
      ...normalizeParams(params)
    });
  }
  function _any(Class2) {
    return new Class2({
      type: "any"
    });
  }
  function _unknown(Class2) {
    return new Class2({
      type: "unknown"
    });
  }
  function _never(Class2, params) {
    return new Class2({
      type: "never",
      ...normalizeParams(params)
    });
  }
  function _void(Class2, params) {
    return new Class2({
      type: "void",
      ...normalizeParams(params)
    });
  }
  function _date(Class2, params) {
    return new Class2({
      type: "date",
      ...normalizeParams(params)
    });
  }
  function _coercedDate(Class2, params) {
    return new Class2({
      type: "date",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  function _nan(Class2, params) {
    return new Class2({
      type: "nan",
      ...normalizeParams(params)
    });
  }
  function _lt(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  function _lte(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  function _gt(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  function _gte(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  function _positive(params) {
    return _gt(0, params);
  }
  function _negative(params) {
    return _lt(0, params);
  }
  function _nonpositive(params) {
    return _lte(0, params);
  }
  function _nonnegative(params) {
    return _gte(0, params);
  }
  function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
      check: "multiple_of",
      ...normalizeParams(params),
      value
    });
  }
  function _maxSize(maximum, params) {
    return new $ZodCheckMaxSize({
      check: "max_size",
      ...normalizeParams(params),
      maximum
    });
  }
  function _minSize(minimum, params) {
    return new $ZodCheckMinSize({
      check: "min_size",
      ...normalizeParams(params),
      minimum
    });
  }
  function _size(size, params) {
    return new $ZodCheckSizeEquals({
      check: "size_equals",
      ...normalizeParams(params),
      size
    });
  }
  function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
      check: "max_length",
      ...normalizeParams(params),
      maximum
    });
    return ch;
  }
  function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
      check: "min_length",
      ...normalizeParams(params),
      minimum
    });
  }
  function _length(length, params) {
    return new $ZodCheckLengthEquals({
      check: "length_equals",
      ...normalizeParams(params),
      length
    });
  }
  function _regex(pattern, params) {
    return new $ZodCheckRegex({
      check: "string_format",
      format: "regex",
      ...normalizeParams(params),
      pattern
    });
  }
  function _lowercase(params) {
    return new $ZodCheckLowerCase({
      check: "string_format",
      format: "lowercase",
      ...normalizeParams(params)
    });
  }
  function _uppercase(params) {
    return new $ZodCheckUpperCase({
      check: "string_format",
      format: "uppercase",
      ...normalizeParams(params)
    });
  }
  function _includes(includes, params) {
    return new $ZodCheckIncludes({
      check: "string_format",
      format: "includes",
      ...normalizeParams(params),
      includes
    });
  }
  function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
      check: "string_format",
      format: "starts_with",
      ...normalizeParams(params),
      prefix
    });
  }
  function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
      check: "string_format",
      format: "ends_with",
      ...normalizeParams(params),
      suffix
    });
  }
  function _property(property, schema, params) {
    return new $ZodCheckProperty({
      check: "property",
      property,
      schema,
      ...normalizeParams(params)
    });
  }
  function _mime(types, params) {
    return new $ZodCheckMimeType({
      check: "mime_type",
      mime: types,
      ...normalizeParams(params)
    });
  }
  function _overwrite(tx) {
    return new $ZodCheckOverwrite({
      check: "overwrite",
      tx
    });
  }
  function _normalize(form) {
    return _overwrite((input) => input.normalize(form));
  }
  function _trim() {
    return _overwrite((input) => input.trim());
  }
  function _toLowerCase() {
    return _overwrite((input) => input.toLowerCase());
  }
  function _toUpperCase() {
    return _overwrite((input) => input.toUpperCase());
  }
  function _array(Class2, element, params) {
    return new Class2({
      type: "array",
      element,
      // get element() {
      //   return element;
      // },
      ...normalizeParams(params)
    });
  }
  function _union(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      ...normalizeParams(params)
    });
  }
  function _discriminatedUnion(Class2, discriminator, options, params) {
    return new Class2({
      type: "union",
      options,
      discriminator,
      ...normalizeParams(params)
    });
  }
  function _intersection(Class2, left, right) {
    return new Class2({
      type: "intersection",
      left,
      right
    });
  }
  function _tuple(Class2, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class2({
      type: "tuple",
      items,
      rest,
      ...normalizeParams(params)
    });
  }
  function _record(Class2, keyType, valueType, params) {
    return new Class2({
      type: "record",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  function _map(Class2, keyType, valueType, params) {
    return new Class2({
      type: "map",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  function _set(Class2, valueType, params) {
    return new Class2({
      type: "set",
      valueType,
      ...normalizeParams(params)
    });
  }
  function _enum(Class2, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  function _nativeEnum(Class2, entries, params) {
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  function _literal(Class2, value, params) {
    return new Class2({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...normalizeParams(params)
    });
  }
  function _file(Class2, params) {
    return new Class2({
      type: "file",
      ...normalizeParams(params)
    });
  }
  function _transform(Class2, fn) {
    return new Class2({
      type: "transform",
      transform: fn
    });
  }
  function _optional(Class2, innerType) {
    return new Class2({
      type: "optional",
      innerType
    });
  }
  function _nullable(Class2, innerType) {
    return new Class2({
      type: "nullable",
      innerType
    });
  }
  function _default(Class2, innerType, defaultValue) {
    return new Class2({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
      }
    });
  }
  function _nonoptional(Class2, innerType, params) {
    return new Class2({
      type: "nonoptional",
      innerType,
      ...normalizeParams(params)
    });
  }
  function _success(Class2, innerType) {
    return new Class2({
      type: "success",
      innerType
    });
  }
  function _catch(Class2, innerType, catchValue) {
    return new Class2({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  function _pipe(Class2, in_, out) {
    return new Class2({
      type: "pipe",
      in: in_,
      out
    });
  }
  function _readonly(Class2, innerType) {
    return new Class2({
      type: "readonly",
      innerType
    });
  }
  function _templateLiteral(Class2, parts, params) {
    return new Class2({
      type: "template_literal",
      parts,
      ...normalizeParams(params)
    });
  }
  function _lazy(Class2, getter) {
    return new Class2({
      type: "lazy",
      getter
    });
  }
  function _promise(Class2, innerType) {
    return new Class2({
      type: "promise",
      innerType
    });
  }
  function _custom(Class2, fn, _params) {
    const norm = normalizeParams(_params);
    norm.abort ?? (norm.abort = true);
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...norm
    });
    return schema;
  }
  function _refine(Class2, fn, _params) {
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...normalizeParams(_params)
    });
    return schema;
  }
  function _superRefine(fn) {
    const ch = _check((payload) => {
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(issue(issue2, payload.value, ch._zod.def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = ch);
          _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
          payload.issues.push(issue(_issue));
        }
      };
      return fn(payload.value, payload);
    });
    return ch;
  }
  function _check(fn, params) {
    const ch = new $ZodCheck({
      check: "custom",
      ...normalizeParams(params)
    });
    ch._zod.check = fn;
    return ch;
  }
  function _stringbool(Classes, _params) {
    const params = normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
      truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? $ZodCodec;
    const _Boolean = Classes.Boolean ?? $ZodBoolean;
    const _String = Classes.String ?? $ZodString;
    const stringSchema = new _String({ type: "string", error: params.error });
    const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
    const codec2 = new _Codec({
      type: "pipe",
      in: stringSchema,
      out: booleanSchema,
      transform: (input, payload) => {
        let data = input;
        if (params.case !== "sensitive")
          data = data.toLowerCase();
        if (truthySet.has(data)) {
          return true;
        } else if (falsySet.has(data)) {
          return false;
        } else {
          payload.issues.push({
            code: "invalid_value",
            expected: "stringbool",
            values: [...truthySet, ...falsySet],
            input: payload.value,
            inst: codec2,
            continue: false
          });
          return {};
        }
      },
      reverseTransform: (input, _payload) => {
        if (input === true) {
          return truthyArray[0] || "true";
        } else {
          return falsyArray[0] || "false";
        }
      },
      error: params.error
    });
    return codec2;
  }
  function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
    const params = normalizeParams(_params);
    const def = {
      ...normalizeParams(_params),
      check: "string_format",
      type: "string",
      format,
      fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
      ...params
    };
    if (fnOrRegex instanceof RegExp) {
      def.pattern = fnOrRegex;
    }
    const inst = new Class2(def);
    return inst;
  }

  // node_modules/zod/v4/core/to-json-schema.js
  var JSONSchemaGenerator = class {
    constructor(params) {
      this.counter = 0;
      this.metadataRegistry = params?.metadata ?? globalRegistry;
      this.target = params?.target ?? "draft-2020-12";
      this.unrepresentable = params?.unrepresentable ?? "throw";
      this.override = params?.override ?? (() => {
      });
      this.io = params?.io ?? "output";
      this.seen = /* @__PURE__ */ new Map();
    }
    process(schema, _params = { path: [], schemaPath: [] }) {
      var _a17;
      const def = schema._zod.def;
      const formatMap = {
        guid: "uuid",
        url: "uri",
        datetime: "date-time",
        json_string: "json-string",
        regex: ""
        // do not set
      };
      const seen = this.seen.get(schema);
      if (seen) {
        seen.count++;
        const isCycle = _params.schemaPath.includes(schema);
        if (isCycle) {
          seen.cycle = _params.path;
        }
        return seen.schema;
      }
      const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
      this.seen.set(schema, result);
      const overrideSchema = schema._zod.toJSONSchema?.();
      if (overrideSchema) {
        result.schema = overrideSchema;
      } else {
        const params = {
          ..._params,
          schemaPath: [..._params.schemaPath, schema],
          path: _params.path
        };
        const parent = schema._zod.parent;
        if (parent) {
          result.ref = parent;
          this.process(parent, params);
          this.seen.get(parent).isParent = true;
        } else {
          const _json = result.schema;
          switch (def.type) {
            case "string": {
              const json2 = _json;
              json2.type = "string";
              const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minLength = minimum;
              if (typeof maximum === "number")
                json2.maxLength = maximum;
              if (format) {
                json2.format = formatMap[format] ?? format;
                if (json2.format === "")
                  delete json2.format;
              }
              if (contentEncoding)
                json2.contentEncoding = contentEncoding;
              if (patterns && patterns.size > 0) {
                const regexes = [...patterns];
                if (regexes.length === 1)
                  json2.pattern = regexes[0].source;
                else if (regexes.length > 1) {
                  result.schema.allOf = [
                    ...regexes.map((regex) => ({
                      ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                      pattern: regex.source
                    }))
                  ];
                }
              }
              break;
            }
            case "number": {
              const json2 = _json;
              const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
              if (typeof format === "string" && format.includes("int"))
                json2.type = "integer";
              else
                json2.type = "number";
              if (typeof exclusiveMinimum === "number") {
                if (this.target === "draft-4" || this.target === "openapi-3.0") {
                  json2.minimum = exclusiveMinimum;
                  json2.exclusiveMinimum = true;
                } else {
                  json2.exclusiveMinimum = exclusiveMinimum;
                }
              }
              if (typeof minimum === "number") {
                json2.minimum = minimum;
                if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                  if (exclusiveMinimum >= minimum)
                    delete json2.minimum;
                  else
                    delete json2.exclusiveMinimum;
                }
              }
              if (typeof exclusiveMaximum === "number") {
                if (this.target === "draft-4" || this.target === "openapi-3.0") {
                  json2.maximum = exclusiveMaximum;
                  json2.exclusiveMaximum = true;
                } else {
                  json2.exclusiveMaximum = exclusiveMaximum;
                }
              }
              if (typeof maximum === "number") {
                json2.maximum = maximum;
                if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                  if (exclusiveMaximum <= maximum)
                    delete json2.maximum;
                  else
                    delete json2.exclusiveMaximum;
                }
              }
              if (typeof multipleOf === "number")
                json2.multipleOf = multipleOf;
              break;
            }
            case "boolean": {
              const json2 = _json;
              json2.type = "boolean";
              break;
            }
            case "bigint": {
              if (this.unrepresentable === "throw") {
                throw new Error("BigInt cannot be represented in JSON Schema");
              }
              break;
            }
            case "symbol": {
              if (this.unrepresentable === "throw") {
                throw new Error("Symbols cannot be represented in JSON Schema");
              }
              break;
            }
            case "null": {
              if (this.target === "openapi-3.0") {
                _json.type = "string";
                _json.nullable = true;
                _json.enum = [null];
              } else
                _json.type = "null";
              break;
            }
            case "any": {
              break;
            }
            case "unknown": {
              break;
            }
            case "undefined": {
              if (this.unrepresentable === "throw") {
                throw new Error("Undefined cannot be represented in JSON Schema");
              }
              break;
            }
            case "void": {
              if (this.unrepresentable === "throw") {
                throw new Error("Void cannot be represented in JSON Schema");
              }
              break;
            }
            case "never": {
              _json.not = {};
              break;
            }
            case "date": {
              if (this.unrepresentable === "throw") {
                throw new Error("Date cannot be represented in JSON Schema");
              }
              break;
            }
            case "array": {
              const json2 = _json;
              const { minimum, maximum } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minItems = minimum;
              if (typeof maximum === "number")
                json2.maxItems = maximum;
              json2.type = "array";
              json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
              break;
            }
            case "object": {
              const json2 = _json;
              json2.type = "object";
              json2.properties = {};
              const shape = def.shape;
              for (const key in shape) {
                json2.properties[key] = this.process(shape[key], {
                  ...params,
                  path: [...params.path, "properties", key]
                });
              }
              const allKeys = new Set(Object.keys(shape));
              const requiredKeys = new Set([...allKeys].filter((key) => {
                const v = def.shape[key]._zod;
                if (this.io === "input") {
                  return v.optin === void 0;
                } else {
                  return v.optout === void 0;
                }
              }));
              if (requiredKeys.size > 0) {
                json2.required = Array.from(requiredKeys);
              }
              if (def.catchall?._zod.def.type === "never") {
                json2.additionalProperties = false;
              } else if (!def.catchall) {
                if (this.io === "output")
                  json2.additionalProperties = false;
              } else if (def.catchall) {
                json2.additionalProperties = this.process(def.catchall, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
              }
              break;
            }
            case "union": {
              const json2 = _json;
              const options = def.options.map((x, i) => this.process(x, {
                ...params,
                path: [...params.path, "anyOf", i]
              }));
              json2.anyOf = options;
              break;
            }
            case "intersection": {
              const json2 = _json;
              const a = this.process(def.left, {
                ...params,
                path: [...params.path, "allOf", 0]
              });
              const b = this.process(def.right, {
                ...params,
                path: [...params.path, "allOf", 1]
              });
              const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
              const allOf = [
                ...isSimpleIntersection(a) ? a.allOf : [a],
                ...isSimpleIntersection(b) ? b.allOf : [b]
              ];
              json2.allOf = allOf;
              break;
            }
            case "tuple": {
              const json2 = _json;
              json2.type = "array";
              const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
              const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
              const prefixItems = def.items.map((x, i) => this.process(x, {
                ...params,
                path: [...params.path, prefixPath, i]
              }));
              const rest = def.rest ? this.process(def.rest, {
                ...params,
                path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
              }) : null;
              if (this.target === "draft-2020-12") {
                json2.prefixItems = prefixItems;
                if (rest) {
                  json2.items = rest;
                }
              } else if (this.target === "openapi-3.0") {
                json2.items = {
                  anyOf: prefixItems
                };
                if (rest) {
                  json2.items.anyOf.push(rest);
                }
                json2.minItems = prefixItems.length;
                if (!rest) {
                  json2.maxItems = prefixItems.length;
                }
              } else {
                json2.items = prefixItems;
                if (rest) {
                  json2.additionalItems = rest;
                }
              }
              const { minimum, maximum } = schema._zod.bag;
              if (typeof minimum === "number")
                json2.minItems = minimum;
              if (typeof maximum === "number")
                json2.maxItems = maximum;
              break;
            }
            case "record": {
              const json2 = _json;
              json2.type = "object";
              if (this.target === "draft-7" || this.target === "draft-2020-12") {
                json2.propertyNames = this.process(def.keyType, {
                  ...params,
                  path: [...params.path, "propertyNames"]
                });
              }
              json2.additionalProperties = this.process(def.valueType, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
              break;
            }
            case "map": {
              if (this.unrepresentable === "throw") {
                throw new Error("Map cannot be represented in JSON Schema");
              }
              break;
            }
            case "set": {
              if (this.unrepresentable === "throw") {
                throw new Error("Set cannot be represented in JSON Schema");
              }
              break;
            }
            case "enum": {
              const json2 = _json;
              const values = getEnumValues(def.entries);
              if (values.every((v) => typeof v === "number"))
                json2.type = "number";
              if (values.every((v) => typeof v === "string"))
                json2.type = "string";
              json2.enum = values;
              break;
            }
            case "literal": {
              const json2 = _json;
              const vals = [];
              for (const val of def.values) {
                if (val === void 0) {
                  if (this.unrepresentable === "throw") {
                    throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                  } else {
                  }
                } else if (typeof val === "bigint") {
                  if (this.unrepresentable === "throw") {
                    throw new Error("BigInt literals cannot be represented in JSON Schema");
                  } else {
                    vals.push(Number(val));
                  }
                } else {
                  vals.push(val);
                }
              }
              if (vals.length === 0) {
              } else if (vals.length === 1) {
                const val = vals[0];
                json2.type = val === null ? "null" : typeof val;
                if (this.target === "draft-4" || this.target === "openapi-3.0") {
                  json2.enum = [val];
                } else {
                  json2.const = val;
                }
              } else {
                if (vals.every((v) => typeof v === "number"))
                  json2.type = "number";
                if (vals.every((v) => typeof v === "string"))
                  json2.type = "string";
                if (vals.every((v) => typeof v === "boolean"))
                  json2.type = "string";
                if (vals.every((v) => v === null))
                  json2.type = "null";
                json2.enum = vals;
              }
              break;
            }
            case "file": {
              const json2 = _json;
              const file2 = {
                type: "string",
                format: "binary",
                contentEncoding: "binary"
              };
              const { minimum, maximum, mime } = schema._zod.bag;
              if (minimum !== void 0)
                file2.minLength = minimum;
              if (maximum !== void 0)
                file2.maxLength = maximum;
              if (mime) {
                if (mime.length === 1) {
                  file2.contentMediaType = mime[0];
                  Object.assign(json2, file2);
                } else {
                  json2.anyOf = mime.map((m) => {
                    const mFile = { ...file2, contentMediaType: m };
                    return mFile;
                  });
                }
              } else {
                Object.assign(json2, file2);
              }
              break;
            }
            case "transform": {
              if (this.unrepresentable === "throw") {
                throw new Error("Transforms cannot be represented in JSON Schema");
              }
              break;
            }
            case "nullable": {
              const inner = this.process(def.innerType, params);
              if (this.target === "openapi-3.0") {
                result.ref = def.innerType;
                _json.nullable = true;
              } else {
                _json.anyOf = [inner, { type: "null" }];
              }
              break;
            }
            case "nonoptional": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "success": {
              const json2 = _json;
              json2.type = "boolean";
              break;
            }
            case "default": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              _json.default = JSON.parse(JSON.stringify(def.defaultValue));
              break;
            }
            case "prefault": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              if (this.io === "input")
                _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
              break;
            }
            case "catch": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              let catchValue;
              try {
                catchValue = def.catchValue(void 0);
              } catch {
                throw new Error("Dynamic catch values are not supported in JSON Schema");
              }
              _json.default = catchValue;
              break;
            }
            case "nan": {
              if (this.unrepresentable === "throw") {
                throw new Error("NaN cannot be represented in JSON Schema");
              }
              break;
            }
            case "template_literal": {
              const json2 = _json;
              const pattern = schema._zod.pattern;
              if (!pattern)
                throw new Error("Pattern not found in template literal");
              json2.type = "string";
              json2.pattern = pattern.source;
              break;
            }
            case "pipe": {
              const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
              this.process(innerType, params);
              result.ref = innerType;
              break;
            }
            case "readonly": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              _json.readOnly = true;
              break;
            }
            case "promise": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "optional": {
              this.process(def.innerType, params);
              result.ref = def.innerType;
              break;
            }
            case "lazy": {
              const innerType = schema._zod.innerType;
              this.process(innerType, params);
              result.ref = innerType;
              break;
            }
            case "custom": {
              if (this.unrepresentable === "throw") {
                throw new Error("Custom types cannot be represented in JSON Schema");
              }
              break;
            }
            case "function": {
              if (this.unrepresentable === "throw") {
                throw new Error("Function types cannot be represented in JSON Schema");
              }
              break;
            }
            default: {
              def;
            }
          }
        }
      }
      const meta = this.metadataRegistry.get(schema);
      if (meta)
        Object.assign(result.schema, meta);
      if (this.io === "input" && isTransforming(schema)) {
        delete result.schema.examples;
        delete result.schema.default;
      }
      if (this.io === "input" && result.schema._prefault)
        (_a17 = result.schema).default ?? (_a17.default = result.schema._prefault);
      delete result.schema._prefault;
      const _result = this.seen.get(schema);
      return _result.schema;
    }
    emit(schema, _params) {
      const params = {
        cycles: _params?.cycles ?? "ref",
        reused: _params?.reused ?? "inline",
        // unrepresentable: _params?.unrepresentable ?? "throw",
        // uri: _params?.uri ?? ((id) => `${id}`),
        external: _params?.external ?? void 0
      };
      const root = this.seen.get(schema);
      if (!root)
        throw new Error("Unprocessed schema. This is a bug in Zod.");
      const makeURI = (entry) => {
        const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
        if (params.external) {
          const externalId = params.external.registry.get(entry[0])?.id;
          const uriGenerator = params.external.uri ?? ((id2) => id2);
          if (externalId) {
            return { ref: uriGenerator(externalId) };
          }
          const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
          entry[1].defId = id;
          return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
        }
        if (entry[1] === root) {
          return { ref: "#" };
        }
        const uriPrefix = `#`;
        const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
        const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
        return { defId, ref: defUriPrefix + defId };
      };
      const extractToDef = (entry) => {
        if (entry[1].schema.$ref) {
          return;
        }
        const seen = entry[1];
        const { ref, defId } = makeURI(entry);
        seen.def = { ...seen.schema };
        if (defId)
          seen.defId = defId;
        const schema2 = seen.schema;
        for (const key in schema2) {
          delete schema2[key];
        }
        schema2.$ref = ref;
      };
      if (params.cycles === "throw") {
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.cycle) {
            throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
          }
        }
      }
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (schema === entry[0]) {
          extractToDef(entry);
          continue;
        }
        if (params.external) {
          const ext = params.external.registry.get(entry[0])?.id;
          if (schema !== entry[0] && ext) {
            extractToDef(entry);
            continue;
          }
        }
        const id = this.metadataRegistry.get(entry[0])?.id;
        if (id) {
          extractToDef(entry);
          continue;
        }
        if (seen.cycle) {
          extractToDef(entry);
          continue;
        }
        if (seen.count > 1) {
          if (params.reused === "ref") {
            extractToDef(entry);
            continue;
          }
        }
      }
      const flattenRef = (zodSchema2, params2) => {
        const seen = this.seen.get(zodSchema2);
        const schema2 = seen.def ?? seen.schema;
        const _cached = { ...schema2 };
        if (seen.ref === null) {
          return;
        }
        const ref = seen.ref;
        seen.ref = null;
        if (ref) {
          flattenRef(ref, params2);
          const refSchema = this.seen.get(ref).schema;
          if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
            schema2.allOf = schema2.allOf ?? [];
            schema2.allOf.push(refSchema);
          } else {
            Object.assign(schema2, refSchema);
            Object.assign(schema2, _cached);
          }
        }
        if (!seen.isParent)
          this.override({
            zodSchema: zodSchema2,
            jsonSchema: schema2,
            path: seen.path ?? []
          });
      };
      for (const entry of [...this.seen.entries()].reverse()) {
        flattenRef(entry[0], { target: this.target });
      }
      const result = {};
      if (this.target === "draft-2020-12") {
        result.$schema = "https://json-schema.org/draft/2020-12/schema";
      } else if (this.target === "draft-7") {
        result.$schema = "http://json-schema.org/draft-07/schema#";
      } else if (this.target === "draft-4") {
        result.$schema = "http://json-schema.org/draft-04/schema#";
      } else if (this.target === "openapi-3.0") {
      } else {
        console.warn(`Invalid target: ${this.target}`);
      }
      if (params.external?.uri) {
        const id = params.external.registry.get(schema)?.id;
        if (!id)
          throw new Error("Schema is missing an `id` property");
        result.$id = params.external.uri(id);
      }
      Object.assign(result, root.def);
      const defs = params.external?.defs ?? {};
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.def && seen.defId) {
          defs[seen.defId] = seen.def;
        }
      }
      if (params.external) {
      } else {
        if (Object.keys(defs).length > 0) {
          if (this.target === "draft-2020-12") {
            result.$defs = defs;
          } else {
            result.definitions = defs;
          }
        }
      }
      try {
        return JSON.parse(JSON.stringify(result));
      } catch (_err) {
        throw new Error("Error converting schema to JSON.");
      }
    }
  };
  function toJSONSchema(input, _params) {
    if (input instanceof $ZodRegistry) {
      const gen2 = new JSONSchemaGenerator(_params);
      const defs = {};
      for (const entry of input._idmap.entries()) {
        const [_, schema] = entry;
        gen2.process(schema);
      }
      const schemas = {};
      const external = {
        registry: input,
        uri: _params?.uri,
        defs
      };
      for (const entry of input._idmap.entries()) {
        const [key, schema] = entry;
        schemas[key] = gen2.emit(schema, {
          ..._params,
          external
        });
      }
      if (Object.keys(defs).length > 0) {
        const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
        schemas.__shared = {
          [defsSegment]: defs
        };
      }
      return { schemas };
    }
    const gen = new JSONSchemaGenerator(_params);
    gen.process(input);
    return gen.emit(input, _params);
  }
  function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
    if (ctx.seen.has(_schema))
      return false;
    ctx.seen.add(_schema);
    const schema = _schema;
    const def = schema._zod.def;
    switch (def.type) {
      case "string":
      case "number":
      case "bigint":
      case "boolean":
      case "date":
      case "symbol":
      case "undefined":
      case "null":
      case "any":
      case "unknown":
      case "never":
      case "void":
      case "literal":
      case "enum":
      case "nan":
      case "file":
      case "template_literal":
        return false;
      case "array": {
        return isTransforming(def.element, ctx);
      }
      case "object": {
        for (const key in def.shape) {
          if (isTransforming(def.shape[key], ctx))
            return true;
        }
        return false;
      }
      case "union": {
        for (const option of def.options) {
          if (isTransforming(option, ctx))
            return true;
        }
        return false;
      }
      case "intersection": {
        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
      }
      case "tuple": {
        for (const item of def.items) {
          if (isTransforming(item, ctx))
            return true;
        }
        if (def.rest && isTransforming(def.rest, ctx))
          return true;
        return false;
      }
      case "record": {
        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
      }
      case "map": {
        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
      }
      case "set": {
        return isTransforming(def.valueType, ctx);
      }
      case "promise":
      case "optional":
      case "nonoptional":
      case "nullable":
      case "readonly":
        return isTransforming(def.innerType, ctx);
      case "lazy":
        return isTransforming(def.getter(), ctx);
      case "default": {
        return isTransforming(def.innerType, ctx);
      }
      case "prefault": {
        return isTransforming(def.innerType, ctx);
      }
      case "custom": {
        return false;
      }
      case "transform": {
        return true;
      }
      case "pipe": {
        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
      }
      case "success": {
        return false;
      }
      case "catch": {
        return false;
      }
      case "function": {
        return false;
      }
      default:
        def;
    }
    throw new Error(`Unknown schema type: ${def.type}`);
  }

  // node_modules/zod/v4/core/json-schema.js
  var json_schema_exports = {};

  // node_modules/zod/v4/classic/iso.js
  var iso_exports = {};
  __export(iso_exports, {
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    date: () => date2,
    datetime: () => datetime2,
    duration: () => duration2,
    time: () => time2
  });
  var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function datetime2(params) {
    return _isoDateTime(ZodISODateTime, params);
  }
  var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function date2(params) {
    return _isoDate(ZodISODate, params);
  }
  var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function time2(params) {
    return _isoTime(ZodISOTime, params);
  }
  var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function duration2(params) {
    return _isoDuration(ZodISODuration, params);
  }

  // node_modules/zod/v4/classic/errors.js
  var initializer2 = (inst, issues) => {
    $ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
      format: {
        value: (mapper) => formatError(inst, mapper)
        // enumerable: false,
      },
      flatten: {
        value: (mapper) => flattenError(inst, mapper)
        // enumerable: false,
      },
      addIssue: {
        value: (issue2) => {
          inst.issues.push(issue2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      addIssues: {
        value: (issues2) => {
          inst.issues.push(...issues2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      isEmpty: {
        get() {
          return inst.issues.length === 0;
        }
        // enumerable: false,
      }
    });
  };
  var ZodError = $constructor("ZodError", initializer2);
  var ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });

  // node_modules/zod/v4/classic/parse.js
  var parse2 = /* @__PURE__ */ _parse(ZodRealError);
  var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
  var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  var encode2 = /* @__PURE__ */ _encode(ZodRealError);
  var decode2 = /* @__PURE__ */ _decode(ZodRealError);
  var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

  // node_modules/zod/v4/classic/schemas.js
  var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks) => {
      return inst.clone(util_exports.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }));
    };
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta) => {
      reg.add(inst, meta);
      return inst;
    };
    inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse2(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check2, params) => inst.check(refine(check2, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(void 0).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
  });
  var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
  });
  var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date2(params));
    inst.time = (params) => inst.check(time2(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  function string2(params) {
    return _string(ZodString, params);
  }
  var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function email2(params) {
    return _email(ZodEmail, params);
  }
  var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function guid2(params) {
    return _guid(ZodGUID, params);
  }
  var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function uuid2(params) {
    return _uuid(ZodUUID, params);
  }
  function uuidv4(params) {
    return _uuidv4(ZodUUID, params);
  }
  function uuidv6(params) {
    return _uuidv6(ZodUUID, params);
  }
  function uuidv7(params) {
    return _uuidv7(ZodUUID, params);
  }
  var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function url(params) {
    return _url(ZodURL, params);
  }
  function httpUrl(params) {
    return _url(ZodURL, {
      protocol: /^https?$/,
      hostname: regexes_exports.domain,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function emoji2(params) {
    return _emoji2(ZodEmoji, params);
  }
  var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function nanoid2(params) {
    return _nanoid(ZodNanoID, params);
  }
  var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid3(params) {
    return _cuid(ZodCUID, params);
  }
  var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid22(params) {
    return _cuid2(ZodCUID2, params);
  }
  var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ulid2(params) {
    return _ulid(ZodULID, params);
  }
  var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function xid2(params) {
    return _xid(ZodXID, params);
  }
  var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ksuid2(params) {
    return _ksuid(ZodKSUID, params);
  }
  var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv42(params) {
    return _ipv4(ZodIPv4, params);
  }
  var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv62(params) {
    return _ipv6(ZodIPv6, params);
  }
  var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv42(params) {
    return _cidrv4(ZodCIDRv4, params);
  }
  var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv62(params) {
    return _cidrv6(ZodCIDRv6, params);
  }
  var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base642(params) {
    return _base64(ZodBase64, params);
  }
  var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base64url2(params) {
    return _base64url(ZodBase64URL, params);
  }
  var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function e1642(params) {
    return _e164(ZodE164, params);
  }
  var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function jwt(params) {
    return _jwt(ZodJWT, params);
  }
  var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function stringFormat(format, fnOrRegex, _params = {}) {
    return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
  }
  function hostname2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
  }
  function hex2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
  }
  function hash(alg, params) {
    const enc = params?.enc ?? "hex";
    const format = `${alg}_${enc}`;
    const regex = regexes_exports[format];
    if (!regex)
      throw new Error(`Unrecognized hash format: ${format}`);
    return _stringFormat(ZodCustomStringFormat, format, regex, params);
  }
  var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  function number2(params) {
    return _number(ZodNumber, params);
  }
  var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  });
  function int(params) {
    return _int(ZodNumberFormat, params);
  }
  function float32(params) {
    return _float32(ZodNumberFormat, params);
  }
  function float64(params) {
    return _float64(ZodNumberFormat, params);
  }
  function int32(params) {
    return _int32(ZodNumberFormat, params);
  }
  function uint32(params) {
    return _uint32(ZodNumberFormat, params);
  }
  var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
  });
  function boolean2(params) {
    return _boolean(ZodBoolean, params);
  }
  var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  function bigint2(params) {
    return _bigint(ZodBigInt, params);
  }
  var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
  function int64(params) {
    return _int64(ZodBigIntFormat, params);
  }
  function uint64(params) {
    return _uint64(ZodBigIntFormat, params);
  }
  var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
  });
  function symbol15(params) {
    return _symbol(ZodSymbol, params);
  }
  var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
  });
  function _undefined3(params) {
    return _undefined2(ZodUndefined, params);
  }
  var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType.init(inst, def);
  });
  function _null3(params) {
    return _null2(ZodNull, params);
  }
  var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
  });
  function any() {
    return _any(ZodAny);
  }
  var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
  });
  function unknown() {
    return _unknown(ZodUnknown);
  }
  var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
  });
  function never(params) {
    return _never(ZodNever, params);
  }
  var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType.init(inst, def);
  });
  function _void2(params) {
    return _void(ZodVoid, params);
  }
  var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  function date3(params) {
    return _date(ZodDate, params);
  }
  var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  function array(element, params) {
    return _array(ZodArray, element, params);
  }
  function keyof(schema) {
    const shape = schema._zod.def.shape;
    return _enum2(Object.keys(shape));
  }
  var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    util_exports.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
    inst.extend = (incoming) => {
      return util_exports.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return util_exports.safeExtend(inst, incoming);
    };
    inst.merge = (other) => util_exports.merge(inst, other);
    inst.pick = (mask) => util_exports.pick(inst, mask);
    inst.omit = (mask) => util_exports.omit(inst, mask);
    inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
  });
  function object(shape, params) {
    const def = {
      type: "object",
      shape: shape ?? {},
      ...util_exports.normalizeParams(params)
    };
    return new ZodObject(def);
  }
  function strictObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: never(),
      ...util_exports.normalizeParams(params)
    });
  }
  function looseObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: unknown(),
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst.options = def.options;
  });
  function union(options, params) {
    return new ZodUnion({
      type: "union",
      options,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  function discriminatedUnion(discriminator, options, params) {
    return new ZodDiscriminatedUnion({
      type: "union",
      options,
      discriminator,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
  });
  function intersection(left, right) {
    return new ZodIntersection({
      type: "intersection",
      left,
      right
    });
  }
  var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
      type: "tuple",
      items,
      rest,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  function record(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function partialRecord(keyType, valueType, params) {
    const k = clone(keyType);
    k._zod.values = void 0;
    return new ZodRecord({
      type: "record",
      keyType: k,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  function map(keyType, valueType, params) {
    return new ZodMap({
      type: "map",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  function set(valueType, params) {
    return new ZodSet({
      type: "set",
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  function _enum2(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  function nativeEnum(entries, params) {
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  function literal(value, params) {
    return new ZodLiteral({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  function file(params) {
    return _file(ZodFile, params);
  }
  var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(util_exports.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(util_exports.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  function transform(fn) {
    return new ZodTransform({
      type: "transform",
      transform: fn
    });
  }
  var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function optional(innerType) {
    return new ZodOptional({
      type: "optional",
      innerType
    });
  }
  var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nullable(innerType) {
    return new ZodNullable({
      type: "nullable",
      innerType
    });
  }
  function nullish2(innerType) {
    return optional(nullable(innerType));
  }
  var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  function _default2(innerType, defaultValue) {
    return new ZodDefault({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function prefault(innerType, defaultValue) {
    return new ZodPrefault({
      type: "prefault",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nonoptional(innerType, params) {
    return new ZodNonOptional({
      type: "nonoptional",
      innerType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function success(innerType) {
    return new ZodSuccess({
      type: "success",
      innerType
    });
  }
  var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  function _catch2(innerType, catchValue) {
    return new ZodCatch({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType.init(inst, def);
  });
  function nan(params) {
    return _nan(ZodNaN, params);
  }
  var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
  });
  function pipe(in_, out) {
    return new ZodPipe({
      type: "pipe",
      in: in_,
      out
      // ...util.normalizeParams(params),
    });
  }
  var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  function codec(in_, out, params) {
    return new ZodCodec({
      type: "pipe",
      in: in_,
      out,
      transform: params.decode,
      reverseTransform: params.encode
    });
  }
  var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function readonly(innerType) {
    return new ZodReadonly({
      type: "readonly",
      innerType
    });
  }
  var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
  });
  function templateLiteral(parts, params) {
    return new ZodTemplateLiteral({
      type: "template_literal",
      parts,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
  });
  function lazy(getter) {
    return new ZodLazy({
      type: "lazy",
      getter
    });
  }
  var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function promise(innerType) {
    return new ZodPromise({
      type: "promise",
      innerType
    });
  }
  var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType.init(inst, def);
  });
  function _function(params) {
    return new ZodFunction({
      type: "function",
      input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
      output: params?.output ?? unknown()
    });
  }
  var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
  });
  function check(fn) {
    const ch = new $ZodCheck({
      check: "custom"
      // ...util.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
  }
  function custom(fn, _params) {
    return _custom(ZodCustom, fn ?? (() => true), _params);
  }
  function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
  }
  function superRefine(fn) {
    return _superRefine(fn);
  }
  function _instanceof(cls, params = {
    error: `Input not instance of ${cls.name}`
  }) {
    const inst = new ZodCustom({
      type: "custom",
      check: "custom",
      fn: (data) => data instanceof cls,
      abort: true,
      ...util_exports.normalizeParams(params)
    });
    inst._zod.bag.Class = cls;
    return inst;
  }
  var stringbool = (...args) => _stringbool({
    Codec: ZodCodec,
    Boolean: ZodBoolean,
    String: ZodString
  }, ...args);
  function json(params) {
    const jsonSchema2 = lazy(() => {
      return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema2), record(string2(), jsonSchema2)]);
    });
    return jsonSchema2;
  }
  function preprocess(fn, schema) {
    return pipe(transform(fn), schema);
  }

  // node_modules/zod/v4/classic/compat.js
  var ZodIssueCode = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  function setErrorMap(map2) {
    config({
      customError: map2
    });
  }
  function getErrorMap() {
    return config().customError;
  }
  var ZodFirstPartyTypeKind;
  /* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

  // node_modules/zod/v4/classic/coerce.js
  var coerce_exports = {};
  __export(coerce_exports, {
    bigint: () => bigint3,
    boolean: () => boolean3,
    date: () => date4,
    number: () => number3,
    string: () => string3
  });
  function string3(params) {
    return _coercedString(ZodString, params);
  }
  function number3(params) {
    return _coercedNumber(ZodNumber, params);
  }
  function boolean3(params) {
    return _coercedBoolean(ZodBoolean, params);
  }
  function bigint3(params) {
    return _coercedBigint(ZodBigInt, params);
  }
  function date4(params) {
    return _coercedDate(ZodDate, params);
  }

  // node_modules/zod/v4/classic/external.js
  config(en_default());

  // node_modules/zod/v3/helpers/util.js
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs2(_arg) {
    }
    util2.assertIs = assertIs2;
    function assertNever2(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object3) => {
      const keys = [];
      for (const key in object3) {
        if (Object.prototype.hasOwnProperty.call(object3, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues2(array2, separator = " | ") {
      return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues2;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  // node_modules/zod/v3/ZodError.js
  var ZodIssueCode2 = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var ZodError2 = class _ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue2) {
        return issue2.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error46) => {
        for (const issue2 of error46.issues) {
          if (issue2.code === "invalid_union") {
            issue2.unionErrors.map(processError);
          } else if (issue2.code === "invalid_return_type") {
            processError(issue2.returnTypeError);
          } else if (issue2.code === "invalid_arguments") {
            processError(issue2.argumentsError);
          } else if (issue2.path.length === 0) {
            fieldErrors._errors.push(mapper(issue2));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue2.path.length) {
              const el = issue2.path[i];
              const terminal = i === issue2.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue2));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue2) => issue2.message) {
      const fieldErrors = /* @__PURE__ */ Object.create(null);
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError2.create = (issues) => {
    const error46 = new ZodError2(issues);
    return error46;
  };

  // node_modules/zod/v3/locales/en.js
  var errorMap = (issue2, _ctx) => {
    let message;
    switch (issue2.code) {
      case ZodIssueCode2.invalid_type:
        if (issue2.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue2.expected}, received ${issue2.received}`;
        }
        break;
      case ZodIssueCode2.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode2.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
        break;
      case ZodIssueCode2.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode2.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
        break;
      case ZodIssueCode2.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
        break;
      case ZodIssueCode2.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode2.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode2.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode2.invalid_string:
        if (typeof issue2.validation === "object") {
          if ("includes" in issue2.validation) {
            message = `Invalid input: must include "${issue2.validation.includes}"`;
            if (typeof issue2.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
            }
          } else if ("startsWith" in issue2.validation) {
            message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
          } else if ("endsWith" in issue2.validation) {
            message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
          } else {
            util.assertNever(issue2.validation);
          }
        } else if (issue2.validation !== "regex") {
          message = `Invalid ${issue2.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode2.too_small:
        if (issue2.type === "array")
          message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
        else if (issue2.type === "string")
          message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
        else if (issue2.type === "number")
          message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
        else if (issue2.type === "bigint")
          message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
        else if (issue2.type === "date")
          message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode2.too_big:
        if (issue2.type === "array")
          message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
        else if (issue2.type === "string")
          message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
        else if (issue2.type === "number")
          message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
        else if (issue2.type === "bigint")
          message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
        else if (issue2.type === "date")
          message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode2.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode2.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode2.not_multiple_of:
        message = `Number must be a multiple of ${issue2.multipleOf}`;
        break;
      case ZodIssueCode2.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue2);
    }
    return { message };
  };
  var en_default2 = errorMap;

  // node_modules/zod/v3/errors.js
  var overrideErrorMap = en_default2;
  function getErrorMap2() {
    return overrideErrorMap;
  }

  // node_modules/zod/v3/helpers/parseUtil.js
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap2();
    const issue2 = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default2 ? void 0 : en_default2
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue2);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

  // node_modules/zod/v3/helpers/errorUtil.js
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));

  // node_modules/zod/v3/types.js
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error46 = new ZodError2(ctx.common.issues);
          this._error = error46;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType2 = class {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType2(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType2(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType2(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType2(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType2(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check2, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check2(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode2.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check2, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check2(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional2.create(this, this._def);
    }
    nullable() {
      return ZodNullable2.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray2.create(this);
    }
    promise() {
      return ZodPromise2.create(this, this._def);
    }
    or(option) {
      return ZodUnion2.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection2.create(this, incoming, this._def);
    }
    transform(transform2) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect: { type: "transform", transform: transform2 }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault2({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind2.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch2({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind2.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly2.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT2(jwt2, alg) {
    if (!jwtRegex.test(jwt2))
      return false;
    try {
      const [header] = jwt2.split(".");
      if (!header)
        return false;
      const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base643));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString2 = class _ZodString2 extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check2 of this._def.checks) {
        if (check2.kind === "min") {
          if (input.data.length < check2.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "max") {
          if (input.data.length > check2.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "length") {
          const tooBig = input.data.length > check2.value;
          const tooSmall = input.data.length < check2.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check2.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check2.message
              });
            }
            status.dirty();
          }
        } else if (check2.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "regex") {
          check2.regex.lastIndex = 0;
          const testResult = check2.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "trim") {
          input.data = input.data.trim();
        } else if (check2.kind === "includes") {
          if (!input.data.includes(check2.value, check2.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: { includes: check2.value, position: check2.position },
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check2.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check2.kind === "startsWith") {
          if (!input.data.startsWith(check2.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: { startsWith: check2.value },
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "endsWith") {
          if (!input.data.endsWith(check2.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: { endsWith: check2.value },
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "datetime") {
          const regex = datetimeRegex(check2);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: "datetime",
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: "date",
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "time") {
          const regex = timeRegex(check2);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_string,
              validation: "time",
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "ip") {
          if (!isValidIP(input.data, check2.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "jwt") {
          if (!isValidJWT2(input.data, check2.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "cidr") {
          if (!isValidCidr(input.data, check2.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode2.invalid_string,
              message: check2.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check2);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode2.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check2) {
      return new _ZodString2({
        ...this._def,
        checks: [...this._def.checks, check2]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString2.create = (params) => {
    return new ZodString2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder2(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var ZodNumber2 = class _ZodNumber extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check2 of this._def.checks) {
        if (check2.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_type,
              expected: "integer",
              received: "float",
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "min") {
          const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "number",
              inclusive: check2.inclusive,
              exact: false,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "max") {
          const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "number",
              inclusive: check2.inclusive,
              exact: false,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "multipleOf") {
          if (floatSafeRemainder2(input.data, check2.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.not_multiple_of,
              multipleOf: check2.value,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.not_finite,
              message: check2.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check2);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check2) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check2]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber2.create = (params) => {
    return new ZodNumber2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt2 = class _ZodBigInt extends ZodType2 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check2 of this._def.checks) {
        if (check2.kind === "min") {
          const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              type: "bigint",
              minimum: check2.value,
              inclusive: check2.inclusive,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "max") {
          const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              type: "bigint",
              maximum: check2.value,
              inclusive: check2.inclusive,
              message: check2.message
            });
            status.dirty();
          }
        } else if (check2.kind === "multipleOf") {
          if (input.data % check2.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.not_multiple_of,
              multipleOf: check2.value,
              message: check2.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check2);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check2) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check2]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt2.create = (params) => {
    return new ZodBigInt2({
      checks: [],
      typeName: ZodFirstPartyTypeKind2.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean2 = class extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean2.create = (params) => {
    return new ZodBoolean2({
      typeName: ZodFirstPartyTypeKind2.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate2 = class _ZodDate extends ZodType2 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode2.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check2 of this._def.checks) {
        if (check2.kind === "min") {
          if (input.data.getTime() < check2.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              message: check2.message,
              inclusive: true,
              exact: false,
              minimum: check2.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check2.kind === "max") {
          if (input.data.getTime() > check2.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              message: check2.message,
              inclusive: true,
              exact: false,
              maximum: check2.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check2);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check2) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check2]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate2.create = (params) => {
    return new ZodDate2({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind2.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol2.create = (params) => {
    return new ZodSymbol2({
      typeName: ZodFirstPartyTypeKind2.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined2.create = (params) => {
    return new ZodUndefined2({
      typeName: ZodFirstPartyTypeKind2.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull2.create = (params) => {
    return new ZodNull2({
      typeName: ZodFirstPartyTypeKind2.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny2 = class extends ZodType2 {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny2.create = (params) => {
    return new ZodAny2({
      typeName: ZodFirstPartyTypeKind2.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown2 = class extends ZodType2 {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown2.create = (params) => {
    return new ZodUnknown2({
      typeName: ZodFirstPartyTypeKind2.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever2 = class extends ZodType2 {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever2.create = (params) => {
    return new ZodNever2({
      typeName: ZodFirstPartyTypeKind2.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid2.create = (params) => {
    return new ZodVoid2({
      typeName: ZodFirstPartyTypeKind2.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray2 = class _ZodArray extends ZodType2 {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray2.create = (schema, params) => {
    return new ZodArray2({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind2.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject2) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
      }
      return new ZodObject2({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray2) {
      return new ZodArray2({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional2) {
      return ZodOptional2.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable2) {
      return ZodNullable2.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple2) {
      return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject2 = class _ZodObject extends ZodType2 {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever2) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue2, ctx) => {
            const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
            if (issue2.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind2.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional2) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject2.create = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject2.strictCreate = (shape, params) => {
    return new ZodObject2({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject2.lazycreate = (shape, params) => {
    return new ZodObject2({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion2 = class extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError2(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion2.create = (types, params) => {
    return new ZodUnion2({
      options: types,
      typeName: ZodFirstPartyTypeKind2.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy2) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral2) {
      return [type.value];
    } else if (type instanceof ZodEnum2) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault2) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined2) {
      return [void 0];
    } else if (type instanceof ZodNull2) {
      return [null];
    } else if (type instanceof ZodOptional2) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable2) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly2) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch2) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues2(a, b) {
    const aType = getParsedType2(a);
    const bType = getParsedType2(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues2(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues2(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection2 = class extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues2(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection2.create = (left, right, params) => {
    return new ZodIntersection2({
      left,
      right,
      typeName: ZodFirstPartyTypeKind2.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple2 = class _ZodTuple extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple2.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple2({
      items: schemas,
      typeName: ZodFirstPartyTypeKind2.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord2 = class _ZodRecord extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType2) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString2.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap2 = class extends ZodType2 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap2.create = (keyType, valueType, params) => {
    return new ZodMap2({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind2.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet2 = class _ZodSet extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet2.create = (valueType, params) => {
    return new ZodSet2({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind2.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction2 = class _ZodFunction extends ZodType2 {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error46) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode2.invalid_arguments,
            argumentsError: error46
          }
        });
      }
      function makeReturnsIssue(returns, error46) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode2.invalid_return_type,
            returnTypeError: error46
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise2) {
        const me = this;
        return OK(async function(...args) {
          const error46 = new ZodError2([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error46.addIssue(makeArgsIssue(args, e));
            throw error46;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error46.addIssue(makeReturnsIssue(result, e));
            throw error46;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple2.create(items).rest(ZodUnknown2.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
        returns: returns || ZodUnknown2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy2 = class extends ZodType2 {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy2.create = (getter, params) => {
    return new ZodLazy2({
      getter,
      typeName: ZodFirstPartyTypeKind2.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral2 = class extends ZodType2 {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode2.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral2.create = (value, params) => {
    return new ZodLiteral2({
      value,
      typeName: ZodFirstPartyTypeKind2.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum2({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum2 = class _ZodEnum extends ZodType2 {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode2.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode2.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum2.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType2 {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode2.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode2.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise2 = class extends ZodType2 {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise2.create = (schema, params) => {
    return new ZodPromise2({
      type: schema,
      typeName: ZodFirstPartyTypeKind2.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType2 {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess2 },
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional2.create = (type, params) => {
    return new ZodOptional2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable2.create = (type, params) => {
    return new ZodNullable2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault2 = class extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault2.create = (type, params) => {
    return new ZodDefault2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch2 = class extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError2(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch2.create = (type, params) => {
    return new ZodCatch2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN2 = class extends ZodType2 {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN2.create = (params) => {
    return new ZodNaN2({
      typeName: ZodFirstPartyTypeKind2.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType2 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType2 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind2.ZodPipeline
      });
    }
  };
  var ZodReadonly2 = class extends ZodType2 {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly2.create = (type, params) => {
    return new ZodReadonly2({
      innerType: type,
      typeName: ZodFirstPartyTypeKind2.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var late = {
    object: ZodObject2.lazycreate
  };
  var ZodFirstPartyTypeKind2;
  (function(ZodFirstPartyTypeKind3) {
    ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
  var stringType = ZodString2.create;
  var numberType = ZodNumber2.create;
  var nanType = ZodNaN2.create;
  var bigIntType = ZodBigInt2.create;
  var booleanType = ZodBoolean2.create;
  var dateType = ZodDate2.create;
  var symbolType = ZodSymbol2.create;
  var undefinedType = ZodUndefined2.create;
  var nullType = ZodNull2.create;
  var anyType = ZodAny2.create;
  var unknownType = ZodUnknown2.create;
  var neverType = ZodNever2.create;
  var voidType = ZodVoid2.create;
  var arrayType = ZodArray2.create;
  var objectType = ZodObject2.create;
  var strictObjectType = ZodObject2.strictCreate;
  var unionType = ZodUnion2.create;
  var discriminatedUnionType = ZodDiscriminatedUnion2.create;
  var intersectionType = ZodIntersection2.create;
  var tupleType = ZodTuple2.create;
  var recordType = ZodRecord2.create;
  var mapType = ZodMap2.create;
  var setType = ZodSet2.create;
  var functionType = ZodFunction2.create;
  var lazyType = ZodLazy2.create;
  var literalType = ZodLiteral2.create;
  var enumType = ZodEnum2.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise2.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional2.create;
  var nullableType = ZodNullable2.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;

  // node_modules/@ai-sdk/provider-utils/dist/index.mjs
  function combineHeaders(...headers) {
    return headers.reduce(
      (combinedHeaders, currentHeaders) => ({
        ...combinedHeaders,
        ...currentHeaders != null ? currentHeaders : {}
      }),
      {}
    );
  }
  async function delay(delayInMs, options) {
    if (delayInMs == null) {
      return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve2, reject) => {
      if (signal == null ? void 0 : signal.aborted) {
        reject(createAbortError());
        return;
      }
      const timeoutId = setTimeout(() => {
        cleanup();
        resolve2();
      }, delayInMs);
      const cleanup = () => {
        clearTimeout(timeoutId);
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
      };
      const onAbort = () => {
        cleanup();
        reject(createAbortError());
      };
      signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
  }
  function createAbortError() {
    return new DOMException("Delay was aborted", "AbortError");
  }
  function extractResponseHeaders(response) {
    return Object.fromEntries([...response.headers]);
  }
  var createIdGenerator = ({
    prefix,
    size = 16,
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    separator = "-"
  } = {}) => {
    const generator = () => {
      const alphabetLength = alphabet.length;
      const chars = new Array(size);
      for (let i = 0; i < size; i++) {
        chars[i] = alphabet[Math.random() * alphabetLength | 0];
      }
      return chars.join("");
    };
    if (prefix == null) {
      return generator;
    }
    if (alphabet.includes(separator)) {
      throw new InvalidArgumentError({
        argument: "separator",
        message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
      });
    }
    return () => `${prefix}${separator}${generator()}`;
  };
  var generateId = createIdGenerator();
  function getErrorMessage2(error46) {
    if (error46 == null) {
      return "unknown error";
    }
    if (typeof error46 === "string") {
      return error46;
    }
    if (error46 instanceof Error) {
      return error46.message;
    }
    return JSON.stringify(error46);
  }
  function isAbortError(error46) {
    return (error46 instanceof Error || error46 instanceof DOMException) && (error46.name === "AbortError" || error46.name === "ResponseAborted" || // Next.js
    error46.name === "TimeoutError");
  }
  var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
  function handleFetchError({
    error: error46,
    url: url2,
    requestBodyValues
  }) {
    if (isAbortError(error46)) {
      return error46;
    }
    if (error46 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error46.message.toLowerCase())) {
      const cause = error46.cause;
      if (cause != null) {
        return new APICallError({
          message: `Cannot connect to API: ${cause.message}`,
          cause,
          url: url2,
          requestBodyValues,
          isRetryable: true
          // retry when network error
        });
      }
    }
    return error46;
  }
  function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
    var _a17, _b8, _c;
    if (globalThisAny.window) {
      return `runtime/browser`;
    }
    if ((_a17 = globalThisAny.navigator) == null ? void 0 : _a17.userAgent) {
      return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
    }
    if ((_c = (_b8 = globalThisAny.process) == null ? void 0 : _b8.versions) == null ? void 0 : _c.node) {
      return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
    }
    if (globalThisAny.EdgeRuntime) {
      return `runtime/vercel-edge`;
    }
    return "runtime/unknown";
  }
  function normalizeHeaders(headers) {
    if (headers == null) {
      return {};
    }
    const normalized = {};
    if (headers instanceof Headers) {
      headers.forEach((value, key) => {
        normalized[key.toLowerCase()] = value;
      });
    } else {
      if (!Array.isArray(headers)) {
        headers = Object.entries(headers);
      }
      for (const [key, value] of headers) {
        if (value != null) {
          normalized[key.toLowerCase()] = value;
        }
      }
    }
    return normalized;
  }
  function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
    const normalizedHeaders = new Headers(normalizeHeaders(headers));
    const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
    normalizedHeaders.set(
      "user-agent",
      [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
    );
    return Object.fromEntries(normalizedHeaders.entries());
  }
  var VERSION = true ? "3.0.17" : "0.0.0-test";
  var getOriginalFetch = () => globalThis.fetch;
  var getFromApi = async ({
    url: url2,
    headers = {},
    successfulResponseHandler,
    failedResponseHandler,
    abortSignal,
    fetch: fetch2 = getOriginalFetch()
  }) => {
    try {
      const response = await fetch2(url2, {
        method: "GET",
        headers: withUserAgentSuffix(
          headers,
          `ai-sdk/provider-utils/${VERSION}`,
          getRuntimeEnvironmentUserAgent()
        ),
        signal: abortSignal
      });
      const responseHeaders = extractResponseHeaders(response);
      if (!response.ok) {
        let errorInformation;
        try {
          errorInformation = await failedResponseHandler({
            response,
            url: url2,
            requestBodyValues: {}
          });
        } catch (error46) {
          if (isAbortError(error46) || APICallError.isInstance(error46)) {
            throw error46;
          }
          throw new APICallError({
            message: "Failed to process error response",
            cause: error46,
            statusCode: response.status,
            url: url2,
            responseHeaders,
            requestBodyValues: {}
          });
        }
        throw errorInformation.value;
      }
      try {
        return await successfulResponseHandler({
          response,
          url: url2,
          requestBodyValues: {}
        });
      } catch (error46) {
        if (error46 instanceof Error) {
          if (isAbortError(error46) || APICallError.isInstance(error46)) {
            throw error46;
          }
        }
        throw new APICallError({
          message: "Failed to process successful response",
          cause: error46,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: {}
        });
      }
    } catch (error46) {
      throw handleFetchError({ error: error46, url: url2, requestBodyValues: {} });
    }
  };
  function isUrlSupported({
    mediaType,
    url: url2,
    supportedUrls
  }) {
    url2 = url2.toLowerCase();
    mediaType = mediaType.toLowerCase();
    return Object.entries(supportedUrls).map(([key, value]) => {
      const mediaType2 = key.toLowerCase();
      return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
    }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url2));
  }
  function loadOptionalSetting({
    settingValue,
    environmentVariableName
  }) {
    if (typeof settingValue === "string") {
      return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
      return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
      return void 0;
    }
    return settingValue;
  }
  var suspectProtoRx = /"__proto__"\s*:/;
  var suspectConstructorRx = /"constructor"\s*:/;
  function _parse2(text2) {
    const obj = JSON.parse(text2);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
      return obj;
    }
    return filter(obj);
  }
  function filter(obj) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node of nodes) {
        if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        for (const key in node) {
          const value = node[key];
          if (value && typeof value === "object") {
            next.push(value);
          }
        }
      }
    }
    return obj;
  }
  function secureJsonParse(text2) {
    const { stackTraceLimit } = Error;
    try {
      Error.stackTraceLimit = 0;
    } catch (e) {
      return _parse2(text2);
    }
    try {
      return _parse2(text2);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  var validatorSymbol = Symbol.for("vercel.ai.validator");
  function validator(validate) {
    return { [validatorSymbol]: true, validate };
  }
  function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
  }
  function lazyValidator(createValidator) {
    let validator2;
    return () => {
      if (validator2 == null) {
        validator2 = createValidator();
      }
      return validator2;
    };
  }
  function asValidator(value) {
    return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
  }
  function standardSchemaValidator(standardSchema) {
    return validator(async (value) => {
      const result = await standardSchema["~standard"].validate(value);
      return result.issues == null ? { success: true, value: result.value } : {
        success: false,
        error: new TypeValidationError({
          value,
          cause: result.issues
        })
      };
    });
  }
  async function validateTypes({
    value,
    schema
  }) {
    const result = await safeValidateTypes({ value, schema });
    if (!result.success) {
      throw TypeValidationError.wrap({ value, cause: result.error });
    }
    return result.value;
  }
  async function safeValidateTypes({
    value,
    schema
  }) {
    const validator2 = asValidator(schema);
    try {
      if (validator2.validate == null) {
        return { success: true, value, rawValue: value };
      }
      const result = await validator2.validate(value);
      if (result.success) {
        return { success: true, value: result.value, rawValue: value };
      }
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: result.error }),
        rawValue: value
      };
    } catch (error46) {
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: error46 }),
        rawValue: value
      };
    }
  }
  async function parseJSON({
    text: text2,
    schema
  }) {
    try {
      const value = secureJsonParse(text2);
      if (schema == null) {
        return value;
      }
      return validateTypes({ value, schema });
    } catch (error46) {
      if (JSONParseError.isInstance(error46) || TypeValidationError.isInstance(error46)) {
        throw error46;
      }
      throw new JSONParseError({ text: text2, cause: error46 });
    }
  }
  async function safeParseJSON({
    text: text2,
    schema
  }) {
    try {
      const value = secureJsonParse(text2);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      return await safeValidateTypes({ value, schema });
    } catch (error46) {
      return {
        success: false,
        error: JSONParseError.isInstance(error46) ? error46 : new JSONParseError({ text: text2, cause: error46 }),
        rawValue: void 0
      };
    }
  }
  function parseJsonEventStream({
    stream,
    schema
  }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
      new TransformStream({
        async transform({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(await safeParseJSON({ text: data, schema }));
        }
      })
    );
  }
  var getOriginalFetch2 = () => globalThis.fetch;
  var postJsonToApi = async ({
    url: url2,
    headers,
    body,
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch2
  }) => postToApi({
    url: url2,
    headers: {
      "Content-Type": "application/json",
      ...headers
    },
    body: {
      content: JSON.stringify(body),
      values: body
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch2
  });
  var postToApi = async ({
    url: url2,
    headers = {},
    body,
    successfulResponseHandler,
    failedResponseHandler,
    abortSignal,
    fetch: fetch2 = getOriginalFetch2()
  }) => {
    try {
      const response = await fetch2(url2, {
        method: "POST",
        headers: withUserAgentSuffix(
          headers,
          `ai-sdk/provider-utils/${VERSION}`,
          getRuntimeEnvironmentUserAgent()
        ),
        body: body.content,
        signal: abortSignal
      });
      const responseHeaders = extractResponseHeaders(response);
      if (!response.ok) {
        let errorInformation;
        try {
          errorInformation = await failedResponseHandler({
            response,
            url: url2,
            requestBodyValues: body.values
          });
        } catch (error46) {
          if (isAbortError(error46) || APICallError.isInstance(error46)) {
            throw error46;
          }
          throw new APICallError({
            message: "Failed to process error response",
            cause: error46,
            statusCode: response.status,
            url: url2,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
        throw errorInformation.value;
      }
      try {
        return await successfulResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values
        });
      } catch (error46) {
        if (error46 instanceof Error) {
          if (isAbortError(error46) || APICallError.isInstance(error46)) {
            throw error46;
          }
        }
        throw new APICallError({
          message: "Failed to process successful response",
          cause: error46,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
    } catch (error46) {
      throw handleFetchError({ error: error46, url: url2, requestBodyValues: body.values });
    }
  };
  async function resolve(value) {
    if (typeof value === "function") {
      value = value();
    }
    return Promise.resolve(value);
  }
  var createJsonErrorResponseHandler = ({
    errorSchema,
    errorToMessage,
    isRetryable
  }) => async ({ response, url: url2, requestBodyValues }) => {
    const responseBody = await response.text();
    const responseHeaders = extractResponseHeaders(response);
    if (responseBody.trim() === "") {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
    try {
      const parsedError = await parseJSON({
        text: responseBody,
        schema: errorSchema
      });
      return {
        responseHeaders,
        value: new APICallError({
          message: errorToMessage(parsedError),
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          data: parsedError,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
        })
      };
    } catch (parseError) {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
  };
  var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
    const responseHeaders = extractResponseHeaders(response);
    if (response.body == null) {
      throw new EmptyResponseBodyError({});
    }
    return {
      responseHeaders,
      value: parseJsonEventStream({
        stream: response.body,
        schema: chunkSchema
      })
    };
  };
  var createJsonResponseHandler = (responseSchema) => async ({ response, url: url2, requestBodyValues }) => {
    const responseBody = await response.text();
    const parsedResult = await safeParseJSON({
      text: responseBody,
      schema: responseSchema
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!parsedResult.success) {
      throw new APICallError({
        message: "Invalid JSON response",
        cause: parsedResult.error,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        url: url2,
        requestBodyValues
      });
    }
    return {
      responseHeaders,
      value: parsedResult.value,
      rawValue: parsedResult.rawValue
    };
  };
  var getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
      if (pathA[i] !== pathB[i])
        break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
  };
  var ignoreOverride = Symbol(
    "Let zodToJsonSchema decide on which parser to use"
  );
  var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  var getDefaultOptions = (options) => typeof options === "string" ? {
    ...defaultOptions,
    name: options
  } : {
    ...defaultOptions,
    ...options
  };
  function parseAnyDef() {
    return {};
  }
  function parseArrayDef(def, refs) {
    var _a17, _b8, _c;
    const res = {
      type: "array"
    };
    if (((_a17 = def.type) == null ? void 0 : _a17._def) && ((_c = (_b8 = def.type) == null ? void 0 : _b8._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny) {
      res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
      res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
      res.minItems = def.exactLength.value;
      res.maxItems = def.exactLength.value;
    }
    return res;
  }
  function parseBigintDef(def) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          if (check2.inclusive) {
            res.minimum = check2.value;
          } else {
            res.exclusiveMinimum = check2.value;
          }
          break;
        case "max":
          if (check2.inclusive) {
            res.maximum = check2.value;
          } else {
            res.exclusiveMaximum = check2.value;
          }
          break;
        case "multipleOf":
          res.multipleOf = check2.value;
          break;
      }
    }
    return res;
  }
  function parseBooleanDef() {
    return { type: "boolean" };
  }
  function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
  }
  var parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser(def);
    }
  }
  var integerDateParser = (def) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          res.minimum = check2.value;
          break;
        case "max":
          res.maximum = check2.value;
          break;
      }
    }
    return res;
  };
  function parseDefaultDef(_def, refs) {
    return {
      ...parseDef(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
  }
  function parseEnumDef(def) {
    return {
      type: "string",
      enum: Array.from(def.values)
    };
  }
  var isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef(def, refs) {
    const allOf = [
      parseDef(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType(schema)) {
        mergedAllOf.push(...schema.allOf);
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
  }
  function parseLiteralDef(def) {
    const parsedType8 = typeof def.value;
    if (parsedType8 !== "bigint" && parsedType8 !== "number" && parsedType8 !== "boolean" && parsedType8 !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    return {
      type: parsedType8 === "bigint" ? "integer" : parsedType8,
      const: def.value
    };
  }
  var emojiRegex2 = void 0;
  var zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex2 === void 0) {
        emojiRegex2 = RegExp(
          "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
          "u"
        );
      }
      return emojiRegex2;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  function parseStringDef(def, refs) {
    const res = {
      type: "string"
    };
    if (def.checks) {
      for (const check2 of def.checks) {
        switch (check2.kind) {
          case "min":
            res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
            break;
          case "max":
            res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check2.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check2.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check2.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check2.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check2.message, refs);
            break;
          case "regex":
            addPattern(res, check2.regex, check2.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check2.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check2.message, refs);
            break;
          case "startsWith":
            addPattern(
              res,
              RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`),
              check2.message,
              refs
            );
            break;
          case "endsWith":
            addPattern(
              res,
              RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`),
              check2.message,
              refs
            );
            break;
          case "datetime":
            addFormat(res, "date-time", check2.message, refs);
            break;
          case "date":
            addFormat(res, "date", check2.message, refs);
            break;
          case "time":
            addFormat(res, "time", check2.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check2.message, refs);
            break;
          case "length":
            res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
            res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
            break;
          case "includes": {
            addPattern(
              res,
              RegExp(escapeLiteralCheckValue(check2.value, refs)),
              check2.message,
              refs
            );
            break;
          }
          case "ip": {
            if (check2.version !== "v6") {
              addFormat(res, "ipv4", check2.message, refs);
            }
            if (check2.version !== "v4") {
              addFormat(res, "ipv6", check2.message, refs);
            }
            break;
          }
          case "base64url":
            addPattern(res, zodPatterns.base64url, check2.message, refs);
            break;
          case "jwt":
            addPattern(res, zodPatterns.jwt, check2.message, refs);
            break;
          case "cidr": {
            if (check2.version !== "v6") {
              addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
            }
            if (check2.version !== "v4") {
              addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern(res, zodPatterns.emoji(), check2.message, refs);
            break;
          case "ulid": {
            addPattern(res, zodPatterns.ulid, check2.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat(res, "binary", check2.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                res.contentEncoding = "base64";
                break;
              }
              case "pattern:zod": {
                addPattern(res, zodPatterns.base64, check2.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern(res, zodPatterns.nanoid, check2.message, refs);
          }
          case "toLowerCase":
          case "toUpperCase":
          case "trim":
            break;
          default:
            /* @__PURE__ */ ((_) => {
            })(check2);
        }
      }
    }
    return res;
  }
  function escapeLiteralCheckValue(literal2, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
  }
  var ALPHA_NUMERIC = new Set(
    "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
  );
  function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
      if (!ALPHA_NUMERIC.has(source[i])) {
        result += "\\";
      }
      result += source[i];
    }
    return result;
  }
  function addFormat(schema, value, message, refs) {
    var _a17;
    if (schema.format || ((_a17 = schema.anyOf) == null ? void 0 : _a17.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format
        });
        delete schema.format;
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      schema.format = value;
    }
  }
  function addPattern(schema, regex, message, refs) {
    var _a17;
    if (schema.pattern || ((_a17 = schema.allOf) == null ? void 0 : _a17.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern
        });
        delete schema.pattern;
      }
      schema.allOf.push({
        pattern: stringifyRegExpWithFlags(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      schema.pattern = stringifyRegExpWithFlags(regex, refs);
    }
  }
  function stringifyRegExpWithFlags(regex, refs) {
    var _a17;
    if (!refs.applyRegexFlags || !regex.flags) {
      return regex.source;
    }
    const flags = {
      i: regex.flags.includes("i"),
      // Case-insensitive
      m: regex.flags.includes("m"),
      // `^` and `$` matches adjacent to newline characters
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
      if (isEscaped) {
        pattern += source[i];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source[i].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source[i];
              pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
              inCharRange = false;
            } else if (source[i + 1] === "-" && ((_a17 = source[i + 2]) == null ? void 0 : _a17.match(/[a-z]/))) {
              pattern += source[i];
              inCharRange = true;
            } else {
              pattern += `${source[i]}${source[i].toUpperCase()}`;
            }
            continue;
          }
        } else if (source[i].match(/[a-z]/)) {
          pattern += `[${source[i]}${source[i].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source[i] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source[i] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source[i] === ".") {
        pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
        continue;
      }
      pattern += source[i];
      if (source[i] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source[i] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source[i] === "[") {
        inCharGroup = true;
      }
    }
    try {
      new RegExp(pattern);
    } catch (e) {
      console.warn(
        `Could not convert regex pattern at ${refs.currentPath.join(
          "/"
        )} to a flag-independent form! Falling back to the flag-ignorant source`
      );
      return regex.source;
    }
    return pattern;
  }
  function parseRecordDef(def, refs) {
    var _a17, _b8, _c, _d, _e, _f;
    const schema = {
      type: "object",
      additionalProperties: (_a17 = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      })) != null ? _a17 : refs.allowedAdditionalProperties
    };
    if (((_b8 = def.keyType) == null ? void 0 : _b8._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
      const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
      const { type, ...keyType } = parseBrandedDef(
        def.keyType._def,
        refs
      );
      return {
        ...schema,
        propertyNames: keyType
      };
    }
    return schema;
  }
  function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || parseAnyDef();
    const values = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || parseAnyDef();
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef(def) {
    const object3 = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object3[object3[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object3[key]);
    const parsedTypes = Array.from(
      new Set(actualValues.map((values) => typeof values))
    );
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }
  function parseNeverDef() {
    return { not: parseAnyDef() };
  }
  function parseNullDef() {
    return {
      type: "null"
    };
  }
  var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every(
      (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
    )) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce(
        (acc, x) => {
          const type = typeof x._def.value;
          switch (type) {
            case "string":
            case "number":
            case "boolean":
              return [...acc, type];
            case "bigint":
              return [...acc, "integer"];
            case "object":
              if (x._def.value === null)
                return [...acc, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return acc;
          }
        },
        []
      );
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce(
            (acc, x) => {
              return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
            },
            []
          )
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce(
          (acc, x) => [
            ...acc,
            ...x._def.values.filter((x2) => !acc.includes(x2))
          ],
          []
        )
      };
    }
    return asAnyOf(def, refs);
  }
  var asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
      (x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`]
      })
    ).filter(
      (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
    );
    return anyOf.length ? { anyOf } : void 0;
  };
  function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      def.innerType._def.typeName
    ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      return {
        type: [
          primitiveMappings[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    const base = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }
  function parseNumberDef(def) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "int":
          res.type = "integer";
          break;
        case "min":
          if (check2.inclusive) {
            res.minimum = check2.value;
          } else {
            res.exclusiveMinimum = check2.value;
          }
          break;
        case "max":
          if (check2.inclusive) {
            res.maximum = check2.value;
          } else {
            res.exclusiveMaximum = check2.value;
          }
          break;
        case "multipleOf":
          res.multipleOf = check2.value;
          break;
      }
    }
    return res;
  }
  function parseObjectDef(def, refs) {
    const result = {
      type: "object",
      properties: {}
    };
    const required2 = [];
    const shape = def.shape();
    for (const propName in shape) {
      let propDef = shape[propName];
      if (propDef === void 0 || propDef._def === void 0) {
        continue;
      }
      const propOptional = safeIsOptional(propDef);
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0) {
        continue;
      }
      result.properties[propName] = parsedDef;
      if (!propOptional) {
        required2.push(propName);
      }
    }
    if (required2.length) {
      result.required = required2;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
      result.additionalProperties = additionalProperties;
    }
    return result;
  }
  function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
      return parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
    }
    switch (def.unknownKeys) {
      case "passthrough":
        return refs.allowedAdditionalProperties;
      case "strict":
        return refs.rejectedAdditionalProperties;
      case "strip":
        return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
  }
  function safeIsOptional(schema) {
    try {
      return schema.isOptional();
    } catch (e) {
      return true;
    }
  }
  var parseOptionalDef = (def, refs) => {
    var _a17;
    if (refs.currentPath.toString() === ((_a17 = refs.propertyPath) == null ? void 0 : _a17.toString())) {
      return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
  };
  var parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };
  function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
  }
  function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
      schema.maxItems = def.maxSize.value;
    }
    return schema;
  }
  function parseTupleDef(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map(
          (x, i) => parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i}`]
          })
        ).reduce(
          (acc, x) => x === void 0 ? acc : [...acc, x],
          []
        ),
        additionalItems: parseDef(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map(
          (x, i) => parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i}`]
          })
        ).reduce(
          (acc, x) => x === void 0 ? acc : [...acc, x],
          []
        )
      };
    }
  }
  function parseUndefinedDef() {
    return {
      not: parseAnyDef()
    };
  }
  function parseUnknownDef() {
    return parseAnyDef();
  }
  var parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  var selectParser = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind2.ZodString:
        return parseStringDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodNumber:
        return parseNumberDef(def);
      case ZodFirstPartyTypeKind2.ZodObject:
        return parseObjectDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodBigInt:
        return parseBigintDef(def);
      case ZodFirstPartyTypeKind2.ZodBoolean:
        return parseBooleanDef();
      case ZodFirstPartyTypeKind2.ZodDate:
        return parseDateDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodUndefined:
        return parseUndefinedDef();
      case ZodFirstPartyTypeKind2.ZodNull:
        return parseNullDef();
      case ZodFirstPartyTypeKind2.ZodArray:
        return parseArrayDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodUnion:
      case ZodFirstPartyTypeKind2.ZodDiscriminatedUnion:
        return parseUnionDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodIntersection:
        return parseIntersectionDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodTuple:
        return parseTupleDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodRecord:
        return parseRecordDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodLiteral:
        return parseLiteralDef(def);
      case ZodFirstPartyTypeKind2.ZodEnum:
        return parseEnumDef(def);
      case ZodFirstPartyTypeKind2.ZodNativeEnum:
        return parseNativeEnumDef(def);
      case ZodFirstPartyTypeKind2.ZodNullable:
        return parseNullableDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodOptional:
        return parseOptionalDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodMap:
        return parseMapDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodSet:
        return parseSetDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodLazy:
        return () => def.getter()._def;
      case ZodFirstPartyTypeKind2.ZodPromise:
        return parsePromiseDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodNaN:
      case ZodFirstPartyTypeKind2.ZodNever:
        return parseNeverDef();
      case ZodFirstPartyTypeKind2.ZodEffects:
        return parseEffectsDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodAny:
        return parseAnyDef();
      case ZodFirstPartyTypeKind2.ZodUnknown:
        return parseUnknownDef();
      case ZodFirstPartyTypeKind2.ZodDefault:
        return parseDefaultDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodBranded:
        return parseBrandedDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodReadonly:
        return parseReadonlyDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodCatch:
        return parseCatchDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodPipeline:
        return parsePipelineDef(def, refs);
      case ZodFirstPartyTypeKind2.ZodFunction:
      case ZodFirstPartyTypeKind2.ZodVoid:
      case ZodFirstPartyTypeKind2.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)(typeName);
    }
  };
  function parseDef(def, refs, forceResolution = false) {
    var _a17;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a17 = refs.override) == null ? void 0 : _a17.call(
        refs,
        def,
        refs,
        seenItem,
        forceResolution
      );
      if (overrideResult !== ignoreOverride) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
      addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
      const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
      newItem.jsonSchema = jsonSchema2;
      return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
  }
  var get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      case "relative":
        return { $ref: getRelativePath(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(
            `Recursive reference detected at ${refs.currentPath.join(
              "/"
            )}! Defaulting to any`
          );
          return parseAnyDef();
        }
        return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
      }
    }
  };
  var addMeta = (def, refs, jsonSchema2) => {
    if (def.description) {
      jsonSchema2.description = def.description;
    }
    return jsonSchema2;
  };
  var getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(
        Object.entries(_options.definitions).map(([name16, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name16],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ])
      )
    };
  };
  var zodToJsonSchema = (schema, options) => {
    var _a17;
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
      (acc, [name24, schema2]) => {
        var _a24;
        return {
          ...acc,
          [name24]: (_a24 = parseDef(
            schema2._def,
            {
              ...refs,
              currentPath: [...refs.basePath, refs.definitionPath, name24]
            },
            true
          )) != null ? _a24 : parseAnyDef()
        };
      },
      {}
    ) : void 0;
    const name16 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a17 = parseDef(
      schema._def,
      name16 === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name16]
      },
      false
    )) != null ? _a17 : parseAnyDef();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const combined = name16 === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name16
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name16]: main
      }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
  };
  var zod_to_json_schema_default = zodToJsonSchema;
  function zod3Schema(zodSchema2, options) {
    var _a17;
    const useReferences = (_a17 = options == null ? void 0 : options.useReferences) != null ? _a17 : false;
    return jsonSchema(
      // defer json schema creation to avoid unnecessary computation when only validation is needed
      () => zod_to_json_schema_default(zodSchema2, {
        $refStrategy: useReferences ? "root" : "none"
      }),
      {
        validate: async (value) => {
          const result = await zodSchema2.safeParseAsync(value);
          return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
        }
      }
    );
  }
  function zod4Schema(zodSchema2, options) {
    var _a17;
    const useReferences = (_a17 = options == null ? void 0 : options.useReferences) != null ? _a17 : false;
    return jsonSchema(
      // defer json schema creation to avoid unnecessary computation when only validation is needed
      () => toJSONSchema(zodSchema2, {
        target: "draft-7",
        io: "output",
        reused: useReferences ? "ref" : "inline"
      }),
      {
        validate: async (value) => {
          const result = await safeParseAsync2(zodSchema2, value);
          return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
        }
      }
    );
  }
  function isZod4Schema(zodSchema2) {
    return "_zod" in zodSchema2;
  }
  function zodSchema(zodSchema2, options) {
    if (isZod4Schema(zodSchema2)) {
      return zod4Schema(zodSchema2, options);
    } else {
      return zod3Schema(zodSchema2, options);
    }
  }
  var schemaSymbol = Symbol.for("vercel.ai.schema");
  function jsonSchema(jsonSchema2, {
    validate
  } = {}) {
    return {
      [schemaSymbol]: true,
      _type: void 0,
      // should never be used directly
      [validatorSymbol]: true,
      get jsonSchema() {
        if (typeof jsonSchema2 === "function") {
          jsonSchema2 = jsonSchema2();
        }
        return jsonSchema2;
      },
      validate
    };
  }
  function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
  }
  function asSchema(schema) {
    return schema == null ? jsonSchema({
      properties: {},
      additionalProperties: false
    }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);
  }
  var { btoa: btoa2, atob: atob2 } = globalThis;
  function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob2(base64Url);
    return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
  }
  function convertUint8ArrayToBase64(array2) {
    let latin1string = "";
    for (let i = 0; i < array2.length; i++) {
      latin1string += String.fromCodePoint(array2[i]);
    }
    return btoa2(latin1string);
  }
  function withoutTrailingSlash(url2) {
    return url2 == null ? void 0 : url2.replace(/\/$/, "");
  }
  function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] === "function";
  }
  async function* executeTool({
    execute,
    input,
    options
  }) {
    const result = execute(input, options);
    if (isAsyncIterable(result)) {
      let lastOutput;
      for await (const output of result) {
        lastOutput = output;
        yield { type: "preliminary", output };
      }
      yield { type: "final", output: lastOutput };
    } else {
      yield { type: "final", output: await result };
    }
  }

  // node_modules/@ai-sdk/gateway/dist/index.mjs
  var import_oidc = __toESM(require_index_browser(), 1);
  var import_oidc2 = __toESM(require_index_browser(), 1);
  var marker15 = "vercel.ai.gateway.error";
  var symbol16 = Symbol.for(marker15);
  var _a15;
  var _b;
  var GatewayError = class _GatewayError extends (_b = Error, _a15 = symbol16, _b) {
    constructor({
      message,
      statusCode = 500,
      cause
    }) {
      super(message);
      this[_a15] = true;
      this.statusCode = statusCode;
      this.cause = cause;
    }
    /**
     * Checks if the given error is a Gateway Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is a Gateway Error, false otherwise.
     */
    static isInstance(error46) {
      return _GatewayError.hasMarker(error46);
    }
    static hasMarker(error46) {
      return typeof error46 === "object" && error46 !== null && symbol16 in error46 && error46[symbol16] === true;
    }
  };
  var name14 = "GatewayAuthenticationError";
  var marker22 = `vercel.ai.gateway.error.${name14}`;
  var symbol22 = Symbol.for(marker22);
  var _a22;
  var _b2;
  var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a22 = symbol22, _b2) {
    constructor({
      message = "Authentication failed",
      statusCode = 401,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a22] = true;
      this.name = name14;
      this.type = "authentication_error";
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol22 in error46;
    }
    /**
     * Creates a contextual error message when authentication fails
     */
    static createContextualError({
      apiKeyProvided,
      oidcTokenProvided,
      message = "Authentication failed",
      statusCode = 401,
      cause
    }) {
      let contextualMessage;
      if (apiKeyProvided) {
        contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
      } else if (oidcTokenProvided) {
        contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
      } else {
        contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
      }
      return new _GatewayAuthenticationError({
        message: contextualMessage,
        statusCode,
        cause
      });
    }
  };
  var name22 = "GatewayInvalidRequestError";
  var marker32 = `vercel.ai.gateway.error.${name22}`;
  var symbol32 = Symbol.for(marker32);
  var _a32;
  var _b3;
  var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a32 = symbol32, _b3) {
    constructor({
      message = "Invalid request",
      statusCode = 400,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a32] = true;
      this.name = name22;
      this.type = "invalid_request_error";
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol32 in error46;
    }
  };
  var name32 = "GatewayRateLimitError";
  var marker42 = `vercel.ai.gateway.error.${name32}`;
  var symbol42 = Symbol.for(marker42);
  var _a42;
  var _b4;
  var GatewayRateLimitError = class extends (_b4 = GatewayError, _a42 = symbol42, _b4) {
    constructor({
      message = "Rate limit exceeded",
      statusCode = 429,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a42] = true;
      this.name = name32;
      this.type = "rate_limit_exceeded";
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol42 in error46;
    }
  };
  var name42 = "GatewayModelNotFoundError";
  var marker52 = `vercel.ai.gateway.error.${name42}`;
  var symbol52 = Symbol.for(marker52);
  var modelNotFoundParamSchema = lazyValidator(
    () => zodSchema(
      external_exports.object({
        modelId: external_exports.string()
      })
    )
  );
  var _a52;
  var _b5;
  var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a52 = symbol52, _b5) {
    constructor({
      message = "Model not found",
      statusCode = 404,
      modelId,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a52] = true;
      this.name = name42;
      this.type = "model_not_found";
      this.modelId = modelId;
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol52 in error46;
    }
  };
  var name52 = "GatewayInternalServerError";
  var marker62 = `vercel.ai.gateway.error.${name52}`;
  var symbol62 = Symbol.for(marker62);
  var _a62;
  var _b6;
  var GatewayInternalServerError = class extends (_b6 = GatewayError, _a62 = symbol62, _b6) {
    constructor({
      message = "Internal server error",
      statusCode = 500,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a62] = true;
      this.name = name52;
      this.type = "internal_server_error";
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol62 in error46;
    }
  };
  var name62 = "GatewayResponseError";
  var marker72 = `vercel.ai.gateway.error.${name62}`;
  var symbol72 = Symbol.for(marker72);
  var _a72;
  var _b7;
  var GatewayResponseError = class extends (_b7 = GatewayError, _a72 = symbol72, _b7) {
    constructor({
      message = "Invalid response from Gateway",
      statusCode = 502,
      response,
      validationError,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a72] = true;
      this.name = name62;
      this.type = "response_error";
      this.response = response;
      this.validationError = validationError;
    }
    static isInstance(error46) {
      return GatewayError.hasMarker(error46) && symbol72 in error46;
    }
  };
  async function createGatewayErrorFromResponse({
    response,
    statusCode,
    defaultMessage = "Gateway request failed",
    cause,
    authMethod
  }) {
    const parseResult = await safeValidateTypes({
      value: response,
      schema: gatewayErrorResponseSchema
    });
    if (!parseResult.success) {
      return new GatewayResponseError({
        message: `Invalid error response format: ${defaultMessage}`,
        statusCode,
        response,
        validationError: parseResult.error,
        cause
      });
    }
    const validatedResponse = parseResult.value;
    const errorType = validatedResponse.error.type;
    const message = validatedResponse.error.message;
    switch (errorType) {
      case "authentication_error":
        return GatewayAuthenticationError.createContextualError({
          apiKeyProvided: authMethod === "api-key",
          oidcTokenProvided: authMethod === "oidc",
          statusCode,
          cause
        });
      case "invalid_request_error":
        return new GatewayInvalidRequestError({ message, statusCode, cause });
      case "rate_limit_exceeded":
        return new GatewayRateLimitError({ message, statusCode, cause });
      case "model_not_found": {
        const modelResult = await safeValidateTypes({
          value: validatedResponse.error.param,
          schema: modelNotFoundParamSchema
        });
        return new GatewayModelNotFoundError({
          message,
          statusCode,
          modelId: modelResult.success ? modelResult.value.modelId : void 0,
          cause
        });
      }
      case "internal_server_error":
        return new GatewayInternalServerError({ message, statusCode, cause });
      default:
        return new GatewayInternalServerError({ message, statusCode, cause });
    }
  }
  var gatewayErrorResponseSchema = lazyValidator(
    () => zodSchema(
      external_exports.object({
        error: external_exports.object({
          message: external_exports.string(),
          type: external_exports.string().nullish(),
          param: external_exports.unknown().nullish(),
          code: external_exports.union([external_exports.string(), external_exports.number()]).nullish()
        })
      })
    )
  );
  function asGatewayError(error46, authMethod) {
    var _a83;
    if (GatewayError.isInstance(error46)) {
      return error46;
    }
    if (APICallError.isInstance(error46)) {
      return createGatewayErrorFromResponse({
        response: extractApiCallResponse(error46),
        statusCode: (_a83 = error46.statusCode) != null ? _a83 : 500,
        defaultMessage: "Gateway request failed",
        cause: error46,
        authMethod
      });
    }
    return createGatewayErrorFromResponse({
      response: {},
      statusCode: 500,
      defaultMessage: error46 instanceof Error ? `Gateway request failed: ${error46.message}` : "Unknown Gateway error",
      cause: error46,
      authMethod
    });
  }
  function extractApiCallResponse(error46) {
    if (error46.data !== void 0) {
      return error46.data;
    }
    if (error46.responseBody != null) {
      try {
        return JSON.parse(error46.responseBody);
      } catch (e) {
        return error46.responseBody;
      }
    }
    return {};
  }
  var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
  async function parseAuthMethod(headers) {
    const result = await safeValidateTypes({
      value: headers[GATEWAY_AUTH_METHOD_HEADER],
      schema: gatewayAuthMethodSchema
    });
    return result.success ? result.value : void 0;
  }
  var gatewayAuthMethodSchema = lazyValidator(
    () => zodSchema(external_exports.union([external_exports.literal("api-key"), external_exports.literal("oidc")]))
  );
  var GatewayFetchMetadata = class {
    constructor(config2) {
      this.config = config2;
    }
    async getAvailableModels() {
      try {
        const { value } = await getFromApi({
          url: `${this.config.baseURL}/config`,
          headers: await resolve(this.config.headers()),
          successfulResponseHandler: createJsonResponseHandler(
            gatewayAvailableModelsResponseSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          fetch: this.config.fetch
        });
        return value;
      } catch (error46) {
        throw await asGatewayError(error46);
      }
    }
    async getCredits() {
      try {
        const baseUrl = new URL(this.config.baseURL);
        const { value } = await getFromApi({
          url: `${baseUrl.origin}/v1/credits`,
          headers: await resolve(this.config.headers()),
          successfulResponseHandler: createJsonResponseHandler(
            gatewayCreditsResponseSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          fetch: this.config.fetch
        });
        return value;
      } catch (error46) {
        throw await asGatewayError(error46);
      }
    }
  };
  var gatewayAvailableModelsResponseSchema = lazyValidator(
    () => zodSchema(
      external_exports.object({
        models: external_exports.array(
          external_exports.object({
            id: external_exports.string(),
            name: external_exports.string(),
            description: external_exports.string().nullish(),
            pricing: external_exports.object({
              input: external_exports.string(),
              output: external_exports.string(),
              input_cache_read: external_exports.string().nullish(),
              input_cache_write: external_exports.string().nullish()
            }).transform(
              ({ input, output, input_cache_read, input_cache_write }) => ({
                input,
                output,
                ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
                ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
              })
            ).nullish(),
            specification: external_exports.object({
              specificationVersion: external_exports.literal("v2"),
              provider: external_exports.string(),
              modelId: external_exports.string()
            }),
            modelType: external_exports.enum(["language", "embedding", "image"]).nullish()
          })
        )
      })
    )
  );
  var gatewayCreditsResponseSchema = lazyValidator(
    () => zodSchema(
      external_exports.object({
        balance: external_exports.string(),
        total_used: external_exports.string()
      }).transform(({ balance, total_used }) => ({
        balance,
        totalUsed: total_used
      }))
    )
  );
  var GatewayLanguageModel = class {
    constructor(modelId, config2) {
      this.modelId = modelId;
      this.config = config2;
      this.specificationVersion = "v2";
      this.supportedUrls = { "*/*": [/.*/] };
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs(options) {
      const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
      return {
        args: this.maybeEncodeFileParts(optionsWithoutSignal),
        warnings: []
      };
    }
    async doGenerate(options) {
      const { args, warnings } = await this.getArgs(options);
      const { abortSignal } = options;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const {
          responseHeaders,
          value: responseBody,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.getUrl(),
          headers: combineHeaders(
            resolvedHeaders,
            options.headers,
            this.getModelConfigHeaders(this.modelId, false),
            await resolve(this.config.o11yHeaders)
          ),
          body: args,
          successfulResponseHandler: createJsonResponseHandler(external_exports.any()),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          ...responseBody,
          request: { body: args },
          response: { headers: responseHeaders, body: rawResponse },
          warnings
        };
      } catch (error46) {
        throw await asGatewayError(error46, await parseAuthMethod(resolvedHeaders));
      }
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const { abortSignal } = options;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const { value: response, responseHeaders } = await postJsonToApi({
          url: this.getUrl(),
          headers: combineHeaders(
            resolvedHeaders,
            options.headers,
            this.getModelConfigHeaders(this.modelId, true),
            await resolve(this.config.o11yHeaders)
          ),
          body: args,
          successfulResponseHandler: createEventSourceResponseHandler(external_exports.any()),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                if (warnings.length > 0) {
                  controller.enqueue({ type: "stream-start", warnings });
                }
              },
              transform(chunk, controller) {
                if (chunk.success) {
                  const streamPart = chunk.value;
                  if (streamPart.type === "raw" && !options.includeRawChunks) {
                    return;
                  }
                  if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                    streamPart.timestamp = new Date(streamPart.timestamp);
                  }
                  controller.enqueue(streamPart);
                } else {
                  controller.error(
                    chunk.error
                  );
                }
              }
            })
          ),
          request: { body: args },
          response: { headers: responseHeaders }
        };
      } catch (error46) {
        throw await asGatewayError(error46, await parseAuthMethod(resolvedHeaders));
      }
    }
    isFilePart(part) {
      return part && typeof part === "object" && "type" in part && part.type === "file";
    }
    /**
     * Encodes file parts in the prompt to base64. Mutates the passed options
     * instance directly to avoid copying the file data.
     * @param options - The options to encode.
     * @returns The options with the file parts encoded.
     */
    maybeEncodeFileParts(options) {
      for (const message of options.prompt) {
        for (const part of message.content) {
          if (this.isFilePart(part)) {
            const filePart = part;
            if (filePart.data instanceof Uint8Array) {
              const buffer = Uint8Array.from(filePart.data);
              const base64Data = Buffer.from(buffer).toString("base64");
              filePart.data = new URL(
                `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
              );
            }
          }
        }
      }
      return options;
    }
    getUrl() {
      return `${this.config.baseURL}/language-model`;
    }
    getModelConfigHeaders(modelId, streaming) {
      return {
        "ai-language-model-specification-version": "2",
        "ai-language-model-id": modelId,
        "ai-language-model-streaming": String(streaming)
      };
    }
  };
  var GatewayEmbeddingModel = class {
    constructor(modelId, config2) {
      this.modelId = modelId;
      this.config = config2;
      this.specificationVersion = "v2";
      this.maxEmbeddingsPerCall = 2048;
      this.supportsParallelCalls = true;
    }
    get provider() {
      return this.config.provider;
    }
    async doEmbed({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a83;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const {
          responseHeaders,
          value: responseBody,
          rawValue
        } = await postJsonToApi({
          url: this.getUrl(),
          headers: combineHeaders(
            resolvedHeaders,
            headers != null ? headers : {},
            this.getModelConfigHeaders(),
            await resolve(this.config.o11yHeaders)
          ),
          body: {
            input: values.length === 1 ? values[0] : values,
            ...providerOptions ? { providerOptions } : {}
          },
          successfulResponseHandler: createJsonResponseHandler(
            gatewayEmbeddingResponseSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          embeddings: responseBody.embeddings,
          usage: (_a83 = responseBody.usage) != null ? _a83 : void 0,
          providerMetadata: responseBody.providerMetadata,
          response: { headers: responseHeaders, body: rawValue }
        };
      } catch (error46) {
        throw await asGatewayError(error46, await parseAuthMethod(resolvedHeaders));
      }
    }
    getUrl() {
      return `${this.config.baseURL}/embedding-model`;
    }
    getModelConfigHeaders() {
      return {
        "ai-embedding-model-specification-version": "2",
        "ai-model-id": this.modelId
      };
    }
  };
  var gatewayEmbeddingResponseSchema = lazyValidator(
    () => zodSchema(
      external_exports.object({
        embeddings: external_exports.array(external_exports.array(external_exports.number())),
        usage: external_exports.object({ tokens: external_exports.number() }).nullish(),
        providerMetadata: external_exports.record(external_exports.string(), external_exports.record(external_exports.string(), external_exports.unknown())).optional()
      })
    )
  );
  var GatewayImageModel = class {
    constructor(modelId, config2) {
      this.modelId = modelId;
      this.config = config2;
      this.specificationVersion = "v2";
      this.maxImagesPerCall = 4;
    }
    get provider() {
      return this.config.provider;
    }
    async doGenerate({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a83;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const {
          responseHeaders,
          value: responseBody,
          rawValue
        } = await postJsonToApi({
          url: this.getUrl(),
          headers: combineHeaders(
            resolvedHeaders,
            headers != null ? headers : {},
            this.getModelConfigHeaders(),
            await resolve(this.config.o11yHeaders)
          ),
          body: {
            prompt,
            n,
            ...size && { size },
            ...aspectRatio && { aspectRatio },
            ...seed && { seed },
            ...providerOptions != null ? providerOptions : {}
          },
          successfulResponseHandler: createJsonResponseHandler(
            gatewayImageResponseSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: external_exports.any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          images: responseBody.images,
          // Always base64 strings from server
          warnings: (_a83 = responseBody.warnings) != null ? _a83 : [],
          providerMetadata: responseBody.providerMetadata,
          response: {
            timestamp: /* @__PURE__ */ new Date(),
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      } catch (error46) {
        throw asGatewayError(error46, await parseAuthMethod(resolvedHeaders));
      }
    }
    getUrl() {
      return `${this.config.baseURL}/image-model`;
    }
    getModelConfigHeaders() {
      return {
        "ai-image-model-specification-version": "2",
        "ai-model-id": this.modelId
      };
    }
  };
  var providerMetadataEntrySchema = external_exports.object({
    images: external_exports.array(external_exports.unknown()).optional()
  }).catchall(external_exports.unknown());
  var gatewayImageResponseSchema = external_exports.object({
    images: external_exports.array(external_exports.string()),
    // Always base64 strings over the wire
    warnings: external_exports.array(
      external_exports.object({
        type: external_exports.literal("other"),
        message: external_exports.string()
      })
    ).optional(),
    providerMetadata: external_exports.record(external_exports.string(), providerMetadataEntrySchema).optional()
  });
  async function getVercelRequestId() {
    var _a83;
    return (_a83 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a83["x-vercel-id"];
  }
  var VERSION2 = true ? "2.0.13" : "0.0.0-test";
  var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
  function createGatewayProvider(options = {}) {
    var _a83, _b8;
    let pendingMetadata = null;
    let metadataCache = null;
    const cacheRefreshMillis = (_a83 = options.metadataCacheRefreshMillis) != null ? _a83 : 1e3 * 60 * 5;
    let lastFetchTime = 0;
    const baseURL = (_b8 = withoutTrailingSlash(options.baseURL)) != null ? _b8 : "https://ai-gateway.vercel.sh/v1/ai";
    const getHeaders = async () => {
      const auth = await getGatewayAuthToken(options);
      if (auth) {
        return withUserAgentSuffix(
          {
            Authorization: `Bearer ${auth.token}`,
            "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
            [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
            ...options.headers
          },
          `ai-sdk/gateway/${VERSION2}`
        );
      }
      throw GatewayAuthenticationError.createContextualError({
        apiKeyProvided: false,
        oidcTokenProvided: false,
        statusCode: 401
      });
    };
    const createO11yHeaders = () => {
      const deploymentId = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_DEPLOYMENT_ID"
      });
      const environment = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_ENV"
      });
      const region = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_REGION"
      });
      return async () => {
        const requestId = await getVercelRequestId();
        return {
          ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
          ...environment && { "ai-o11y-environment": environment },
          ...region && { "ai-o11y-region": region },
          ...requestId && { "ai-o11y-request-id": requestId }
        };
      };
    };
    const createLanguageModel = (modelId) => {
      return new GatewayLanguageModel(modelId, {
        provider: "gateway",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        o11yHeaders: createO11yHeaders()
      });
    };
    const getAvailableModels = async () => {
      var _a93, _b9, _c;
      const now2 = (_c = (_b9 = (_a93 = options._internal) == null ? void 0 : _a93.currentDate) == null ? void 0 : _b9.call(_a93).getTime()) != null ? _c : Date.now();
      if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
        lastFetchTime = now2;
        pendingMetadata = new GatewayFetchMetadata({
          baseURL,
          headers: getHeaders,
          fetch: options.fetch
        }).getAvailableModels().then((metadata) => {
          metadataCache = metadata;
          return metadata;
        }).catch(async (error46) => {
          throw await asGatewayError(
            error46,
            await parseAuthMethod(await getHeaders())
          );
        });
      }
      return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
    };
    const getCredits = async () => {
      return new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getCredits().catch(async (error46) => {
        throw await asGatewayError(
          error46,
          await parseAuthMethod(await getHeaders())
        );
      });
    };
    const provider = function(modelId) {
      if (new.target) {
        throw new Error(
          "The Gateway Provider model function cannot be called with the new keyword."
        );
      }
      return createLanguageModel(modelId);
    };
    provider.getAvailableModels = getAvailableModels;
    provider.getCredits = getCredits;
    provider.imageModel = (modelId) => {
      return new GatewayImageModel(modelId, {
        provider: "gateway",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        o11yHeaders: createO11yHeaders()
      });
    };
    provider.languageModel = createLanguageModel;
    provider.textEmbeddingModel = (modelId) => {
      return new GatewayEmbeddingModel(modelId, {
        provider: "gateway",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        o11yHeaders: createO11yHeaders()
      });
    };
    return provider;
  }
  var gateway = createGatewayProvider();
  async function getGatewayAuthToken(options) {
    const apiKey = loadOptionalSetting({
      settingValue: options.apiKey,
      environmentVariableName: "AI_GATEWAY_API_KEY"
    });
    if (apiKey) {
      return {
        token: apiKey,
        authMethod: "api-key"
      };
    }
    try {
      const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
      return {
        token: oidcToken,
        authMethod: "oidc"
      };
    } catch (e) {
      return null;
    }
  }

  // node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
  var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};

  // node_modules/@opentelemetry/api/build/esm/version.js
  var VERSION3 = "1.9.0";

  // node_modules/@opentelemetry/api/build/esm/internal/semver.js
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return function() {
        return false;
      };
    }
    var ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible2(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      var globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      var globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  var isCompatible = _makeCompatibilityCheck(VERSION3);

  // node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
  var major = VERSION3.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
  var _global = _globalThis;
  function registerGlobal(type, instance, diag, allowOverride) {
    var _a17;
    if (allowOverride === void 0) {
      allowOverride = false;
    }
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a17 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a17 !== void 0 ? _a17 : {
      version: VERSION3
    };
    if (!allowOverride && api[type]) {
      var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== VERSION3) {
      var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION3);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION3 + ".");
    return true;
  }
  function getGlobal(type) {
    var _a17, _b8;
    var globalVersion = (_a17 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a17 === void 0 ? void 0 : _a17.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
      return;
    }
    return (_b8 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b8 === void 0 ? void 0 : _b8[type];
  }
  function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION3 + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }

  // node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
  var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error46) {
      e = { error: error46 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var DiagComponentLogger = (
    /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }()
  );
  function logProxy(funcName, namespace, args) {
    var logger = getGlobal("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
  }

  // node_modules/@opentelemetry/api/build/esm/diag/types.js
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel || (DiagLogLevel = {}));

  // node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
      maxLevel = DiagLogLevel.NONE;
    } else if (maxLevel > DiagLogLevel.ALL) {
      maxLevel = DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      var theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", DiagLogLevel.ERROR),
      warn: _filterFunc("warn", DiagLogLevel.WARN),
      info: _filterFunc("info", DiagLogLevel.INFO),
      debug: _filterFunc("debug", DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
    };
  }

  // node_modules/@opentelemetry/api/build/esm/api/diag.js
  var __read2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error46) {
      e = { error: error46 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME = "diag";
  var DiagAPI = (
    /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a17, _b8, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a17 = err.stack) !== null && _a17 !== void 0 ? _a17 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b8 = optionsOrLogLevel.logLevel) !== null && _b8 !== void 0 ? _b8 : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/context/context.js
  function createContextKey(description) {
    return Symbol.for(description);
  }
  var BaseContext = (
    /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context = new BaseContext2(self2._currentContext);
          context._currentContext.set(key, value);
          return context;
        };
        self2.deleteValue = function(key) {
          var context = new BaseContext2(self2._currentContext);
          context._currentContext.delete(key);
          return context;
        };
      }
      return BaseContext2;
    }()
  );
  var ROOT_CONTEXT = new BaseContext();

  // node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
  var __read3 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error46) {
      e = { error: error46 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray3 = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var NoopContextManager = (
    /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/api/context.js
  var __read4 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error46) {
      e = { error: error46 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray4 = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME2 = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager();
  var ContextAPI = (
    /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context, fn, thisArg) {
        var _a17;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a17 = this._getContextManager()).with.apply(_a17, __spreadArray4([context, fn, thisArg], __read4(args), false));
      };
      ContextAPI2.prototype.bind = function(context, target) {
        return this._getContextManager().bind(context, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags || (TraceFlags = {}));

  // node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
  var INVALID_SPANID = "0000000000000000";
  var INVALID_TRACEID = "00000000000000000000000000000000";
  var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE
  };

  // node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
  var NonRecordingSpan = (
    /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
  var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || void 0;
  }
  function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
  }
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
  }
  function getSpanContext(context) {
    var _a17;
    return (_a17 = getSpan(context)) === null || _a17 === void 0 ? void 0 : _a17.spanContext();
  }

  // node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
  }
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
  }
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
  }

  // node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
  var contextApi = ContextAPI.getInstance();
  var NoopTracer = (
    /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name16, options, context) {
        if (context === void 0) {
          context = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name16, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name16, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }()
  );
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }

  // node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
  var NOOP_TRACER = new NoopTracer();
  var ProxyTracer = (
    /** @class */
    function() {
      function ProxyTracer2(_provider, name16, version2, options) {
        this._provider = _provider;
        this.name = name16;
        this.version = version2;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name16, options, context) {
        return this._getTracer().startSpan(name16, options, context);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
  var NoopTracerProvider = (
    /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
  var ProxyTracerProvider = (
    /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name16, version2, options) {
        var _a17;
        return (_a17 = this.getDelegateTracer(name16, version2, options)) !== null && _a17 !== void 0 ? _a17 : new ProxyTracer(this, name16, version2, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a17;
        return (_a17 = this._delegate) !== null && _a17 !== void 0 ? _a17 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name16, version2, options) {
        var _a17;
        return (_a17 = this._delegate) === null || _a17 === void 0 ? void 0 : _a17.getTracer(name16, version2, options);
      };
      return ProxyTracerProvider2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace/status.js
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode || (SpanStatusCode = {}));

  // node_modules/@opentelemetry/api/build/esm/api/trace.js
  var API_NAME3 = "trace";
  var TraceAPI = (
    /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success2 = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success2) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success2;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name16, version2) {
        return this.getTracerProvider().getTracer(name16, version2);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }()
  );

  // node_modules/@opentelemetry/api/build/esm/trace-api.js
  var trace = TraceAPI.getInstance();

  // node_modules/ai/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name16 in all)
      __defProp2(target, name16, { get: all[name16], enumerable: true });
  };
  var name15 = "AI_NoOutputSpecifiedError";
  var marker16 = `vercel.ai.error.${name15}`;
  var symbol17 = Symbol.for(marker16);
  var _a16;
  var NoOutputSpecifiedError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "No output specified." } = {}) {
      super({ name: name15, message });
      this[_a16] = true;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker16);
    }
  };
  _a16 = symbol17;
  function formatWarning(warning) {
    const prefix = "AI SDK Warning:";
    switch (warning.type) {
      case "unsupported-setting": {
        let message = `${prefix} The "${warning.setting}" setting is not supported by this model`;
        if (warning.details) {
          message += ` - ${warning.details}`;
        }
        return message;
      }
      case "unsupported-tool": {
        const toolName = "name" in warning.tool ? warning.tool.name : "unknown tool";
        let message = `${prefix} The tool "${toolName}" is not supported by this model`;
        if (warning.details) {
          message += ` - ${warning.details}`;
        }
        return message;
      }
      case "other": {
        return `${prefix} ${warning.message}`;
      }
      default: {
        return `${prefix} ${JSON.stringify(warning, null, 2)}`;
      }
    }
  }
  var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
  var hasLoggedBefore = false;
  var logWarnings = (warnings) => {
    if (warnings.length === 0) {
      return;
    }
    const logger = globalThis.AI_SDK_LOG_WARNINGS;
    if (logger === false) {
      return;
    }
    if (typeof logger === "function") {
      logger(warnings);
      return;
    }
    if (!hasLoggedBefore) {
      hasLoggedBefore = true;
      console.info(FIRST_WARNING_INFO_MESSAGE);
    }
    for (const warning of warnings) {
      console.warn(formatWarning(warning));
    }
  };
  var name23 = "AI_InvalidArgumentError";
  var marker23 = `vercel.ai.error.${name23}`;
  var symbol23 = Symbol.for(marker23);
  var _a23;
  var InvalidArgumentError2 = class extends AISDKError {
    constructor({
      parameter,
      value,
      message
    }) {
      super({
        name: name23,
        message: `Invalid argument for parameter ${parameter}: ${message}`
      });
      this[_a23] = true;
      this.parameter = parameter;
      this.value = value;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker23);
    }
  };
  _a23 = symbol23;
  var name33 = "AI_InvalidStreamPartError";
  var marker33 = `vercel.ai.error.${name33}`;
  var symbol33 = Symbol.for(marker33);
  var _a33;
  _a33 = symbol33;
  var name43 = "AI_InvalidToolInputError";
  var marker43 = `vercel.ai.error.${name43}`;
  var symbol43 = Symbol.for(marker43);
  var _a43;
  var InvalidToolInputError = class extends AISDKError {
    constructor({
      toolInput,
      toolName,
      cause,
      message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`
    }) {
      super({ name: name43, message, cause });
      this[_a43] = true;
      this.toolInput = toolInput;
      this.toolName = toolName;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker43);
    }
  };
  _a43 = symbol43;
  var name53 = "AI_NoImageGeneratedError";
  var marker53 = `vercel.ai.error.${name53}`;
  var symbol53 = Symbol.for(marker53);
  var _a53;
  _a53 = symbol53;
  var name63 = "AI_NoObjectGeneratedError";
  var marker63 = `vercel.ai.error.${name63}`;
  var symbol63 = Symbol.for(marker63);
  var _a63;
  var NoObjectGeneratedError = class extends AISDKError {
    constructor({
      message = "No object generated.",
      cause,
      text: text2,
      response,
      usage,
      finishReason
    }) {
      super({ name: name63, message, cause });
      this[_a63] = true;
      this.text = text2;
      this.response = response;
      this.usage = usage;
      this.finishReason = finishReason;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker63);
    }
  };
  _a63 = symbol63;
  var name72 = "AI_NoOutputGeneratedError";
  var marker73 = `vercel.ai.error.${name72}`;
  var symbol73 = Symbol.for(marker73);
  var _a73;
  var NoOutputGeneratedError = class extends AISDKError {
    // used in isInstance
    constructor({
      message = "No output generated.",
      cause
    } = {}) {
      super({ name: name72, message, cause });
      this[_a73] = true;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker73);
    }
  };
  _a73 = symbol73;
  var name82 = "AI_NoSuchToolError";
  var marker82 = `vercel.ai.error.${name82}`;
  var symbol82 = Symbol.for(marker82);
  var _a82;
  var NoSuchToolError = class extends AISDKError {
    constructor({
      toolName,
      availableTools = void 0,
      message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
    }) {
      super({ name: name82, message });
      this[_a82] = true;
      this.toolName = toolName;
      this.availableTools = availableTools;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker82);
    }
  };
  _a82 = symbol82;
  var name92 = "AI_ToolCallRepairError";
  var marker92 = `vercel.ai.error.${name92}`;
  var symbol92 = Symbol.for(marker92);
  var _a92;
  var ToolCallRepairError = class extends AISDKError {
    constructor({
      cause,
      originalError,
      message = `Error repairing tool call: ${getErrorMessage(cause)}`
    }) {
      super({ name: name92, message, cause });
      this[_a92] = true;
      this.originalError = originalError;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker92);
    }
  };
  _a92 = symbol92;
  var UnsupportedModelVersionError = class extends AISDKError {
    constructor(options) {
      super({
        name: "AI_UnsupportedModelVersionError",
        message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
      });
      this.version = options.version;
      this.provider = options.provider;
      this.modelId = options.modelId;
    }
  };
  var name102 = "AI_InvalidDataContentError";
  var marker102 = `vercel.ai.error.${name102}`;
  var symbol102 = Symbol.for(marker102);
  var _a102;
  _a102 = symbol102;
  var name112 = "AI_InvalidMessageRoleError";
  var marker112 = `vercel.ai.error.${name112}`;
  var symbol112 = Symbol.for(marker112);
  var _a112;
  var InvalidMessageRoleError = class extends AISDKError {
    constructor({
      role,
      message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
    }) {
      super({ name: name112, message });
      this[_a112] = true;
      this.role = role;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker112);
    }
  };
  _a112 = symbol112;
  var name122 = "AI_MessageConversionError";
  var marker122 = `vercel.ai.error.${name122}`;
  var symbol122 = Symbol.for(marker122);
  var _a122;
  _a122 = symbol122;
  var name132 = "AI_DownloadError";
  var marker132 = `vercel.ai.error.${name132}`;
  var symbol132 = Symbol.for(marker132);
  var _a132;
  var DownloadError = class extends AISDKError {
    constructor({
      url: url2,
      statusCode,
      statusText,
      cause,
      message = cause == null ? `Failed to download ${url2}: ${statusCode} ${statusText}` : `Failed to download ${url2}: ${cause}`
    }) {
      super({ name: name132, message, cause });
      this[_a132] = true;
      this.url = url2;
      this.statusCode = statusCode;
      this.statusText = statusText;
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker132);
    }
  };
  _a132 = symbol132;
  var name142 = "AI_RetryError";
  var marker142 = `vercel.ai.error.${name142}`;
  var symbol142 = Symbol.for(marker142);
  var _a142;
  var RetryError = class extends AISDKError {
    constructor({
      message,
      reason,
      errors
    }) {
      super({ name: name142, message });
      this[_a142] = true;
      this.reason = reason;
      this.errors = errors;
      this.lastError = errors[errors.length - 1];
    }
    static isInstance(error46) {
      return AISDKError.hasMarker(error46, marker142);
    }
  };
  _a142 = symbol142;
  function resolveLanguageModel(model) {
    if (typeof model !== "string") {
      if (model.specificationVersion !== "v2") {
        throw new UnsupportedModelVersionError({
          version: model.specificationVersion,
          provider: model.provider,
          modelId: model.modelId
        });
      }
      return model;
    }
    return getGlobalProvider().languageModel(model);
  }
  function getGlobalProvider() {
    var _a162;
    return (_a162 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a162 : gateway;
  }
  var imageMediaTypeSignatures = [
    {
      mediaType: "image/gif",
      bytesPrefix: [71, 73, 70]
      // GIF
    },
    {
      mediaType: "image/png",
      bytesPrefix: [137, 80, 78, 71]
      // PNG
    },
    {
      mediaType: "image/jpeg",
      bytesPrefix: [255, 216]
      // JPEG
    },
    {
      mediaType: "image/webp",
      bytesPrefix: [
        82,
        73,
        70,
        70,
        // "RIFF"
        null,
        null,
        null,
        null,
        // file size (variable)
        87,
        69,
        66,
        80
        // "WEBP"
      ]
    },
    {
      mediaType: "image/bmp",
      bytesPrefix: [66, 77]
    },
    {
      mediaType: "image/tiff",
      bytesPrefix: [73, 73, 42, 0]
    },
    {
      mediaType: "image/tiff",
      bytesPrefix: [77, 77, 0, 42]
    },
    {
      mediaType: "image/avif",
      bytesPrefix: [
        0,
        0,
        0,
        32,
        102,
        116,
        121,
        112,
        97,
        118,
        105,
        102
      ]
    },
    {
      mediaType: "image/heic",
      bytesPrefix: [
        0,
        0,
        0,
        32,
        102,
        116,
        121,
        112,
        104,
        101,
        105,
        99
      ]
    }
  ];
  var stripID3 = (data) => {
    const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
    return bytes.slice(id3Size + 10);
  };
  function stripID3TagsIfPresent(data) {
    const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
    data[1] === 68 && // 'D'
    data[2] === 51;
    return hasId3 ? stripID3(data) : data;
  }
  function detectMediaType({
    data,
    signatures
  }) {
    const processedData = stripID3TagsIfPresent(data);
    const bytes = typeof processedData === "string" ? convertBase64ToUint8Array(
      processedData.substring(0, Math.min(processedData.length, 24))
    ) : processedData;
    for (const signature of signatures) {
      if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(
        (byte, index) => byte === null || bytes[index] === byte
      )) {
        return signature.mediaType;
      }
    }
    return void 0;
  }
  var VERSION4 = true ? "5.0.98" : "0.0.0-test";
  var download = async ({ url: url2 }) => {
    var _a162;
    const urlText = url2.toString();
    try {
      const response = await fetch(urlText, {
        headers: withUserAgentSuffix(
          {},
          `ai-sdk/${VERSION4}`,
          getRuntimeEnvironmentUserAgent()
        )
      });
      if (!response.ok) {
        throw new DownloadError({
          url: urlText,
          statusCode: response.status,
          statusText: response.statusText
        });
      }
      return {
        data: new Uint8Array(await response.arrayBuffer()),
        mediaType: (_a162 = response.headers.get("content-type")) != null ? _a162 : void 0
      };
    } catch (error46) {
      if (DownloadError.isInstance(error46)) {
        throw error46;
      }
      throw new DownloadError({ url: urlText, cause: error46 });
    }
  };
  var createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(
    requestedDownloads.map(
      async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)
    )
  );
  function splitDataUrl(dataUrl) {
    try {
      const [header, base64Content] = dataUrl.split(",");
      return {
        mediaType: header.split(";")[0].split(":")[1],
        base64Content
      };
    } catch (error46) {
      return {
        mediaType: void 0,
        base64Content: void 0
      };
    }
  }
  var dataContentSchema = external_exports.union([
    external_exports.string(),
    external_exports.instanceof(Uint8Array),
    external_exports.instanceof(ArrayBuffer),
    external_exports.custom(
      // Buffer might not be available in some environments such as CloudFlare:
      (value) => {
        var _a162, _b8;
        return (_b8 = (_a162 = globalThis.Buffer) == null ? void 0 : _a162.isBuffer(value)) != null ? _b8 : false;
      },
      { message: "Must be a Buffer" }
    )
  ]);
  function convertToLanguageModelV2DataContent(content) {
    if (content instanceof Uint8Array) {
      return { data: content, mediaType: void 0 };
    }
    if (content instanceof ArrayBuffer) {
      return { data: new Uint8Array(content), mediaType: void 0 };
    }
    if (typeof content === "string") {
      try {
        content = new URL(content);
      } catch (error46) {
      }
    }
    if (content instanceof URL && content.protocol === "data:") {
      const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(
        content.toString()
      );
      if (dataUrlMediaType == null || base64Content == null) {
        throw new AISDKError({
          name: "InvalidDataContentError",
          message: `Invalid data URL format in content ${content.toString()}`
        });
      }
      return { data: base64Content, mediaType: dataUrlMediaType };
    }
    return { data: content, mediaType: void 0 };
  }
  function convertDataContentToBase64String(content) {
    if (typeof content === "string") {
      return content;
    }
    if (content instanceof ArrayBuffer) {
      return convertUint8ArrayToBase64(new Uint8Array(content));
    }
    return convertUint8ArrayToBase64(content);
  }
  async function convertToLanguageModelPrompt({
    prompt,
    supportedUrls,
    download: download2 = createDefaultDownloadFunction()
  }) {
    const downloadedAssets = await downloadAssets(
      prompt.messages,
      download2,
      supportedUrls
    );
    return [
      ...prompt.system != null ? [{ role: "system", content: prompt.system }] : [],
      ...prompt.messages.map(
        (message) => convertToLanguageModelMessage({ message, downloadedAssets })
      )
    ];
  }
  function convertToLanguageModelMessage({
    message,
    downloadedAssets
  }) {
    const role = message.role;
    switch (role) {
      case "system": {
        return {
          role: "system",
          content: message.content,
          providerOptions: message.providerOptions
        };
      }
      case "user": {
        if (typeof message.content === "string") {
          return {
            role: "user",
            content: [{ type: "text", text: message.content }],
            providerOptions: message.providerOptions
          };
        }
        return {
          role: "user",
          content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
          providerOptions: message.providerOptions
        };
      }
      case "assistant": {
        if (typeof message.content === "string") {
          return {
            role: "assistant",
            content: [{ type: "text", text: message.content }],
            providerOptions: message.providerOptions
          };
        }
        return {
          role: "assistant",
          content: message.content.filter(
            // remove empty text parts (no text, and no provider options):
            (part) => part.type !== "text" || part.text !== "" || part.providerOptions != null
          ).map((part) => {
            const providerOptions = part.providerOptions;
            switch (part.type) {
              case "file": {
                const { data, mediaType } = convertToLanguageModelV2DataContent(
                  part.data
                );
                return {
                  type: "file",
                  data,
                  filename: part.filename,
                  mediaType: mediaType != null ? mediaType : part.mediaType,
                  providerOptions
                };
              }
              case "reasoning": {
                return {
                  type: "reasoning",
                  text: part.text,
                  providerOptions
                };
              }
              case "text": {
                return {
                  type: "text",
                  text: part.text,
                  providerOptions
                };
              }
              case "tool-call": {
                return {
                  type: "tool-call",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  input: part.input,
                  providerExecuted: part.providerExecuted,
                  providerOptions
                };
              }
              case "tool-result": {
                return {
                  type: "tool-result",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  output: part.output,
                  providerOptions
                };
              }
            }
          }),
          providerOptions: message.providerOptions
        };
      }
      case "tool": {
        return {
          role: "tool",
          content: message.content.map((part) => ({
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: part.output,
            providerOptions: part.providerOptions
          })),
          providerOptions: message.providerOptions
        };
      }
      default: {
        const _exhaustiveCheck = role;
        throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
      }
    }
  }
  async function downloadAssets(messages, download2, supportedUrls) {
    const plannedDownloads = messages.filter((message) => message.role === "user").map((message) => message.content).filter(
      (content) => Array.isArray(content)
    ).flat().filter(
      (part) => part.type === "image" || part.type === "file"
    ).map((part) => {
      var _a162;
      const mediaType = (_a162 = part.mediaType) != null ? _a162 : part.type === "image" ? "image/*" : void 0;
      let data = part.type === "image" ? part.image : part.data;
      if (typeof data === "string") {
        try {
          data = new URL(data);
        } catch (ignored) {
        }
      }
      return { mediaType, data };
    }).filter(
      (part) => part.data instanceof URL
    ).map((part) => ({
      url: part.data,
      isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
        url: part.data.toString(),
        mediaType: part.mediaType,
        supportedUrls
      })
    }));
    const downloadedFiles = await download2(plannedDownloads);
    return Object.fromEntries(
      downloadedFiles.map(
        (file2, index) => file2 == null ? null : [
          plannedDownloads[index].url.toString(),
          { data: file2.data, mediaType: file2.mediaType }
        ]
      ).filter((file2) => file2 != null)
    );
  }
  function convertPartToLanguageModelPart(part, downloadedAssets) {
    var _a162;
    if (part.type === "text") {
      return {
        type: "text",
        text: part.text,
        providerOptions: part.providerOptions
      };
    }
    let originalData;
    const type = part.type;
    switch (type) {
      case "image":
        originalData = part.image;
        break;
      case "file":
        originalData = part.data;
        break;
      default:
        throw new Error(`Unsupported part type: ${type}`);
    }
    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);
    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
    let data = convertedData;
    if (data instanceof URL) {
      const downloadedFile = downloadedAssets[data.toString()];
      if (downloadedFile) {
        data = downloadedFile.data;
        mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;
      }
    }
    switch (type) {
      case "image": {
        if (data instanceof Uint8Array || typeof data === "string") {
          mediaType = (_a162 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a162 : mediaType;
        }
        return {
          type: "file",
          mediaType: mediaType != null ? mediaType : "image/*",
          // any image
          filename: void 0,
          data,
          providerOptions: part.providerOptions
        };
      }
      case "file": {
        if (mediaType == null) {
          throw new Error(`Media type is missing for file part`);
        }
        return {
          type: "file",
          mediaType,
          filename: part.filename,
          data,
          providerOptions: part.providerOptions
        };
      }
    }
  }
  function prepareCallSettings({
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    stopSequences
  }) {
    if (maxOutputTokens != null) {
      if (!Number.isInteger(maxOutputTokens)) {
        throw new InvalidArgumentError2({
          parameter: "maxOutputTokens",
          value: maxOutputTokens,
          message: "maxOutputTokens must be an integer"
        });
      }
      if (maxOutputTokens < 1) {
        throw new InvalidArgumentError2({
          parameter: "maxOutputTokens",
          value: maxOutputTokens,
          message: "maxOutputTokens must be >= 1"
        });
      }
    }
    if (temperature != null) {
      if (typeof temperature !== "number") {
        throw new InvalidArgumentError2({
          parameter: "temperature",
          value: temperature,
          message: "temperature must be a number"
        });
      }
    }
    if (topP != null) {
      if (typeof topP !== "number") {
        throw new InvalidArgumentError2({
          parameter: "topP",
          value: topP,
          message: "topP must be a number"
        });
      }
    }
    if (topK != null) {
      if (typeof topK !== "number") {
        throw new InvalidArgumentError2({
          parameter: "topK",
          value: topK,
          message: "topK must be a number"
        });
      }
    }
    if (presencePenalty != null) {
      if (typeof presencePenalty !== "number") {
        throw new InvalidArgumentError2({
          parameter: "presencePenalty",
          value: presencePenalty,
          message: "presencePenalty must be a number"
        });
      }
    }
    if (frequencyPenalty != null) {
      if (typeof frequencyPenalty !== "number") {
        throw new InvalidArgumentError2({
          parameter: "frequencyPenalty",
          value: frequencyPenalty,
          message: "frequencyPenalty must be a number"
        });
      }
    }
    if (seed != null) {
      if (!Number.isInteger(seed)) {
        throw new InvalidArgumentError2({
          parameter: "seed",
          value: seed,
          message: "seed must be an integer"
        });
      }
    }
    return {
      maxOutputTokens,
      temperature,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      stopSequences,
      seed
    };
  }
  function isNonEmptyObject(object22) {
    return object22 != null && Object.keys(object22).length > 0;
  }
  function prepareToolsAndToolChoice({
    tools,
    toolChoice,
    activeTools
  }) {
    if (!isNonEmptyObject(tools)) {
      return {
        tools: void 0,
        toolChoice: void 0
      };
    }
    const filteredTools = activeTools != null ? Object.entries(tools).filter(
      ([name16]) => activeTools.includes(name16)
    ) : Object.entries(tools);
    return {
      tools: filteredTools.map(([name16, tool2]) => {
        const toolType = tool2.type;
        switch (toolType) {
          case void 0:
          case "dynamic":
          case "function":
            return {
              type: "function",
              name: name16,
              description: tool2.description,
              inputSchema: asSchema(tool2.inputSchema).jsonSchema,
              providerOptions: tool2.providerOptions
            };
          case "provider-defined":
            return {
              type: "provider-defined",
              name: name16,
              id: tool2.id,
              args: tool2.args
            };
          default: {
            const exhaustiveCheck = toolType;
            throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
          }
        }
      }),
      toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
    };
  }
  var jsonValueSchema = external_exports.lazy(
    () => external_exports.union([
      external_exports.null(),
      external_exports.string(),
      external_exports.number(),
      external_exports.boolean(),
      external_exports.record(external_exports.string(), jsonValueSchema),
      external_exports.array(jsonValueSchema)
    ])
  );
  var providerMetadataSchema = external_exports.record(
    external_exports.string(),
    external_exports.record(external_exports.string(), jsonValueSchema)
  );
  var textPartSchema = external_exports.object({
    type: external_exports.literal("text"),
    text: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var imagePartSchema = external_exports.object({
    type: external_exports.literal("image"),
    image: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
    mediaType: external_exports.string().optional(),
    providerOptions: providerMetadataSchema.optional()
  });
  var filePartSchema = external_exports.object({
    type: external_exports.literal("file"),
    data: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
    filename: external_exports.string().optional(),
    mediaType: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var reasoningPartSchema = external_exports.object({
    type: external_exports.literal("reasoning"),
    text: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolCallPartSchema = external_exports.object({
    type: external_exports.literal("tool-call"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    input: external_exports.unknown(),
    providerOptions: providerMetadataSchema.optional(),
    providerExecuted: external_exports.boolean().optional()
  });
  var outputSchema = external_exports.discriminatedUnion("type", [
    external_exports.object({
      type: external_exports.literal("text"),
      value: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("json"),
      value: jsonValueSchema
    }),
    external_exports.object({
      type: external_exports.literal("error-text"),
      value: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("error-json"),
      value: jsonValueSchema
    }),
    external_exports.object({
      type: external_exports.literal("content"),
      value: external_exports.array(
        external_exports.union([
          external_exports.object({
            type: external_exports.literal("text"),
            text: external_exports.string()
          }),
          external_exports.object({
            type: external_exports.literal("media"),
            data: external_exports.string(),
            mediaType: external_exports.string()
          })
        ])
      )
    })
  ]);
  var toolResultPartSchema = external_exports.object({
    type: external_exports.literal("tool-result"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    output: outputSchema,
    providerOptions: providerMetadataSchema.optional()
  });
  var systemModelMessageSchema = external_exports.object(
    {
      role: external_exports.literal("system"),
      content: external_exports.string(),
      providerOptions: providerMetadataSchema.optional()
    }
  );
  var userModelMessageSchema = external_exports.object({
    role: external_exports.literal("user"),
    content: external_exports.union([
      external_exports.string(),
      external_exports.array(external_exports.union([textPartSchema, imagePartSchema, filePartSchema]))
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var assistantModelMessageSchema = external_exports.object({
    role: external_exports.literal("assistant"),
    content: external_exports.union([
      external_exports.string(),
      external_exports.array(
        external_exports.union([
          textPartSchema,
          filePartSchema,
          reasoningPartSchema,
          toolCallPartSchema,
          toolResultPartSchema
        ])
      )
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolModelMessageSchema = external_exports.object({
    role: external_exports.literal("tool"),
    content: external_exports.array(toolResultPartSchema),
    providerOptions: providerMetadataSchema.optional()
  });
  var modelMessageSchema = external_exports.union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
  ]);
  async function standardizePrompt(prompt) {
    if (prompt.prompt == null && prompt.messages == null) {
      throw new InvalidPromptError({
        prompt,
        message: "prompt or messages must be defined"
      });
    }
    if (prompt.prompt != null && prompt.messages != null) {
      throw new InvalidPromptError({
        prompt,
        message: "prompt and messages cannot be defined at the same time"
      });
    }
    if (prompt.system != null && typeof prompt.system !== "string") {
      throw new InvalidPromptError({
        prompt,
        message: "system must be a string"
      });
    }
    let messages;
    if (prompt.prompt != null && typeof prompt.prompt === "string") {
      messages = [{ role: "user", content: prompt.prompt }];
    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
      messages = prompt.prompt;
    } else if (prompt.messages != null) {
      messages = prompt.messages;
    } else {
      throw new InvalidPromptError({
        prompt,
        message: "prompt or messages must be defined"
      });
    }
    if (messages.length === 0) {
      throw new InvalidPromptError({
        prompt,
        message: "messages must not be empty"
      });
    }
    const validationResult = await safeValidateTypes({
      value: messages,
      schema: external_exports.array(modelMessageSchema)
    });
    if (!validationResult.success) {
      throw new InvalidPromptError({
        prompt,
        message: "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
        cause: validationResult.error
      });
    }
    return {
      messages,
      system: prompt.system
    };
  }
  function wrapGatewayError(error46) {
    if (GatewayAuthenticationError.isInstance(error46) || GatewayModelNotFoundError.isInstance(error46)) {
      return new AISDKError({
        name: "GatewayError",
        message: "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
        cause: error46
      });
    }
    return error46;
  }
  function assembleOperationName({
    operationId,
    telemetry
  }) {
    return {
      // standardized operation and resource name:
      "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
      "resource.name": telemetry == null ? void 0 : telemetry.functionId,
      // detailed, AI SDK specific data:
      "ai.operationId": operationId,
      "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
  }
  function getBaseTelemetryAttributes({
    model,
    settings,
    telemetry,
    headers
  }) {
    var _a162;
    return {
      "ai.model.provider": model.provider,
      "ai.model.id": model.modelId,
      // settings:
      ...Object.entries(settings).reduce((attributes, [key, value]) => {
        attributes[`ai.settings.${key}`] = value;
        return attributes;
      }, {}),
      // add metadata as attributes:
      ...Object.entries((_a162 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a162 : {}).reduce(
        (attributes, [key, value]) => {
          attributes[`ai.telemetry.metadata.${key}`] = value;
          return attributes;
        },
        {}
      ),
      // request headers
      ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
        if (value !== void 0) {
          attributes[`ai.request.headers.${key}`] = value;
        }
        return attributes;
      }, {})
    };
  }
  var noopTracer = {
    startSpan() {
      return noopSpan;
    },
    startActiveSpan(name16, arg1, arg2, arg3) {
      if (typeof arg1 === "function") {
        return arg1(noopSpan);
      }
      if (typeof arg2 === "function") {
        return arg2(noopSpan);
      }
      if (typeof arg3 === "function") {
        return arg3(noopSpan);
      }
    }
  };
  var noopSpan = {
    spanContext() {
      return noopSpanContext;
    },
    setAttribute() {
      return this;
    },
    setAttributes() {
      return this;
    },
    addEvent() {
      return this;
    },
    addLink() {
      return this;
    },
    addLinks() {
      return this;
    },
    setStatus() {
      return this;
    },
    updateName() {
      return this;
    },
    end() {
      return this;
    },
    isRecording() {
      return false;
    },
    recordException() {
      return this;
    }
  };
  var noopSpanContext = {
    traceId: "",
    spanId: "",
    traceFlags: 0
  };
  function getTracer({
    isEnabled = false,
    tracer
  } = {}) {
    if (!isEnabled) {
      return noopTracer;
    }
    if (tracer) {
      return tracer;
    }
    return trace.getTracer("ai");
  }
  function recordSpan({
    name: name16,
    tracer,
    attributes,
    fn,
    endWhenDone = true
  }) {
    return tracer.startActiveSpan(name16, { attributes }, async (span) => {
      try {
        const result = await fn(span);
        if (endWhenDone) {
          span.end();
        }
        return result;
      } catch (error46) {
        try {
          recordErrorOnSpan(span, error46);
        } finally {
          span.end();
        }
        throw error46;
      }
    });
  }
  function recordErrorOnSpan(span, error46) {
    if (error46 instanceof Error) {
      span.recordException({
        name: error46.name,
        message: error46.message,
        stack: error46.stack
      });
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error46.message
      });
    } else {
      span.setStatus({ code: SpanStatusCode.ERROR });
    }
  }
  function selectTelemetryAttributes({
    telemetry,
    attributes
  }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
      return {};
    }
    return Object.entries(attributes).reduce((attributes2, [key, value]) => {
      if (value == null) {
        return attributes2;
      }
      if (typeof value === "object" && "input" in value && typeof value.input === "function") {
        if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
          return attributes2;
        }
        const result = value.input();
        return result == null ? attributes2 : { ...attributes2, [key]: result };
      }
      if (typeof value === "object" && "output" in value && typeof value.output === "function") {
        if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
          return attributes2;
        }
        const result = value.output();
        return result == null ? attributes2 : { ...attributes2, [key]: result };
      }
      return { ...attributes2, [key]: value };
    }, {});
  }
  function stringifyForTelemetry(prompt) {
    return JSON.stringify(
      prompt.map((message) => ({
        ...message,
        content: typeof message.content === "string" ? message.content : message.content.map(
          (part) => part.type === "file" ? {
            ...part,
            data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
          } : part
        )
      }))
    );
  }
  function addLanguageModelUsage(usage1, usage2) {
    return {
      inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
      outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
      totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
      reasoningTokens: addTokenCounts(
        usage1.reasoningTokens,
        usage2.reasoningTokens
      ),
      cachedInputTokens: addTokenCounts(
        usage1.cachedInputTokens,
        usage2.cachedInputTokens
      )
    };
  }
  function addTokenCounts(tokenCount1, tokenCount2) {
    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
  }
  function asArray(value) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [value];
  }
  function getRetryDelayInMs({
    error: error46,
    exponentialBackoffDelay
  }) {
    const headers = error46.responseHeaders;
    if (!headers)
      return exponentialBackoffDelay;
    let ms;
    const retryAfterMs = headers["retry-after-ms"];
    if (retryAfterMs) {
      const timeoutMs = parseFloat(retryAfterMs);
      if (!Number.isNaN(timeoutMs)) {
        ms = timeoutMs;
      }
    }
    const retryAfter = headers["retry-after"];
    if (retryAfter && ms === void 0) {
      const timeoutSeconds = parseFloat(retryAfter);
      if (!Number.isNaN(timeoutSeconds)) {
        ms = timeoutSeconds * 1e3;
      } else {
        ms = Date.parse(retryAfter) - Date.now();
      }
    }
    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
      return ms;
    }
    return exponentialBackoffDelay;
  }
  var retryWithExponentialBackoffRespectingRetryHeaders = ({
    maxRetries = 2,
    initialDelayInMs = 2e3,
    backoffFactor = 2,
    abortSignal
  } = {}) => async (f) => _retryWithExponentialBackoff(f, {
    maxRetries,
    delayInMs: initialDelayInMs,
    backoffFactor,
    abortSignal
  });
  async function _retryWithExponentialBackoff(f, {
    maxRetries,
    delayInMs,
    backoffFactor,
    abortSignal
  }, errors = []) {
    try {
      return await f();
    } catch (error46) {
      if (isAbortError(error46)) {
        throw error46;
      }
      if (maxRetries === 0) {
        throw error46;
      }
      const errorMessage = getErrorMessage2(error46);
      const newErrors = [...errors, error46];
      const tryNumber = newErrors.length;
      if (tryNumber > maxRetries) {
        throw new RetryError({
          message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
          reason: "maxRetriesExceeded",
          errors: newErrors
        });
      }
      if (error46 instanceof Error && APICallError.isInstance(error46) && error46.isRetryable === true && tryNumber <= maxRetries) {
        await delay(
          getRetryDelayInMs({
            error: error46,
            exponentialBackoffDelay: delayInMs
          }),
          { abortSignal }
        );
        return _retryWithExponentialBackoff(
          f,
          {
            maxRetries,
            delayInMs: backoffFactor * delayInMs,
            backoffFactor,
            abortSignal
          },
          newErrors
        );
      }
      if (tryNumber === 1) {
        throw error46;
      }
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
        reason: "errorNotRetryable",
        errors: newErrors
      });
    }
  }
  function prepareRetries({
    maxRetries,
    abortSignal
  }) {
    if (maxRetries != null) {
      if (!Number.isInteger(maxRetries)) {
        throw new InvalidArgumentError2({
          parameter: "maxRetries",
          value: maxRetries,
          message: "maxRetries must be an integer"
        });
      }
      if (maxRetries < 0) {
        throw new InvalidArgumentError2({
          parameter: "maxRetries",
          value: maxRetries,
          message: "maxRetries must be >= 0"
        });
      }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
      maxRetries: maxRetriesResult,
      retry: retryWithExponentialBackoffRespectingRetryHeaders({
        maxRetries: maxRetriesResult,
        abortSignal
      })
    };
  }
  var DefaultGeneratedFile = class {
    constructor({
      data,
      mediaType
    }) {
      const isUint8Array = data instanceof Uint8Array;
      this.base64Data = isUint8Array ? void 0 : data;
      this.uint8ArrayData = isUint8Array ? data : void 0;
      this.mediaType = mediaType;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get base64() {
      if (this.base64Data == null) {
        this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
      }
      return this.base64Data;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get uint8Array() {
      if (this.uint8ArrayData == null) {
        this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
      }
      return this.uint8ArrayData;
    }
  };
  var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
    constructor(options) {
      super(options);
      this.type = "file";
    }
  };
  async function parseToolCall({
    toolCall,
    tools,
    repairToolCall,
    system,
    messages
  }) {
    try {
      if (tools == null) {
        throw new NoSuchToolError({ toolName: toolCall.toolName });
      }
      try {
        return await doParseToolCall({ toolCall, tools });
      } catch (error46) {
        if (repairToolCall == null || !(NoSuchToolError.isInstance(error46) || InvalidToolInputError.isInstance(error46))) {
          throw error46;
        }
        let repairedToolCall = null;
        try {
          repairedToolCall = await repairToolCall({
            toolCall,
            tools,
            inputSchema: ({ toolName }) => {
              const { inputSchema } = tools[toolName];
              return asSchema(inputSchema).jsonSchema;
            },
            system,
            messages,
            error: error46
          });
        } catch (repairError) {
          throw new ToolCallRepairError({
            cause: repairError,
            originalError: error46
          });
        }
        if (repairedToolCall == null) {
          throw error46;
        }
        return await doParseToolCall({ toolCall: repairedToolCall, tools });
      }
    } catch (error46) {
      const parsedInput = await safeParseJSON({ text: toolCall.input });
      const input = parsedInput.success ? parsedInput.value : toolCall.input;
      return {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName: toolCall.toolName,
        input,
        dynamic: true,
        invalid: true,
        error: error46
      };
    }
  }
  async function doParseToolCall({
    toolCall,
    tools
  }) {
    const toolName = toolCall.toolName;
    const tool2 = tools[toolName];
    if (tool2 == null) {
      throw new NoSuchToolError({
        toolName: toolCall.toolName,
        availableTools: Object.keys(tools)
      });
    }
    const schema = asSchema(tool2.inputSchema);
    const parseResult = toolCall.input.trim() === "" ? await safeValidateTypes({ value: {}, schema }) : await safeParseJSON({ text: toolCall.input, schema });
    if (parseResult.success === false) {
      throw new InvalidToolInputError({
        toolName,
        toolInput: toolCall.input,
        cause: parseResult.error
      });
    }
    return tool2.type === "dynamic" ? {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input: parseResult.value,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata,
      dynamic: true
    } : {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName,
      input: parseResult.value,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata
    };
  }
  var DefaultStepResult = class {
    constructor({
      content,
      finishReason,
      usage,
      warnings,
      request,
      response,
      providerMetadata
    }) {
      this.content = content;
      this.finishReason = finishReason;
      this.usage = usage;
      this.warnings = warnings;
      this.request = request;
      this.response = response;
      this.providerMetadata = providerMetadata;
    }
    get text() {
      return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
    }
    get reasoning() {
      return this.content.filter((part) => part.type === "reasoning");
    }
    get reasoningText() {
      return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join("");
    }
    get files() {
      return this.content.filter((part) => part.type === "file").map((part) => part.file);
    }
    get sources() {
      return this.content.filter((part) => part.type === "source");
    }
    get toolCalls() {
      return this.content.filter((part) => part.type === "tool-call");
    }
    get staticToolCalls() {
      return this.toolCalls.filter(
        (toolCall) => toolCall.dynamic !== true
      );
    }
    get dynamicToolCalls() {
      return this.toolCalls.filter(
        (toolCall) => toolCall.dynamic === true
      );
    }
    get toolResults() {
      return this.content.filter((part) => part.type === "tool-result");
    }
    get staticToolResults() {
      return this.toolResults.filter(
        (toolResult) => toolResult.dynamic !== true
      );
    }
    get dynamicToolResults() {
      return this.toolResults.filter(
        (toolResult) => toolResult.dynamic === true
      );
    }
  };
  function stepCountIs(stepCount) {
    return ({ steps }) => steps.length === stepCount;
  }
  async function isStopConditionMet({
    stopConditions,
    steps
  }) {
    return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);
  }
  function createToolModelOutput({
    output,
    tool: tool2,
    errorMode
  }) {
    if (errorMode === "text") {
      return { type: "error-text", value: getErrorMessage(output) };
    } else if (errorMode === "json") {
      return { type: "error-json", value: toJSONValue(output) };
    }
    if (tool2 == null ? void 0 : tool2.toModelOutput) {
      return tool2.toModelOutput(output);
    }
    return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
  }
  function toJSONValue(value) {
    return value === void 0 ? null : value;
  }
  function toResponseMessages({
    content: inputContent,
    tools
  }) {
    const responseMessages = [];
    const content = inputContent.filter((part) => part.type !== "source").filter(
      (part) => (part.type !== "tool-result" || part.providerExecuted) && (part.type !== "tool-error" || part.providerExecuted)
    ).filter((part) => part.type !== "text" || part.text.length > 0).map((part) => {
      switch (part.type) {
        case "text":
          return {
            type: "text",
            text: part.text,
            providerOptions: part.providerMetadata
          };
        case "reasoning":
          return {
            type: "reasoning",
            text: part.text,
            providerOptions: part.providerMetadata
          };
        case "file":
          return {
            type: "file",
            data: part.file.base64,
            mediaType: part.file.mediaType,
            providerOptions: part.providerMetadata
          };
        case "tool-call":
          return {
            type: "tool-call",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: part.input,
            providerExecuted: part.providerExecuted,
            providerOptions: part.providerMetadata
          };
        case "tool-result":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools == null ? void 0 : tools[part.toolName],
              output: part.output,
              errorMode: "none"
            }),
            providerExecuted: true,
            providerOptions: part.providerMetadata
          };
        case "tool-error":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools == null ? void 0 : tools[part.toolName],
              output: part.error,
              errorMode: "json"
            }),
            providerOptions: part.providerMetadata
          };
      }
    });
    if (content.length > 0) {
      responseMessages.push({
        role: "assistant",
        content
      });
    }
    const toolResultContent = inputContent.filter((part) => part.type === "tool-result" || part.type === "tool-error").filter((part) => !part.providerExecuted).map((toolResult) => ({
      type: "tool-result",
      toolCallId: toolResult.toolCallId,
      toolName: toolResult.toolName,
      output: createToolModelOutput({
        tool: tools == null ? void 0 : tools[toolResult.toolName],
        output: toolResult.type === "tool-result" ? toolResult.output : toolResult.error,
        errorMode: toolResult.type === "tool-error" ? "text" : "none"
      }),
      ...toolResult.providerMetadata != null ? { providerOptions: toolResult.providerMetadata } : {}
    }));
    if (toolResultContent.length > 0) {
      responseMessages.push({
        role: "tool",
        content: toolResultContent
      });
    }
    return responseMessages;
  }
  var originalGenerateId = createIdGenerator({
    prefix: "aitxt",
    size: 24
  });
  function prepareHeaders(headers, defaultHeaders) {
    const responseHeaders = new Headers(headers != null ? headers : {});
    for (const [key, value] of Object.entries(defaultHeaders)) {
      if (!responseHeaders.has(key)) {
        responseHeaders.set(key, value);
      }
    }
    return responseHeaders;
  }
  function createTextStreamResponse({
    status,
    statusText,
    headers,
    textStream
  }) {
    return new Response(textStream.pipeThrough(new TextEncoderStream()), {
      status: status != null ? status : 200,
      statusText,
      headers: prepareHeaders(headers, {
        "content-type": "text/plain; charset=utf-8"
      })
    });
  }
  function writeToServerResponse({
    response,
    status,
    statusText,
    headers,
    stream
  }) {
    response.writeHead(status != null ? status : 200, statusText, headers);
    const reader = stream.getReader();
    const read = async () => {
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          const canContinue = response.write(value);
          if (!canContinue) {
            await new Promise((resolve2) => {
              response.once("drain", resolve2);
            });
          }
        }
      } catch (error46) {
        throw error46;
      } finally {
        response.end();
      }
    };
    read();
  }
  function pipeTextStreamToResponse({
    response,
    status,
    statusText,
    headers,
    textStream
  }) {
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: Object.fromEntries(
        prepareHeaders(headers, {
          "content-type": "text/plain; charset=utf-8"
        }).entries()
      ),
      stream: textStream.pipeThrough(new TextEncoderStream())
    });
  }
  var JsonToSseTransformStream = class extends TransformStream {
    constructor() {
      super({
        transform(part, controller) {
          controller.enqueue(`data: ${JSON.stringify(part)}

`);
        },
        flush(controller) {
          controller.enqueue("data: [DONE]\n\n");
        }
      });
    }
  };
  var UI_MESSAGE_STREAM_HEADERS = {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-vercel-ai-ui-message-stream": "v1",
    "x-accel-buffering": "no"
    // disable nginx buffering
  };
  function createUIMessageStreamResponse({
    status,
    statusText,
    headers,
    stream,
    consumeSseStream
  }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
      const [stream1, stream2] = sseStream.tee();
      sseStream = stream1;
      consumeSseStream({ stream: stream2 });
    }
    return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
      status,
      statusText,
      headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
    });
  }
  function getResponseUIMessageId({
    originalMessages,
    responseMessageId
  }) {
    if (originalMessages == null) {
      return void 0;
    }
    const lastMessage = originalMessages[originalMessages.length - 1];
    return (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
  }
  var uiMessageChunkSchema = lazyValidator(
    () => zodSchema(
      external_exports.union([
        external_exports.strictObject({
          type: external_exports.literal("text-start"),
          id: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("text-delta"),
          id: external_exports.string(),
          delta: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("text-end"),
          id: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("error"),
          errorText: external_exports.string()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-input-start"),
          toolCallId: external_exports.string(),
          toolName: external_exports.string(),
          providerExecuted: external_exports.boolean().optional(),
          dynamic: external_exports.boolean().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-input-delta"),
          toolCallId: external_exports.string(),
          inputTextDelta: external_exports.string()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-input-available"),
          toolCallId: external_exports.string(),
          toolName: external_exports.string(),
          input: external_exports.unknown(),
          providerExecuted: external_exports.boolean().optional(),
          providerMetadata: providerMetadataSchema.optional(),
          dynamic: external_exports.boolean().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-input-error"),
          toolCallId: external_exports.string(),
          toolName: external_exports.string(),
          input: external_exports.unknown(),
          providerExecuted: external_exports.boolean().optional(),
          providerMetadata: providerMetadataSchema.optional(),
          dynamic: external_exports.boolean().optional(),
          errorText: external_exports.string()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-output-available"),
          toolCallId: external_exports.string(),
          output: external_exports.unknown(),
          providerExecuted: external_exports.boolean().optional(),
          dynamic: external_exports.boolean().optional(),
          preliminary: external_exports.boolean().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("tool-output-error"),
          toolCallId: external_exports.string(),
          errorText: external_exports.string(),
          providerExecuted: external_exports.boolean().optional(),
          dynamic: external_exports.boolean().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("reasoning-start"),
          id: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("reasoning-delta"),
          id: external_exports.string(),
          delta: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("reasoning-end"),
          id: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("source-url"),
          sourceId: external_exports.string(),
          url: external_exports.string(),
          title: external_exports.string().optional(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("source-document"),
          sourceId: external_exports.string(),
          mediaType: external_exports.string(),
          title: external_exports.string(),
          filename: external_exports.string().optional(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("file"),
          url: external_exports.string(),
          mediaType: external_exports.string(),
          providerMetadata: providerMetadataSchema.optional()
        }),
        external_exports.strictObject({
          type: external_exports.custom(
            (value) => typeof value === "string" && value.startsWith("data-"),
            { message: 'Type must start with "data-"' }
          ),
          id: external_exports.string().optional(),
          data: external_exports.unknown(),
          transient: external_exports.boolean().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("start-step")
        }),
        external_exports.strictObject({
          type: external_exports.literal("finish-step")
        }),
        external_exports.strictObject({
          type: external_exports.literal("start"),
          messageId: external_exports.string().optional(),
          messageMetadata: external_exports.unknown().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("finish"),
          finishReason: external_exports.enum([
            "stop",
            "length",
            "content-filter",
            "tool-calls",
            "error",
            "other",
            "unknown"
          ]).optional(),
          messageMetadata: external_exports.unknown().optional()
        }),
        external_exports.strictObject({
          type: external_exports.literal("abort")
        }),
        external_exports.strictObject({
          type: external_exports.literal("message-metadata"),
          messageMetadata: external_exports.unknown()
        })
      ])
    )
  );
  function isDataUIMessageChunk(chunk) {
    return chunk.type.startsWith("data-");
  }
  function mergeObjects(base, overrides) {
    if (base === void 0 && overrides === void 0) {
      return void 0;
    }
    if (base === void 0) {
      return overrides;
    }
    if (overrides === void 0) {
      return base;
    }
    const result = { ...base };
    for (const key in overrides) {
      if (Object.prototype.hasOwnProperty.call(overrides, key)) {
        const overridesValue = overrides[key];
        if (overridesValue === void 0)
          continue;
        const baseValue = key in base ? base[key] : void 0;
        const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
        const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
        if (isSourceObject && isTargetObject) {
          result[key] = mergeObjects(
            baseValue,
            overridesValue
          );
        } else {
          result[key] = overridesValue;
        }
      }
    }
    return result;
  }
  function fixJson(input) {
    const stack = ["ROOT"];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
      {
        switch (char) {
          case '"': {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_STRING");
            break;
          }
          case "f":
          case "t":
          case "n": {
            lastValidIndex = i;
            literalStart = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_LITERAL");
            break;
          }
          case "-": {
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "{": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_OBJECT_START");
            break;
          }
          case "[": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_ARRAY_START");
            break;
          }
        }
      }
    }
    function processAfterObjectValue(char, i) {
      switch (char) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_OBJECT_AFTER_COMMA");
          break;
        }
        case "}": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    function processAfterArrayValue(char, i) {
      switch (char) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_ARRAY_AFTER_COMMA");
          break;
        }
        case "]": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      const currentState = stack[stack.length - 1];
      switch (currentState) {
        case "ROOT":
          processValueStart(char, i, "FINISH");
          break;
        case "INSIDE_OBJECT_START": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
            case "}": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_COMMA": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_KEY": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_AFTER_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_KEY": {
          switch (char) {
            case ":": {
              stack.pop();
              stack.push("INSIDE_OBJECT_BEFORE_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_BEFORE_VALUE": {
          processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
          break;
        }
        case "INSIDE_OBJECT_AFTER_VALUE": {
          processAfterObjectValue(char, i);
          break;
        }
        case "INSIDE_STRING": {
          switch (char) {
            case '"': {
              stack.pop();
              lastValidIndex = i;
              break;
            }
            case "\\": {
              stack.push("INSIDE_STRING_ESCAPE");
              break;
            }
            default: {
              lastValidIndex = i;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_START": {
          switch (char) {
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_VALUE": {
          switch (char) {
            case ",": {
              stack.pop();
              stack.push("INSIDE_ARRAY_AFTER_COMMA");
              break;
            }
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_COMMA": {
          processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
          break;
        }
        case "INSIDE_STRING_ESCAPE": {
          stack.pop();
          lastValidIndex = i;
          break;
        }
        case "INSIDE_NUMBER": {
          switch (char) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9": {
              lastValidIndex = i;
              break;
            }
            case "e":
            case "E":
            case "-":
            case ".": {
              break;
            }
            case ",": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char, i);
              }
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char, i);
              }
              break;
            }
            case "}": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char, i);
              }
              break;
            }
            case "]": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char, i);
              }
              break;
            }
            default: {
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, i + 1);
          if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
          } else {
            lastValidIndex = i;
          }
          break;
        }
      }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for (let i = stack.length - 1; i >= 0; i--) {
      const state = stack[i];
      switch (state) {
        case "INSIDE_STRING": {
          result += '"';
          break;
        }
        case "INSIDE_OBJECT_KEY":
        case "INSIDE_OBJECT_AFTER_KEY":
        case "INSIDE_OBJECT_AFTER_COMMA":
        case "INSIDE_OBJECT_START":
        case "INSIDE_OBJECT_BEFORE_VALUE":
        case "INSIDE_OBJECT_AFTER_VALUE": {
          result += "}";
          break;
        }
        case "INSIDE_ARRAY_START":
        case "INSIDE_ARRAY_AFTER_COMMA":
        case "INSIDE_ARRAY_AFTER_VALUE": {
          result += "]";
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, input.length);
          if ("true".startsWith(partialLiteral)) {
            result += "true".slice(partialLiteral.length);
          } else if ("false".startsWith(partialLiteral)) {
            result += "false".slice(partialLiteral.length);
          } else if ("null".startsWith(partialLiteral)) {
            result += "null".slice(partialLiteral.length);
          }
        }
      }
    }
    return result;
  }
  async function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
      return { value: void 0, state: "undefined-input" };
    }
    let result = await safeParseJSON({ text: jsonText });
    if (result.success) {
      return { value: result.value, state: "successful-parse" };
    }
    result = await safeParseJSON({ text: fixJson(jsonText) });
    if (result.success) {
      return { value: result.value, state: "repaired-parse" };
    }
    return { value: void 0, state: "failed-parse" };
  }
  function isToolUIPart(part) {
    return part.type.startsWith("tool-");
  }
  function getToolName(part) {
    return part.type.split("-").slice(1).join("-");
  }
  function createStreamingUIMessageState({
    lastMessage,
    messageId
  }) {
    return {
      message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
        id: messageId,
        metadata: void 0,
        role: "assistant",
        parts: []
      },
      activeTextParts: {},
      activeReasoningParts: {},
      partialToolCalls: {}
    };
  }
  function processUIMessageStream({
    stream,
    messageMetadataSchema,
    dataPartSchemas,
    runUpdateMessageJob,
    onError,
    onToolCall,
    onData
  }) {
    return stream.pipeThrough(
      new TransformStream({
        async transform(chunk, controller) {
          await runUpdateMessageJob(async ({ state, write }) => {
            var _a162, _b8, _c, _d;
            function getToolInvocation(toolCallId) {
              const toolInvocations = state.message.parts.filter(isToolUIPart);
              const toolInvocation = toolInvocations.find(
                (invocation) => invocation.toolCallId === toolCallId
              );
              if (toolInvocation == null) {
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              }
              return toolInvocation;
            }
            function getDynamicToolInvocation(toolCallId) {
              const toolInvocations = state.message.parts.filter(
                (part) => part.type === "dynamic-tool"
              );
              const toolInvocation = toolInvocations.find(
                (invocation) => invocation.toolCallId === toolCallId
              );
              if (toolInvocation == null) {
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              }
              return toolInvocation;
            }
            function updateToolPart(options) {
              var _a17;
              const part = state.message.parts.find(
                (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId
              );
              const anyOptions = options;
              const anyPart = part;
              if (part != null) {
                part.state = options.state;
                anyPart.input = anyOptions.input;
                anyPart.output = anyOptions.output;
                anyPart.errorText = anyOptions.errorText;
                anyPart.rawInput = anyOptions.rawInput;
                anyPart.preliminary = anyOptions.preliminary;
                anyPart.providerExecuted = (_a17 = anyOptions.providerExecuted) != null ? _a17 : part.providerExecuted;
                if (anyOptions.providerMetadata != null && part.state === "input-available") {
                  part.callProviderMetadata = anyOptions.providerMetadata;
                }
              } else {
                state.message.parts.push({
                  type: `tool-${options.toolName}`,
                  toolCallId: options.toolCallId,
                  state: options.state,
                  input: anyOptions.input,
                  output: anyOptions.output,
                  rawInput: anyOptions.rawInput,
                  errorText: anyOptions.errorText,
                  providerExecuted: anyOptions.providerExecuted,
                  preliminary: anyOptions.preliminary,
                  ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
                });
              }
            }
            function updateDynamicToolPart(options) {
              var _a17, _b22;
              const part = state.message.parts.find(
                (part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId
              );
              const anyOptions = options;
              const anyPart = part;
              if (part != null) {
                part.state = options.state;
                anyPart.toolName = options.toolName;
                anyPart.input = anyOptions.input;
                anyPart.output = anyOptions.output;
                anyPart.errorText = anyOptions.errorText;
                anyPart.rawInput = (_a17 = anyOptions.rawInput) != null ? _a17 : anyPart.rawInput;
                anyPart.preliminary = anyOptions.preliminary;
                anyPart.providerExecuted = (_b22 = anyOptions.providerExecuted) != null ? _b22 : part.providerExecuted;
                if (anyOptions.providerMetadata != null && part.state === "input-available") {
                  part.callProviderMetadata = anyOptions.providerMetadata;
                }
              } else {
                state.message.parts.push({
                  type: "dynamic-tool",
                  toolName: options.toolName,
                  toolCallId: options.toolCallId,
                  state: options.state,
                  input: anyOptions.input,
                  output: anyOptions.output,
                  errorText: anyOptions.errorText,
                  preliminary: anyOptions.preliminary,
                  providerExecuted: anyOptions.providerExecuted,
                  ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
                });
              }
            }
            async function updateMessageMetadata(metadata) {
              if (metadata != null) {
                const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
                if (messageMetadataSchema != null) {
                  await validateTypes({
                    value: mergedMetadata,
                    schema: messageMetadataSchema
                  });
                }
                state.message.metadata = mergedMetadata;
              }
            }
            switch (chunk.type) {
              case "text-start": {
                const textPart = {
                  type: "text",
                  text: "",
                  providerMetadata: chunk.providerMetadata,
                  state: "streaming"
                };
                state.activeTextParts[chunk.id] = textPart;
                state.message.parts.push(textPart);
                write();
                break;
              }
              case "text-delta": {
                const textPart = state.activeTextParts[chunk.id];
                textPart.text += chunk.delta;
                textPart.providerMetadata = (_a162 = chunk.providerMetadata) != null ? _a162 : textPart.providerMetadata;
                write();
                break;
              }
              case "text-end": {
                const textPart = state.activeTextParts[chunk.id];
                textPart.state = "done";
                textPart.providerMetadata = (_b8 = chunk.providerMetadata) != null ? _b8 : textPart.providerMetadata;
                delete state.activeTextParts[chunk.id];
                write();
                break;
              }
              case "reasoning-start": {
                const reasoningPart = {
                  type: "reasoning",
                  text: "",
                  providerMetadata: chunk.providerMetadata,
                  state: "streaming"
                };
                state.activeReasoningParts[chunk.id] = reasoningPart;
                state.message.parts.push(reasoningPart);
                write();
                break;
              }
              case "reasoning-delta": {
                const reasoningPart = state.activeReasoningParts[chunk.id];
                reasoningPart.text += chunk.delta;
                reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;
                write();
                break;
              }
              case "reasoning-end": {
                const reasoningPart = state.activeReasoningParts[chunk.id];
                reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;
                reasoningPart.state = "done";
                delete state.activeReasoningParts[chunk.id];
                write();
                break;
              }
              case "file": {
                state.message.parts.push({
                  type: "file",
                  mediaType: chunk.mediaType,
                  url: chunk.url
                });
                write();
                break;
              }
              case "source-url": {
                state.message.parts.push({
                  type: "source-url",
                  sourceId: chunk.sourceId,
                  url: chunk.url,
                  title: chunk.title,
                  providerMetadata: chunk.providerMetadata
                });
                write();
                break;
              }
              case "source-document": {
                state.message.parts.push({
                  type: "source-document",
                  sourceId: chunk.sourceId,
                  mediaType: chunk.mediaType,
                  title: chunk.title,
                  filename: chunk.filename,
                  providerMetadata: chunk.providerMetadata
                });
                write();
                break;
              }
              case "tool-input-start": {
                const toolInvocations = state.message.parts.filter(isToolUIPart);
                state.partialToolCalls[chunk.toolCallId] = {
                  text: "",
                  toolName: chunk.toolName,
                  index: toolInvocations.length,
                  dynamic: chunk.dynamic
                };
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-streaming",
                    input: void 0,
                    providerExecuted: chunk.providerExecuted
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-streaming",
                    input: void 0,
                    providerExecuted: chunk.providerExecuted
                  });
                }
                write();
                break;
              }
              case "tool-input-delta": {
                const partialToolCall = state.partialToolCalls[chunk.toolCallId];
                partialToolCall.text += chunk.inputTextDelta;
                const { value: partialArgs } = await parsePartialJson(
                  partialToolCall.text
                );
                if (partialToolCall.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                }
                write();
                break;
              }
              case "tool-input-available": {
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-available",
                    input: chunk.input,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-available",
                    input: chunk.input,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                }
                write();
                if (onToolCall && !chunk.providerExecuted) {
                  await onToolCall({
                    toolCall: chunk
                  });
                }
                break;
              }
              case "tool-input-error": {
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "output-error",
                    input: chunk.input,
                    errorText: chunk.errorText,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "output-error",
                    input: void 0,
                    rawInput: chunk.input,
                    errorText: chunk.errorText,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                }
                write();
                break;
              }
              case "tool-output-available": {
                if (chunk.dynamic) {
                  const toolInvocation = getDynamicToolInvocation(
                    chunk.toolCallId
                  );
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: toolInvocation.toolName,
                    state: "output-available",
                    input: toolInvocation.input,
                    output: chunk.output,
                    preliminary: chunk.preliminary
                  });
                } else {
                  const toolInvocation = getToolInvocation(chunk.toolCallId);
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: getToolName(toolInvocation),
                    state: "output-available",
                    input: toolInvocation.input,
                    output: chunk.output,
                    providerExecuted: chunk.providerExecuted,
                    preliminary: chunk.preliminary
                  });
                }
                write();
                break;
              }
              case "tool-output-error": {
                if (chunk.dynamic) {
                  const toolInvocation = getDynamicToolInvocation(
                    chunk.toolCallId
                  );
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: toolInvocation.toolName,
                    state: "output-error",
                    input: toolInvocation.input,
                    errorText: chunk.errorText,
                    providerExecuted: chunk.providerExecuted
                  });
                } else {
                  const toolInvocation = getToolInvocation(chunk.toolCallId);
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: getToolName(toolInvocation),
                    state: "output-error",
                    input: toolInvocation.input,
                    rawInput: toolInvocation.rawInput,
                    errorText: chunk.errorText,
                    providerExecuted: chunk.providerExecuted
                  });
                }
                write();
                break;
              }
              case "start-step": {
                state.message.parts.push({ type: "step-start" });
                break;
              }
              case "finish-step": {
                state.activeTextParts = {};
                state.activeReasoningParts = {};
                break;
              }
              case "start": {
                if (chunk.messageId != null) {
                  state.message.id = chunk.messageId;
                }
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageId != null || chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "finish": {
                if (chunk.finishReason != null) {
                  state.finishReason = chunk.finishReason;
                }
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "message-metadata": {
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "error": {
                onError == null ? void 0 : onError(new Error(chunk.errorText));
                break;
              }
              default: {
                if (isDataUIMessageChunk(chunk)) {
                  if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                    await validateTypes({
                      value: chunk.data,
                      schema: dataPartSchemas[chunk.type]
                    });
                  }
                  const dataChunk = chunk;
                  if (dataChunk.transient) {
                    onData == null ? void 0 : onData(dataChunk);
                    break;
                  }
                  const existingUIPart = dataChunk.id != null ? state.message.parts.find(
                    (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id
                  ) : void 0;
                  if (existingUIPart != null) {
                    existingUIPart.data = dataChunk.data;
                  } else {
                    state.message.parts.push(dataChunk);
                  }
                  onData == null ? void 0 : onData(dataChunk);
                  write();
                }
              }
            }
            controller.enqueue(chunk);
          });
        }
      })
    );
  }
  function handleUIMessageStreamFinish({
    messageId,
    originalMessages = [],
    onFinish,
    onError,
    stream
  }) {
    let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
    if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
      lastMessage = void 0;
    } else {
      messageId = lastMessage.id;
    }
    let isAborted2 = false;
    const idInjectedStream = stream.pipeThrough(
      new TransformStream({
        transform(chunk, controller) {
          if (chunk.type === "start") {
            const startChunk = chunk;
            if (startChunk.messageId == null && messageId != null) {
              startChunk.messageId = messageId;
            }
          }
          if (chunk.type === "abort") {
            isAborted2 = true;
          }
          controller.enqueue(chunk);
        }
      })
    );
    if (onFinish == null) {
      return idInjectedStream;
    }
    const state = createStreamingUIMessageState({
      lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
      messageId: messageId != null ? messageId : ""
      // will be overridden by the stream
    });
    const runUpdateMessageJob = async (job) => {
      await job({ state, write: () => {
      } });
    };
    let finishCalled = false;
    const callOnFinish = async () => {
      if (finishCalled || !onFinish) {
        return;
      }
      finishCalled = true;
      const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
      await onFinish({
        isAborted: isAborted2,
        isContinuation,
        responseMessage: state.message,
        messages: [
          ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
          state.message
        ],
        finishReason: state.finishReason
      });
    };
    return processUIMessageStream({
      stream: idInjectedStream,
      runUpdateMessageJob,
      onError
    }).pipeThrough(
      new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
        },
        // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
        async cancel() {
          await callOnFinish();
        },
        async flush() {
          await callOnFinish();
        }
      })
    );
  }
  function pipeUIMessageStreamToResponse({
    response,
    status,
    statusText,
    headers,
    stream,
    consumeSseStream
  }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
      const [stream1, stream2] = sseStream.tee();
      sseStream = stream1;
      consumeSseStream({ stream: stream2 });
    }
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: Object.fromEntries(
        prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()
      ),
      stream: sseStream.pipeThrough(new TextEncoderStream())
    });
  }
  function createAsyncIterableStream(source) {
    const stream = source.pipeThrough(new TransformStream());
    stream[Symbol.asyncIterator] = function() {
      const reader = this.getReader();
      let finished = false;
      async function cleanup(cancelStream) {
        var _a162;
        finished = true;
        try {
          if (cancelStream) {
            await ((_a162 = reader.cancel) == null ? void 0 : _a162.call(reader));
          }
        } finally {
          try {
            reader.releaseLock();
          } catch (e) {
          }
        }
      }
      return {
        /**
         * Reads the next chunk from the stream.
         * @returns A promise resolving to the next IteratorResult.
         */
        async next() {
          if (finished) {
            return { done: true, value: void 0 };
          }
          const { done, value } = await reader.read();
          if (done) {
            await cleanup(true);
            return { done: true, value: void 0 };
          }
          return { done: false, value };
        },
        /**
         * Called on early exit (e.g., break from for-await).
         * Ensures the stream is cancelled and resources are released.
         * @returns A promise resolving to a completed IteratorResult.
         */
        async return() {
          await cleanup(true);
          return { done: true, value: void 0 };
        },
        /**
         * Called on early exit with error.
         * Ensures the stream is cancelled and resources are released, then rethrows the error.
         * @param err The error to throw.
         * @returns A promise that rejects with the provided error.
         */
        async throw(err) {
          await cleanup(true);
          throw err;
        }
      };
    };
    return stream;
  }
  async function consumeStream({
    stream,
    onError
  }) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done } = await reader.read();
        if (done)
          break;
      }
    } catch (error46) {
      onError == null ? void 0 : onError(error46);
    } finally {
      reader.releaseLock();
    }
  }
  function createResolvablePromise() {
    let resolve2;
    let reject;
    const promise2 = new Promise((res, rej) => {
      resolve2 = res;
      reject = rej;
    });
    return {
      promise: promise2,
      resolve: resolve2,
      reject
    };
  }
  function createStitchableStream() {
    let innerStreamReaders = [];
    let controller = null;
    let isClosed = false;
    let waitForNewStream = createResolvablePromise();
    const terminate = () => {
      isClosed = true;
      waitForNewStream.resolve();
      innerStreamReaders.forEach((reader) => reader.cancel());
      innerStreamReaders = [];
      controller == null ? void 0 : controller.close();
    };
    const processPull = async () => {
      if (isClosed && innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
        return;
      }
      if (innerStreamReaders.length === 0) {
        waitForNewStream = createResolvablePromise();
        await waitForNewStream.promise;
        return processPull();
      }
      try {
        const { value, done } = await innerStreamReaders[0].read();
        if (done) {
          innerStreamReaders.shift();
          if (innerStreamReaders.length > 0) {
            await processPull();
          } else if (isClosed) {
            controller == null ? void 0 : controller.close();
          }
        } else {
          controller == null ? void 0 : controller.enqueue(value);
        }
      } catch (error46) {
        controller == null ? void 0 : controller.error(error46);
        innerStreamReaders.shift();
        terminate();
      }
    };
    return {
      stream: new ReadableStream({
        start(controllerParam) {
          controller = controllerParam;
        },
        pull: processPull,
        async cancel() {
          for (const reader of innerStreamReaders) {
            await reader.cancel();
          }
          innerStreamReaders = [];
          isClosed = true;
        }
      }),
      addStream: (innerStream) => {
        if (isClosed) {
          throw new Error("Cannot add inner stream: outer stream is closed");
        }
        innerStreamReaders.push(innerStream.getReader());
        waitForNewStream.resolve();
      },
      /**
       * Gracefully close the outer stream. This will let the inner streams
       * finish processing and then close the outer stream.
       */
      close: () => {
        isClosed = true;
        waitForNewStream.resolve();
        if (innerStreamReaders.length === 0) {
          controller == null ? void 0 : controller.close();
        }
      },
      /**
       * Immediately close the outer stream. This will cancel all inner streams
       * and close the outer stream.
       */
      terminate
    };
  }
  var DelayedPromise = class {
    constructor() {
      this.status = { type: "pending" };
      this._resolve = void 0;
      this._reject = void 0;
    }
    get promise() {
      if (this._promise) {
        return this._promise;
      }
      this._promise = new Promise((resolve2, reject) => {
        if (this.status.type === "resolved") {
          resolve2(this.status.value);
        } else if (this.status.type === "rejected") {
          reject(this.status.error);
        }
        this._resolve = resolve2;
        this._reject = reject;
      });
      return this._promise;
    }
    resolve(value) {
      var _a162;
      this.status = { type: "resolved", value };
      if (this._promise) {
        (_a162 = this._resolve) == null ? void 0 : _a162.call(this, value);
      }
    }
    reject(error46) {
      var _a162;
      this.status = { type: "rejected", error: error46 };
      if (this._promise) {
        (_a162 = this._reject) == null ? void 0 : _a162.call(this, error46);
      }
    }
  };
  function now() {
    var _a162, _b8;
    return (_b8 = (_a162 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a162.now()) != null ? _b8 : Date.now();
  }
  function runToolsTransformation({
    tools,
    generatorStream,
    tracer,
    telemetry,
    system,
    messages,
    abortSignal,
    repairToolCall,
    experimental_context
  }) {
    let toolResultsStreamController = null;
    const toolResultsStream = new ReadableStream({
      start(controller) {
        toolResultsStreamController = controller;
      }
    });
    const outstandingToolResults = /* @__PURE__ */ new Set();
    const toolInputs = /* @__PURE__ */ new Map();
    let canClose = false;
    let finishChunk = void 0;
    function attemptClose() {
      if (canClose && outstandingToolResults.size === 0) {
        if (finishChunk != null) {
          toolResultsStreamController.enqueue(finishChunk);
        }
        toolResultsStreamController.close();
      }
    }
    const forwardStream = new TransformStream({
      async transform(chunk, controller) {
        const chunkType = chunk.type;
        switch (chunkType) {
          case "stream-start":
          case "text-start":
          case "text-delta":
          case "text-end":
          case "reasoning-start":
          case "reasoning-delta":
          case "reasoning-end":
          case "tool-input-start":
          case "tool-input-delta":
          case "tool-input-end":
          case "source":
          case "response-metadata":
          case "error":
          case "raw": {
            controller.enqueue(chunk);
            break;
          }
          case "file": {
            controller.enqueue({
              type: "file",
              file: new DefaultGeneratedFileWithType({
                data: chunk.data,
                mediaType: chunk.mediaType
              })
            });
            break;
          }
          case "finish": {
            finishChunk = {
              type: "finish",
              finishReason: chunk.finishReason,
              usage: chunk.usage,
              providerMetadata: chunk.providerMetadata
            };
            break;
          }
          case "tool-call": {
            try {
              const toolCall = await parseToolCall({
                toolCall: chunk,
                tools,
                repairToolCall,
                system,
                messages
              });
              controller.enqueue(toolCall);
              if (toolCall.invalid) {
                toolResultsStreamController.enqueue({
                  type: "tool-error",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  input: toolCall.input,
                  error: getErrorMessage2(toolCall.error),
                  dynamic: true
                });
                break;
              }
              const tool2 = tools[toolCall.toolName];
              toolInputs.set(toolCall.toolCallId, toolCall.input);
              if (tool2.onInputAvailable != null) {
                await tool2.onInputAvailable({
                  input: toolCall.input,
                  toolCallId: toolCall.toolCallId,
                  messages,
                  abortSignal,
                  experimental_context
                });
              }
              if (tool2.execute != null && toolCall.providerExecuted !== true) {
                const toolExecutionId = generateId();
                outstandingToolResults.add(toolExecutionId);
                recordSpan({
                  name: "ai.toolCall",
                  attributes: selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      ...assembleOperationName({
                        operationId: "ai.toolCall",
                        telemetry
                      }),
                      "ai.toolCall.name": toolCall.toolName,
                      "ai.toolCall.id": toolCall.toolCallId,
                      "ai.toolCall.args": {
                        output: () => JSON.stringify(toolCall.input)
                      }
                    }
                  }),
                  tracer,
                  fn: async (span) => {
                    let output;
                    try {
                      const stream = executeTool({
                        execute: tool2.execute.bind(tool2),
                        input: toolCall.input,
                        options: {
                          toolCallId: toolCall.toolCallId,
                          messages,
                          abortSignal,
                          experimental_context
                        }
                      });
                      for await (const part of stream) {
                        toolResultsStreamController.enqueue({
                          ...toolCall,
                          type: "tool-result",
                          output: part.output,
                          ...part.type === "preliminary" && {
                            preliminary: true
                          }
                        });
                        if (part.type === "final") {
                          output = part.output;
                        }
                      }
                    } catch (error46) {
                      recordErrorOnSpan(span, error46);
                      toolResultsStreamController.enqueue({
                        ...toolCall,
                        type: "tool-error",
                        error: error46
                      });
                      outstandingToolResults.delete(toolExecutionId);
                      attemptClose();
                      return;
                    }
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                    try {
                      span.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.toolCall.result": {
                              output: () => JSON.stringify(output)
                            }
                          }
                        })
                      );
                    } catch (ignored) {
                    }
                  }
                });
              }
            } catch (error46) {
              toolResultsStreamController.enqueue({ type: "error", error: error46 });
            }
            break;
          }
          case "tool-result": {
            const toolName = chunk.toolName;
            if (chunk.isError) {
              toolResultsStreamController.enqueue({
                type: "tool-error",
                toolCallId: chunk.toolCallId,
                toolName,
                input: toolInputs.get(chunk.toolCallId),
                providerExecuted: chunk.providerExecuted,
                error: chunk.result
              });
            } else {
              controller.enqueue({
                type: "tool-result",
                toolCallId: chunk.toolCallId,
                toolName,
                input: toolInputs.get(chunk.toolCallId),
                output: chunk.result,
                providerExecuted: chunk.providerExecuted
              });
            }
            break;
          }
          default: {
            const _exhaustiveCheck = chunkType;
            throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
          }
        }
      },
      flush() {
        canClose = true;
        attemptClose();
      }
    });
    return new ReadableStream({
      async start(controller) {
        return Promise.all([
          generatorStream.pipeThrough(forwardStream).pipeTo(
            new WritableStream({
              write(chunk) {
                controller.enqueue(chunk);
              },
              close() {
              }
            })
          ),
          toolResultsStream.pipeTo(
            new WritableStream({
              write(chunk) {
                controller.enqueue(chunk);
              },
              close() {
                controller.close();
              }
            })
          )
        ]);
      }
    });
  }
  var originalGenerateId2 = createIdGenerator({
    prefix: "aitxt",
    size: 24
  });
  function streamText({
    model,
    tools,
    toolChoice,
    system,
    prompt,
    messages,
    maxRetries,
    abortSignal,
    headers,
    stopWhen = stepCountIs(1),
    experimental_output: output,
    experimental_telemetry: telemetry,
    prepareStep,
    providerOptions,
    experimental_activeTools,
    activeTools = experimental_activeTools,
    experimental_repairToolCall: repairToolCall,
    experimental_transform: transform2,
    experimental_download: download2,
    includeRawChunks = false,
    onChunk,
    onError = ({ error: error46 }) => {
      console.error(error46);
    },
    onFinish,
    onAbort,
    onStepFinish,
    experimental_context,
    _internal: {
      now: now2 = now,
      generateId: generateId3 = originalGenerateId2,
      currentDate = () => /* @__PURE__ */ new Date()
    } = {},
    ...settings
  }) {
    return new DefaultStreamTextResult({
      model: resolveLanguageModel(model),
      telemetry,
      headers,
      settings,
      maxRetries,
      abortSignal,
      system,
      prompt,
      messages,
      tools,
      toolChoice,
      transforms: asArray(transform2),
      activeTools,
      repairToolCall,
      stopConditions: asArray(stopWhen),
      output,
      providerOptions,
      prepareStep,
      includeRawChunks,
      onChunk,
      onError,
      onFinish,
      onAbort,
      onStepFinish,
      now: now2,
      currentDate,
      generateId: generateId3,
      experimental_context,
      download: download2
    });
  }
  function createOutputTransformStream(output) {
    if (!output) {
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
        }
      });
    }
    let firstTextChunkId = void 0;
    let text2 = "";
    let textChunk = "";
    let lastPublishedJson = "";
    function publishTextChunk({
      controller,
      partialOutput = void 0
    }) {
      controller.enqueue({
        part: {
          type: "text-delta",
          id: firstTextChunkId,
          text: textChunk
        },
        partialOutput
      });
      textChunk = "";
    }
    return new TransformStream({
      async transform(chunk, controller) {
        if (chunk.type === "finish-step" && textChunk.length > 0) {
          publishTextChunk({ controller });
        }
        if (chunk.type !== "text-delta" && chunk.type !== "text-start" && chunk.type !== "text-end") {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (firstTextChunkId == null) {
          firstTextChunkId = chunk.id;
        } else if (chunk.id !== firstTextChunkId) {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (chunk.type === "text-start") {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (chunk.type === "text-end") {
          if (textChunk.length > 0) {
            publishTextChunk({ controller });
          }
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        text2 += chunk.text;
        textChunk += chunk.text;
        const result = await output.parsePartial({ text: text2 });
        if (result != null) {
          const currentJson = JSON.stringify(result.partial);
          if (currentJson !== lastPublishedJson) {
            publishTextChunk({ controller, partialOutput: result.partial });
            lastPublishedJson = currentJson;
          }
        }
      }
    });
  }
  var DefaultStreamTextResult = class {
    constructor({
      model,
      telemetry,
      headers,
      settings,
      maxRetries: maxRetriesArg,
      abortSignal,
      system,
      prompt,
      messages,
      tools,
      toolChoice,
      transforms,
      activeTools,
      repairToolCall,
      stopConditions,
      output,
      providerOptions,
      prepareStep,
      includeRawChunks,
      now: now2,
      currentDate,
      generateId: generateId3,
      onChunk,
      onError,
      onFinish,
      onAbort,
      onStepFinish,
      experimental_context,
      download: download2
    }) {
      this._totalUsage = new DelayedPromise();
      this._finishReason = new DelayedPromise();
      this._steps = new DelayedPromise();
      this.output = output;
      this.includeRawChunks = includeRawChunks;
      this.tools = tools;
      let stepFinish;
      let recordedContent = [];
      const recordedResponseMessages = [];
      let recordedFinishReason = void 0;
      let recordedTotalUsage = void 0;
      let recordedRequest = {};
      let recordedWarnings = [];
      const recordedSteps = [];
      let rootSpan;
      let activeTextContent = {};
      let activeReasoningContent = {};
      const eventProcessor = new TransformStream({
        async transform(chunk, controller) {
          var _a162, _b8, _c, _d;
          controller.enqueue(chunk);
          const { part } = chunk;
          if (part.type === "text-delta" || part.type === "reasoning-delta" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-input-start" || part.type === "tool-input-delta" || part.type === "raw") {
            await (onChunk == null ? void 0 : onChunk({ chunk: part }));
          }
          if (part.type === "error") {
            await onError({ error: wrapGatewayError(part.error) });
          }
          if (part.type === "text-start") {
            activeTextContent[part.id] = {
              type: "text",
              text: "",
              providerMetadata: part.providerMetadata
            };
            recordedContent.push(activeTextContent[part.id]);
          }
          if (part.type === "text-delta") {
            const activeText = activeTextContent[part.id];
            if (activeText == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `text part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeText.text += part.text;
            activeText.providerMetadata = (_a162 = part.providerMetadata) != null ? _a162 : activeText.providerMetadata;
          }
          if (part.type === "text-end") {
            const activeText = activeTextContent[part.id];
            if (activeText == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `text part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeText.providerMetadata = (_b8 = part.providerMetadata) != null ? _b8 : activeText.providerMetadata;
            delete activeTextContent[part.id];
          }
          if (part.type === "reasoning-start") {
            activeReasoningContent[part.id] = {
              type: "reasoning",
              text: "",
              providerMetadata: part.providerMetadata
            };
            recordedContent.push(activeReasoningContent[part.id]);
          }
          if (part.type === "reasoning-delta") {
            const activeReasoning = activeReasoningContent[part.id];
            if (activeReasoning == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `reasoning part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeReasoning.text += part.text;
            activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;
          }
          if (part.type === "reasoning-end") {
            const activeReasoning = activeReasoningContent[part.id];
            if (activeReasoning == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `reasoning part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;
            delete activeReasoningContent[part.id];
          }
          if (part.type === "file") {
            recordedContent.push({ type: "file", file: part.file });
          }
          if (part.type === "source") {
            recordedContent.push(part);
          }
          if (part.type === "tool-call") {
            recordedContent.push(part);
          }
          if (part.type === "tool-result" && !part.preliminary) {
            recordedContent.push(part);
          }
          if (part.type === "tool-error") {
            recordedContent.push(part);
          }
          if (part.type === "start-step") {
            recordedRequest = part.request;
            recordedWarnings = part.warnings;
          }
          if (part.type === "finish-step") {
            const stepMessages = toResponseMessages({
              content: recordedContent,
              tools
            });
            const currentStepResult = new DefaultStepResult({
              content: recordedContent,
              finishReason: part.finishReason,
              usage: part.usage,
              warnings: recordedWarnings,
              request: recordedRequest,
              response: {
                ...part.response,
                messages: [...recordedResponseMessages, ...stepMessages]
              },
              providerMetadata: part.providerMetadata
            });
            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
            logWarnings(recordedWarnings);
            recordedSteps.push(currentStepResult);
            recordedContent = [];
            activeReasoningContent = {};
            activeTextContent = {};
            recordedResponseMessages.push(...stepMessages);
            stepFinish.resolve();
          }
          if (part.type === "finish") {
            recordedTotalUsage = part.totalUsage;
            recordedFinishReason = part.finishReason;
          }
        },
        async flush(controller) {
          try {
            if (recordedSteps.length === 0) {
              const error46 = new NoOutputGeneratedError({
                message: "No output generated. Check the stream for errors."
              });
              self2._finishReason.reject(error46);
              self2._totalUsage.reject(error46);
              self2._steps.reject(error46);
              return;
            }
            const finishReason = recordedFinishReason != null ? recordedFinishReason : "unknown";
            const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            self2._finishReason.resolve(finishReason);
            self2._totalUsage.resolve(totalUsage);
            self2._steps.resolve(recordedSteps);
            const finalStep = recordedSteps[recordedSteps.length - 1];
            await (onFinish == null ? void 0 : onFinish({
              finishReason,
              totalUsage,
              usage: finalStep.usage,
              content: finalStep.content,
              text: finalStep.text,
              reasoningText: finalStep.reasoningText,
              reasoning: finalStep.reasoning,
              files: finalStep.files,
              sources: finalStep.sources,
              toolCalls: finalStep.toolCalls,
              staticToolCalls: finalStep.staticToolCalls,
              dynamicToolCalls: finalStep.dynamicToolCalls,
              toolResults: finalStep.toolResults,
              staticToolResults: finalStep.staticToolResults,
              dynamicToolResults: finalStep.dynamicToolResults,
              request: finalStep.request,
              response: finalStep.response,
              warnings: finalStep.warnings,
              providerMetadata: finalStep.providerMetadata,
              steps: recordedSteps
            }));
            rootSpan.setAttributes(
              selectTelemetryAttributes({
                telemetry,
                attributes: {
                  "ai.response.finishReason": finishReason,
                  "ai.response.text": { output: () => finalStep.text },
                  "ai.response.toolCalls": {
                    output: () => {
                      var _a162;
                      return ((_a162 = finalStep.toolCalls) == null ? void 0 : _a162.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                    }
                  },
                  "ai.response.providerMetadata": JSON.stringify(
                    finalStep.providerMetadata
                  ),
                  "ai.usage.inputTokens": totalUsage.inputTokens,
                  "ai.usage.outputTokens": totalUsage.outputTokens,
                  "ai.usage.totalTokens": totalUsage.totalTokens,
                  "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                  "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
                }
              })
            );
          } catch (error46) {
            controller.error(error46);
          } finally {
            rootSpan.end();
          }
        }
      });
      const stitchableStream = createStitchableStream();
      this.addStream = stitchableStream.addStream;
      this.closeStream = stitchableStream.close;
      const reader = stitchableStream.stream.getReader();
      let stream = new ReadableStream({
        async start(controller) {
          controller.enqueue({ type: "start" });
        },
        async pull(controller) {
          function abort() {
            onAbort == null ? void 0 : onAbort({ steps: recordedSteps });
            controller.enqueue({ type: "abort" });
            controller.close();
          }
          try {
            const { done, value } = await reader.read();
            if (done) {
              controller.close();
              return;
            }
            if (abortSignal == null ? void 0 : abortSignal.aborted) {
              abort();
              return;
            }
            controller.enqueue(value);
          } catch (error46) {
            if (isAbortError(error46) && (abortSignal == null ? void 0 : abortSignal.aborted)) {
              abort();
            } else {
              controller.error(error46);
            }
          }
        },
        cancel(reason) {
          return stitchableStream.stream.cancel(reason);
        }
      });
      for (const transform2 of transforms) {
        stream = stream.pipeThrough(
          transform2({
            tools,
            stopStream() {
              stitchableStream.terminate();
            }
          })
        );
      }
      this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);
      const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg,
        abortSignal
      });
      const tracer = getTracer(telemetry);
      const callSettings = prepareCallSettings(settings);
      const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: { ...callSettings, maxRetries }
      });
      const self2 = this;
      recordSpan({
        name: "ai.streamText",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
            ...baseTelemetryAttributes,
            // specific settings that only make sense on the outer level:
            "ai.prompt": {
              input: () => JSON.stringify({ system, prompt, messages })
            }
          }
        }),
        tracer,
        endWhenDone: false,
        fn: async (rootSpanArg) => {
          rootSpan = rootSpanArg;
          async function streamStep({
            currentStep,
            responseMessages,
            usage
          }) {
            var _a162, _b8, _c, _d, _e;
            const includeRawChunks2 = self2.includeRawChunks;
            stepFinish = new DelayedPromise();
            const initialPrompt = await standardizePrompt({
              system,
              prompt,
              messages
            });
            const stepInputMessages = [
              ...initialPrompt.messages,
              ...responseMessages
            ];
            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps: recordedSteps,
              stepNumber: recordedSteps.length,
              messages: stepInputMessages
            }));
            const stepModel = resolveLanguageModel(
              (_a162 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a162 : model
            );
            const promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_b8 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b8 : initialPrompt.system,
                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
              },
              supportedUrls: await stepModel.supportedUrls,
              download: download2
            });
            const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
              tools,
              toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
              activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
            });
            const {
              result: { stream: stream2, response, request },
              doStreamSpan,
              startTimestampMs
            } = await retry(
              () => recordSpan({
                name: "ai.streamText.doStream",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.streamText.doStream",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // model:
                    "ai.model.provider": stepModel.provider,
                    "ai.model.id": stepModel.modelId,
                    // prompt:
                    "ai.prompt.messages": {
                      input: () => stringifyForTelemetry(promptMessages)
                    },
                    "ai.prompt.tools": {
                      // convert the language model level tools:
                      input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))
                    },
                    "ai.prompt.toolChoice": {
                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                    },
                    // standardized gen-ai llm span attributes:
                    "gen_ai.system": stepModel.provider,
                    "gen_ai.request.model": stepModel.modelId,
                    "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                    "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                    "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                    "gen_ai.request.stop_sequences": callSettings.stopSequences,
                    "gen_ai.request.temperature": callSettings.temperature,
                    "gen_ai.request.top_k": callSettings.topK,
                    "gen_ai.request.top_p": callSettings.topP
                  }
                }),
                tracer,
                endWhenDone: false,
                fn: async (doStreamSpan2) => {
                  return {
                    startTimestampMs: now2(),
                    // get before the call
                    doStreamSpan: doStreamSpan2,
                    result: await stepModel.doStream({
                      ...callSettings,
                      tools: stepTools,
                      toolChoice: stepToolChoice,
                      responseFormat: output == null ? void 0 : output.responseFormat,
                      prompt: promptMessages,
                      providerOptions,
                      abortSignal,
                      headers,
                      includeRawChunks: includeRawChunks2
                    })
                  };
                }
              })
            );
            const streamWithToolResults = runToolsTransformation({
              tools,
              generatorStream: stream2,
              tracer,
              telemetry,
              system,
              messages: stepInputMessages,
              repairToolCall,
              abortSignal,
              experimental_context
            });
            const stepRequest = request != null ? request : {};
            const stepToolCalls = [];
            const stepToolOutputs = [];
            let warnings;
            const activeToolCallToolNames = {};
            let stepFinishReason = "unknown";
            let stepUsage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let stepProviderMetadata;
            let stepFirstChunk = true;
            let stepResponse = {
              id: generateId3(),
              timestamp: currentDate(),
              modelId: model.modelId
            };
            let activeText = "";
            self2.addStream(
              streamWithToolResults.pipeThrough(
                new TransformStream({
                  async transform(chunk, controller) {
                    var _a17, _b22, _c2, _d2;
                    if (chunk.type === "stream-start") {
                      warnings = chunk.warnings;
                      return;
                    }
                    if (stepFirstChunk) {
                      const msToFirstChunk = now2() - startTimestampMs;
                      stepFirstChunk = false;
                      doStreamSpan.addEvent("ai.stream.firstChunk", {
                        "ai.response.msToFirstChunk": msToFirstChunk
                      });
                      doStreamSpan.setAttributes({
                        "ai.response.msToFirstChunk": msToFirstChunk
                      });
                      controller.enqueue({
                        type: "start-step",
                        request: stepRequest,
                        warnings: warnings != null ? warnings : []
                      });
                    }
                    const chunkType = chunk.type;
                    switch (chunkType) {
                      case "text-start":
                      case "text-end": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "text-delta": {
                        if (chunk.delta.length > 0) {
                          controller.enqueue({
                            type: "text-delta",
                            id: chunk.id,
                            text: chunk.delta,
                            providerMetadata: chunk.providerMetadata
                          });
                          activeText += chunk.delta;
                        }
                        break;
                      }
                      case "reasoning-start":
                      case "reasoning-end": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "reasoning-delta": {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: chunk.id,
                          text: chunk.delta,
                          providerMetadata: chunk.providerMetadata
                        });
                        break;
                      }
                      case "tool-call": {
                        controller.enqueue(chunk);
                        stepToolCalls.push(chunk);
                        break;
                      }
                      case "tool-result": {
                        controller.enqueue(chunk);
                        if (!chunk.preliminary) {
                          stepToolOutputs.push(chunk);
                        }
                        break;
                      }
                      case "tool-error": {
                        controller.enqueue(chunk);
                        stepToolOutputs.push(chunk);
                        break;
                      }
                      case "response-metadata": {
                        stepResponse = {
                          id: (_a17 = chunk.id) != null ? _a17 : stepResponse.id,
                          timestamp: (_b22 = chunk.timestamp) != null ? _b22 : stepResponse.timestamp,
                          modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                        };
                        break;
                      }
                      case "finish": {
                        stepUsage = chunk.usage;
                        stepFinishReason = chunk.finishReason;
                        stepProviderMetadata = chunk.providerMetadata;
                        const msToFinish = now2() - startTimestampMs;
                        doStreamSpan.addEvent("ai.stream.finish");
                        doStreamSpan.setAttributes({
                          "ai.response.msToFinish": msToFinish,
                          "ai.response.avgOutputTokensPerSecond": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                        });
                        break;
                      }
                      case "file": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "source": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "tool-input-start": {
                        activeToolCallToolNames[chunk.id] = chunk.toolName;
                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];
                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {
                          await tool2.onInputStart({
                            toolCallId: chunk.id,
                            messages: stepInputMessages,
                            abortSignal,
                            experimental_context
                          });
                        }
                        controller.enqueue({
                          ...chunk,
                          dynamic: (tool2 == null ? void 0 : tool2.type) === "dynamic"
                        });
                        break;
                      }
                      case "tool-input-end": {
                        delete activeToolCallToolNames[chunk.id];
                        controller.enqueue(chunk);
                        break;
                      }
                      case "tool-input-delta": {
                        const toolName = activeToolCallToolNames[chunk.id];
                        const tool2 = tools == null ? void 0 : tools[toolName];
                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {
                          await tool2.onInputDelta({
                            inputTextDelta: chunk.delta,
                            toolCallId: chunk.id,
                            messages: stepInputMessages,
                            abortSignal,
                            experimental_context
                          });
                        }
                        controller.enqueue(chunk);
                        break;
                      }
                      case "error": {
                        controller.enqueue(chunk);
                        stepFinishReason = "error";
                        break;
                      }
                      case "raw": {
                        if (includeRawChunks2) {
                          controller.enqueue(chunk);
                        }
                        break;
                      }
                      default: {
                        const exhaustiveCheck = chunkType;
                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                      }
                    }
                  },
                  // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                  async flush(controller) {
                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                    try {
                      doStreamSpan.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.response.finishReason": stepFinishReason,
                            "ai.response.text": {
                              output: () => activeText
                            },
                            "ai.response.toolCalls": {
                              output: () => stepToolCallsJson
                            },
                            "ai.response.id": stepResponse.id,
                            "ai.response.model": stepResponse.modelId,
                            "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                            "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                            "ai.usage.inputTokens": stepUsage.inputTokens,
                            "ai.usage.outputTokens": stepUsage.outputTokens,
                            "ai.usage.totalTokens": stepUsage.totalTokens,
                            "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                            "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                            // standardized gen-ai llm span attributes:
                            "gen_ai.response.finish_reasons": [stepFinishReason],
                            "gen_ai.response.id": stepResponse.id,
                            "gen_ai.response.model": stepResponse.modelId,
                            "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                            "gen_ai.usage.output_tokens": stepUsage.outputTokens
                          }
                        })
                      );
                    } catch (error46) {
                    } finally {
                      doStreamSpan.end();
                    }
                    controller.enqueue({
                      type: "finish-step",
                      finishReason: stepFinishReason,
                      usage: stepUsage,
                      providerMetadata: stepProviderMetadata,
                      response: {
                        ...stepResponse,
                        headers: response == null ? void 0 : response.headers
                      }
                    });
                    const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                    await stepFinish.promise;
                    const clientToolCalls = stepToolCalls.filter(
                      (toolCall) => toolCall.providerExecuted !== true
                    );
                    const clientToolOutputs = stepToolOutputs.filter(
                      (toolOutput) => toolOutput.providerExecuted !== true
                    );
                    if (clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):
                    clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:
                    !await isStopConditionMet({
                      stopConditions,
                      steps: recordedSteps
                    })) {
                      responseMessages.push(
                        ...toResponseMessages({
                          content: (
                            // use transformed content to create the messages for the next step:
                            recordedSteps[recordedSteps.length - 1].content
                          ),
                          tools
                        })
                      );
                      try {
                        await streamStep({
                          currentStep: currentStep + 1,
                          responseMessages,
                          usage: combinedUsage
                        });
                      } catch (error46) {
                        controller.enqueue({
                          type: "error",
                          error: error46
                        });
                        self2.closeStream();
                      }
                    } else {
                      controller.enqueue({
                        type: "finish",
                        finishReason: stepFinishReason,
                        totalUsage: combinedUsage
                      });
                      self2.closeStream();
                    }
                  }
                })
              )
            );
          }
          await streamStep({
            currentStep: 0,
            responseMessages: [],
            usage: {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            }
          });
        }
      }).catch((error46) => {
        self2.addStream(
          new ReadableStream({
            start(controller) {
              controller.enqueue({ type: "error", error: error46 });
              controller.close();
            }
          })
        );
        self2.closeStream();
      });
    }
    get steps() {
      this.consumeStream();
      return this._steps.promise;
    }
    get finalStep() {
      return this.steps.then((steps) => steps[steps.length - 1]);
    }
    get content() {
      return this.finalStep.then((step) => step.content);
    }
    get warnings() {
      return this.finalStep.then((step) => step.warnings);
    }
    get providerMetadata() {
      return this.finalStep.then((step) => step.providerMetadata);
    }
    get text() {
      return this.finalStep.then((step) => step.text);
    }
    get reasoningText() {
      return this.finalStep.then((step) => step.reasoningText);
    }
    get reasoning() {
      return this.finalStep.then((step) => step.reasoning);
    }
    get sources() {
      return this.finalStep.then((step) => step.sources);
    }
    get files() {
      return this.finalStep.then((step) => step.files);
    }
    get toolCalls() {
      return this.finalStep.then((step) => step.toolCalls);
    }
    get staticToolCalls() {
      return this.finalStep.then((step) => step.staticToolCalls);
    }
    get dynamicToolCalls() {
      return this.finalStep.then((step) => step.dynamicToolCalls);
    }
    get toolResults() {
      return this.finalStep.then((step) => step.toolResults);
    }
    get staticToolResults() {
      return this.finalStep.then((step) => step.staticToolResults);
    }
    get dynamicToolResults() {
      return this.finalStep.then((step) => step.dynamicToolResults);
    }
    get usage() {
      return this.finalStep.then((step) => step.usage);
    }
    get request() {
      return this.finalStep.then((step) => step.request);
    }
    get response() {
      return this.finalStep.then((step) => step.response);
    }
    get totalUsage() {
      this.consumeStream();
      return this._totalUsage.promise;
    }
    get finishReason() {
      this.consumeStream();
      return this._finishReason.promise;
    }
    /**
    Split out a new stream from the original stream.
    The original stream is replaced to allow for further splitting,
    since we do not know how many times the stream will be split.
    
    Note: this leads to buffering the stream content on the server.
    However, the LLM results are expected to be small enough to not cause issues.
       */
    teeStream() {
      const [stream1, stream2] = this.baseStream.tee();
      this.baseStream = stream2;
      return stream1;
    }
    get textStream() {
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part }, controller) {
              if (part.type === "text-delta") {
                controller.enqueue(part.text);
              }
            }
          })
        )
      );
    }
    get fullStream() {
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part }, controller) {
              controller.enqueue(part);
            }
          })
        )
      );
    }
    async consumeStream(options) {
      var _a162;
      try {
        await consumeStream({
          stream: this.fullStream,
          onError: options == null ? void 0 : options.onError
        });
      } catch (error46) {
        (_a162 = options == null ? void 0 : options.onError) == null ? void 0 : _a162.call(options, error46);
      }
    }
    get experimental_partialOutputStream() {
      if (this.output == null) {
        throw new NoOutputSpecifiedError();
      }
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ partialOutput }, controller) {
              if (partialOutput != null) {
                controller.enqueue(partialOutput);
              }
            }
          })
        )
      );
    }
    toUIMessageStream({
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning = true,
      sendSources = false,
      sendStart = true,
      sendFinish = true,
      onError = getErrorMessage
    } = {}) {
      const responseMessageId = generateMessageId != null ? getResponseUIMessageId({
        originalMessages,
        responseMessageId: generateMessageId
      }) : void 0;
      const toolNamesByCallId = {};
      const isDynamic = (toolCallId) => {
        var _a162, _b8;
        const toolName = toolNamesByCallId[toolCallId];
        const dynamic = ((_b8 = (_a162 = this.tools) == null ? void 0 : _a162[toolName]) == null ? void 0 : _b8.type) === "dynamic";
        return dynamic ? true : void 0;
      };
      const baseStream = this.fullStream.pipeThrough(
        new TransformStream({
          transform: async (part, controller) => {
            const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });
            const partType = part.type;
            switch (partType) {
              case "text-start": {
                controller.enqueue({
                  type: "text-start",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "text-delta": {
                controller.enqueue({
                  type: "text-delta",
                  id: part.id,
                  delta: part.text,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "text-end": {
                controller.enqueue({
                  type: "text-end",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "reasoning-start": {
                controller.enqueue({
                  type: "reasoning-start",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "reasoning-delta": {
                if (sendReasoning) {
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: part.id,
                    delta: part.text,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                break;
              }
              case "reasoning-end": {
                controller.enqueue({
                  type: "reasoning-end",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "file": {
                controller.enqueue({
                  type: "file",
                  mediaType: part.file.mediaType,
                  url: `data:${part.file.mediaType};base64,${part.file.base64}`
                });
                break;
              }
              case "source": {
                if (sendSources && part.sourceType === "url") {
                  controller.enqueue({
                    type: "source-url",
                    sourceId: part.id,
                    url: part.url,
                    title: part.title,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                if (sendSources && part.sourceType === "document") {
                  controller.enqueue({
                    type: "source-document",
                    sourceId: part.id,
                    mediaType: part.mediaType,
                    title: part.title,
                    filename: part.filename,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                break;
              }
              case "tool-input-start": {
                toolNamesByCallId[part.id] = part.toolName;
                const dynamic = isDynamic(part.id);
                controller.enqueue({
                  type: "tool-input-start",
                  toolCallId: part.id,
                  toolName: part.toolName,
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "tool-input-delta": {
                controller.enqueue({
                  type: "tool-input-delta",
                  toolCallId: part.id,
                  inputTextDelta: part.delta
                });
                break;
              }
              case "tool-call": {
                toolNamesByCallId[part.toolCallId] = part.toolName;
                const dynamic = isDynamic(part.toolCallId);
                if (part.invalid) {
                  controller.enqueue({
                    type: "tool-input-error",
                    toolCallId: part.toolCallId,
                    toolName: part.toolName,
                    input: part.input,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                    ...dynamic != null ? { dynamic } : {},
                    errorText: onError(part.error)
                  });
                } else {
                  controller.enqueue({
                    type: "tool-input-available",
                    toolCallId: part.toolCallId,
                    toolName: part.toolName,
                    input: part.input,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                    ...dynamic != null ? { dynamic } : {}
                  });
                }
                break;
              }
              case "tool-result": {
                const dynamic = isDynamic(part.toolCallId);
                controller.enqueue({
                  type: "tool-output-available",
                  toolCallId: part.toolCallId,
                  output: part.output,
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...part.preliminary != null ? { preliminary: part.preliminary } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "tool-error": {
                const dynamic = isDynamic(part.toolCallId);
                controller.enqueue({
                  type: "tool-output-error",
                  toolCallId: part.toolCallId,
                  errorText: onError(part.error),
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "error": {
                controller.enqueue({
                  type: "error",
                  errorText: onError(part.error)
                });
                break;
              }
              case "start-step": {
                controller.enqueue({ type: "start-step" });
                break;
              }
              case "finish-step": {
                controller.enqueue({ type: "finish-step" });
                break;
              }
              case "start": {
                if (sendStart) {
                  controller.enqueue({
                    type: "start",
                    ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},
                    ...responseMessageId != null ? { messageId: responseMessageId } : {}
                  });
                }
                break;
              }
              case "finish": {
                if (sendFinish) {
                  controller.enqueue({
                    type: "finish",
                    finishReason: part.finishReason,
                    ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}
                  });
                }
                break;
              }
              case "abort": {
                controller.enqueue(part);
                break;
              }
              case "tool-input-end": {
                break;
              }
              case "raw": {
                break;
              }
              default: {
                const exhaustiveCheck = partType;
                throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
              }
            }
            if (messageMetadataValue != null && partType !== "start" && partType !== "finish") {
              controller.enqueue({
                type: "message-metadata",
                messageMetadata: messageMetadataValue
              });
            }
          }
        })
      );
      return createAsyncIterableStream(
        handleUIMessageStreamFinish({
          stream: baseStream,
          messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),
          originalMessages,
          onFinish,
          onError
        })
      );
    }
    pipeUIMessageStreamToResponse(response, {
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning,
      sendSources,
      sendFinish,
      sendStart,
      onError,
      ...init
    } = {}) {
      pipeUIMessageStreamToResponse({
        response,
        stream: this.toUIMessageStream({
          originalMessages,
          generateMessageId,
          onFinish,
          messageMetadata,
          sendReasoning,
          sendSources,
          sendFinish,
          sendStart,
          onError
        }),
        ...init
      });
    }
    pipeTextStreamToResponse(response, init) {
      pipeTextStreamToResponse({
        response,
        textStream: this.textStream,
        ...init
      });
    }
    toUIMessageStreamResponse({
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning,
      sendSources,
      sendFinish,
      sendStart,
      onError,
      ...init
    } = {}) {
      return createUIMessageStreamResponse({
        stream: this.toUIMessageStream({
          originalMessages,
          generateMessageId,
          onFinish,
          messageMetadata,
          sendReasoning,
          sendSources,
          sendFinish,
          sendStart,
          onError
        }),
        ...init
      });
    }
    toTextStreamResponse(init) {
      return createTextStreamResponse({
        textStream: this.textStream,
        ...init
      });
    }
  };
  var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
  var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
  var output_exports = {};
  __export2(output_exports, {
    object: () => object2,
    text: () => text
  });
  var text = () => ({
    type: "text",
    responseFormat: { type: "text" },
    async parsePartial({ text: text2 }) {
      return { partial: text2 };
    },
    async parseOutput({ text: text2 }) {
      return text2;
    }
  });
  var object2 = ({
    schema: inputSchema
  }) => {
    const schema = asSchema(inputSchema);
    return {
      type: "object",
      responseFormat: {
        type: "json",
        schema: schema.jsonSchema
      },
      async parsePartial({ text: text2 }) {
        const result = await parsePartialJson(text2);
        switch (result.state) {
          case "failed-parse":
          case "undefined-input":
            return void 0;
          case "repaired-parse":
          case "successful-parse":
            return {
              // Note: currently no validation of partial results:
              partial: result.value
            };
          default: {
            const _exhaustiveCheck = result.state;
            throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
          }
        }
      },
      async parseOutput({ text: text2 }, context) {
        const parseResult = await safeParseJSON({ text: text2 });
        if (!parseResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: could not parse the response.",
            cause: parseResult.error,
            text: text2,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        const validationResult = await safeValidateTypes({
          value: parseResult.value,
          schema
        });
        if (!validationResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text2,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        return validationResult.value;
      }
    };
  };
  var name152 = "AI_NoSuchProviderError";
  var marker152 = `vercel.ai.error.${name152}`;
  var symbol152 = Symbol.for(marker152);
  var _a152;
  _a152 = symbol152;
  var uiMessagesSchema = lazyValidator(
    () => zodSchema(
      external_exports.array(
        external_exports.object({
          id: external_exports.string(),
          role: external_exports.enum(["system", "user", "assistant"]),
          metadata: external_exports.unknown().optional(),
          parts: external_exports.array(
            external_exports.union([
              external_exports.object({
                type: external_exports.literal("text"),
                text: external_exports.string(),
                state: external_exports.enum(["streaming", "done"]).optional(),
                providerMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("reasoning"),
                text: external_exports.string(),
                state: external_exports.enum(["streaming", "done"]).optional(),
                providerMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("source-url"),
                sourceId: external_exports.string(),
                url: external_exports.string(),
                title: external_exports.string().optional(),
                providerMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("source-document"),
                sourceId: external_exports.string(),
                mediaType: external_exports.string(),
                title: external_exports.string(),
                filename: external_exports.string().optional(),
                providerMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("file"),
                mediaType: external_exports.string(),
                filename: external_exports.string().optional(),
                url: external_exports.string(),
                providerMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("step-start")
              }),
              external_exports.object({
                type: external_exports.string().startsWith("data-"),
                id: external_exports.string().optional(),
                data: external_exports.unknown()
              }),
              external_exports.object({
                type: external_exports.literal("dynamic-tool"),
                toolName: external_exports.string(),
                toolCallId: external_exports.string(),
                state: external_exports.literal("input-streaming"),
                input: external_exports.unknown().optional(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional()
              }),
              external_exports.object({
                type: external_exports.literal("dynamic-tool"),
                toolName: external_exports.string(),
                toolCallId: external_exports.string(),
                state: external_exports.literal("input-available"),
                input: external_exports.unknown(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.literal("dynamic-tool"),
                toolName: external_exports.string(),
                toolCallId: external_exports.string(),
                state: external_exports.literal("output-available"),
                input: external_exports.unknown(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.unknown(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                preliminary: external_exports.boolean().optional()
              }),
              external_exports.object({
                type: external_exports.literal("dynamic-tool"),
                toolName: external_exports.string(),
                toolCallId: external_exports.string(),
                state: external_exports.literal("output-error"),
                input: external_exports.unknown(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.string(),
                callProviderMetadata: providerMetadataSchema.optional()
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("input-streaming"),
                providerExecuted: external_exports.boolean().optional(),
                input: external_exports.unknown().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                approval: external_exports.never().optional()
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("input-available"),
                providerExecuted: external_exports.boolean().optional(),
                input: external_exports.unknown(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                approval: external_exports.never().optional()
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("approval-requested"),
                input: external_exports.unknown(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                approval: external_exports.object({
                  id: external_exports.string(),
                  approved: external_exports.never().optional(),
                  reason: external_exports.never().optional()
                })
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("approval-responded"),
                input: external_exports.unknown(),
                providerExecuted: external_exports.boolean().optional(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                approval: external_exports.object({
                  id: external_exports.string(),
                  approved: external_exports.boolean(),
                  reason: external_exports.string().optional()
                })
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("output-available"),
                providerExecuted: external_exports.boolean().optional(),
                input: external_exports.unknown(),
                output: external_exports.unknown(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                preliminary: external_exports.boolean().optional(),
                approval: external_exports.object({
                  id: external_exports.string(),
                  approved: external_exports.literal(true),
                  reason: external_exports.string().optional()
                }).optional()
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("output-error"),
                providerExecuted: external_exports.boolean().optional(),
                input: external_exports.unknown(),
                output: external_exports.never().optional(),
                errorText: external_exports.string(),
                callProviderMetadata: providerMetadataSchema.optional(),
                approval: external_exports.object({
                  id: external_exports.string(),
                  approved: external_exports.literal(true),
                  reason: external_exports.string().optional()
                }).optional()
              }),
              external_exports.object({
                type: external_exports.string().startsWith("tool-"),
                toolCallId: external_exports.string(),
                state: external_exports.literal("output-denied"),
                providerExecuted: external_exports.boolean().optional(),
                input: external_exports.unknown(),
                output: external_exports.never().optional(),
                errorText: external_exports.never().optional(),
                callProviderMetadata: providerMetadataSchema.optional(),
                approval: external_exports.object({
                  id: external_exports.string(),
                  approved: external_exports.literal(false),
                  reason: external_exports.string().optional()
                })
              })
            ])
          ).nonempty("Message must contain at least one part")
        })
      ).nonempty("Messages array must not be empty")
    )
  );

  // lib/federation.js
  var import_core8 = __toESM(require_dist2(), 1);
  console.log("[built-in-chat/federation] Setting up Module Federation container");
  var scope = "@wiki3-ai/built-in-chat";
  var sharedScope = null;
  async function importShared(pkg) {
    if (!sharedScope) {
      if (window.__webpack_share_scopes__ && window.__webpack_share_scopes__.default) {
        console.warn(`[built-in-chat] Using global __webpack_share_scopes__.default for ${pkg}`);
        sharedScope = window.__webpack_share_scopes__.default;
      } else {
        throw new Error(`[built-in-chat] Shared scope not initialized when requesting ${pkg}`);
      }
    }
    const versions = sharedScope[pkg];
    if (!versions) {
      throw new Error(`[built-in-chat] Shared module ${pkg} not found in shared scope. Available: ${Object.keys(sharedScope)}`);
    }
    const versionKeys = Object.keys(versions);
    if (versionKeys.length === 0) {
      throw new Error(`[built-in-chat] No versions available for ${pkg}`);
    }
    const version2 = versions[versionKeys[0]];
    const factory = version2?.get;
    if (typeof factory !== "function") {
      throw new Error(`[built-in-chat] Module ${pkg} has no factory function`);
    }
    let result = factory();
    if (result && typeof result.then === "function") {
      result = await result;
    }
    if (typeof result === "function") {
      result = result();
    }
    console.log(`[built-in-chat] Loaded ${pkg}:`, result);
    return result;
  }
  var container = {
    init: (scope2) => {
      console.log("[built-in-chat/federation] init() called, storing shared scope");
      sharedScope = scope2;
      return Promise.resolve();
    },
    get: async (module) => {
      console.log("[built-in-chat/federation] get() called for module:", module);
      console.log("[built-in-chat/federation] This means JupyterLite is requesting our plugin!");
      if (module === "./index" || module === "./extension") {
        return async () => {
          console.log("[built-in-chat/federation] ===== LOADING PLUGIN MODULE =====");
          console.log("[built-in-chat/federation] Loading plugins from shared scope...");
          const { BaseKernel, IKernelSpecs } = await importShared("@jupyterlite/kernel");
          const { Widget } = await importShared("@lumino/widgets");
          const { ReactWidget } = await importShared("@jupyterlab/apputils");
          const React = await importShared("react");
          const { HTMLSelect } = await importShared("@jupyterlab/ui-components");
          console.log("[built-in-chat/federation] Got BaseKernel from shared scope:", BaseKernel);
          class ChatHttpKernel {
            constructor(opts = {}) {
              this.model = (0, import_core8.builtInAI)();
              console.log("[ChatHttpKernel] Using Chrome built-in AI");
            }
            async send(prompt) {
              console.log("[ChatHttpKernel] Sending prompt to Chrome built-in AI:", prompt);
              const availability = await this.model.availability();
              if (availability === "unavailable") {
                throw new Error("Browser does not support Chrome built-in AI.");
              }
              if (availability === "downloadable" || availability === "downloading") {
                await this.model.createSessionWithProgress((report) => {
                  if (typeof window !== "undefined") {
                    window.dispatchEvent(new CustomEvent("builtinai:model-progress", { detail: report }));
                  }
                });
              }
              const result = await streamText({
                model: this.model,
                messages: [{ role: "user", content: prompt }]
              });
              let reply = "";
              for await (const chunk of result.textStream) {
                reply += chunk;
              }
              console.log("[ChatHttpKernel] Got reply from Chrome built-in AI:", reply);
              return reply;
            }
          }
          class BuiltInChatKernel extends BaseKernel {
            constructor(options) {
              super(options);
              const model = options.model;
              this.chat = new ChatHttpKernel({ model });
            }
            async executeRequest(content) {
              const code = String(content.code ?? "");
              try {
                const reply = await this.chat.send(code);
                this.publishExecuteResult(
                  {
                    data: { "text/plain": reply },
                    metadata: {},
                    // @ts-ignore
                    execution_count: this.executionCount
                  },
                  // @ts-ignore
                  this.parentHeader
                );
                return {
                  status: "ok",
                  // @ts-ignore
                  execution_count: this.executionCount,
                  payload: [],
                  user_expressions: {}
                };
              } catch (err) {
                const message = err?.message ?? String(err);
                this.publishExecuteError(
                  {
                    ename: "Error",
                    evalue: message,
                    traceback: []
                  },
                  // @ts-ignore
                  this.parentHeader
                );
                return {
                  status: "error",
                  // @ts-ignore
                  execution_count: this.executionCount,
                  ename: "Error",
                  evalue: message,
                  traceback: []
                };
              }
            }
            async kernelInfoRequest() {
              return {
                status: "ok",
                protocol_version: "5.3",
                implementation: "built-in-chat-kernel",
                implementation_version: "0.1.0",
                language_info: {
                  name: "markdown",
                  version: "0.0.0",
                  mimetype: "text/markdown",
                  file_extension: ".md"
                },
                banner: "Chrome built-in AI chat kernel",
                help_links: []
              };
            }
            async completeRequest(content) {
              return {
                status: "ok",
                matches: [],
                cursor_start: content.cursor_pos ?? 0,
                cursor_end: content.cursor_pos ?? 0,
                metadata: {}
              };
            }
            async inspectRequest(_content) {
              return { status: "ok", found: false, data: {}, metadata: {} };
            }
            async isCompleteRequest(_content) {
              return { status: "complete", indent: "" };
            }
            async commInfoRequest(_content) {
              return { status: "ok", comms: {} };
            }
            async historyRequest(_content) {
              return { status: "ok", history: [] };
            }
            async shutdownRequest(_content) {
              return { status: "ok", restart: false };
            }
            async inputReply(_content) {
            }
            async commOpen(_content) {
            }
            async commMsg(_content) {
            }
            async commClose(_content) {
            }
          }
          const builtInChatKernelPlugin = {
            id: "@wiki3-ai/built-in-chat:plugin",
            autoStart: true,
            // Match the official JupyterLite custom kernel pattern:
            // https://jupyterlite.readthedocs.io/en/latest/howto/extensions/kernel.html
            requires: [IKernelSpecs],
            activate: (app, kernelspecs) => {
              console.log("[built-in-chat] ===== ACTIVATE FUNCTION CALLED =====");
              console.log("[built-in-chat] JupyterLab app:", app);
              console.log("[built-in-chat] kernelspecs service:", kernelspecs);
              if (!kernelspecs || typeof kernelspecs.register !== "function") {
                console.error("[built-in-chat] ERROR: kernelspecs.register not available!");
                return;
              }
              try {
                kernelspecs.register({
                  spec: {
                    name: "built-in-chat",
                    display_name: "Built-in AI Chat",
                    language: "python",
                    argv: [],
                    resources: {}
                  },
                  create: async (options) => {
                    console.log("[built-in-chat] Creating BuiltInChatKernel instance", options);
                    return new BuiltInChatKernel(options);
                  }
                });
                console.log("[built-in-chat] ===== KERNEL REGISTERED SUCCESSFULLY =====");
                console.log("[built-in-chat] Kernel name: built-in-chat");
                console.log("[built-in-chat] Display name: Built-in AI Chat");
              } catch (error46) {
                console.error("[built-in-chat] ===== REGISTRATION ERROR =====", error46);
              }
              if (typeof document !== "undefined") {
                window.addEventListener("builtinai:model-progress", (ev) => {
                  const { progress: p, text: text2 } = ev.detail;
                  console.log(`[built-in-chat] Model progress: ${text2} (${Math.round((p ?? 0) * 100)}%)`);
                });
              }
            }
          };
          const plugins = [builtInChatKernelPlugin];
          console.log("[built-in-chat/federation] ===== PLUGIN CREATED SUCCESSFULLY =====");
          console.log("[built-in-chat/federation] Plugin ID:", builtInChatKernelPlugin.id);
          console.log("[built-in-chat/federation] Plugin autoStart:", builtInChatKernelPlugin.autoStart);
          console.log("[built-in-chat/federation] Returning plugins array:", plugins);
          const moduleExports = {
            __esModule: true,
            default: plugins
          };
          return moduleExports;
        };
      }
      throw new Error(`[built-in-chat/federation] Unknown module: ${module}`);
    }
  };
  window._JUPYTERLAB = window._JUPYTERLAB || {};
  window._JUPYTERLAB[scope] = container;
  console.log("[built-in-chat/federation] Registered Module Federation container for scope:", scope);
})();
