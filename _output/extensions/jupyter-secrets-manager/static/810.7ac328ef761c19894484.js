"use strict";(self.webpackChunkjupyter_secrets_manager=self.webpackChunkjupyter_secrets_manager||[]).push([[810],{810:(e,t,s)=>{s.r(t),s.d(t,{ISecretsManager:()=>l,InMemoryConnector:()=>u,LocalStorageConnector:()=>d,SecretsManager:()=>c,default:()=>g});var r,i=s(316),a=s(23),n=s(262),o=s(602);class c{constructor(e){var t;this._onInput=async e=>{var t;await this.storing,this._storing=new n.PromiseDelegate;const s=e.target,{namespace:i,id:a}=null!==(t=r.secretPath.get(s))&&void 0!==t?t:{};if(i&&a){const e=r.buildConnectorId(i,a);await this.ready,await r.set(e,{namespace:i,id:a,value:s.value})}this._storing.resolve()},this._ready=new n.PromiseDelegate,this._fieldsVisibilityChanged=new o.Signal(this),this._storing=new n.PromiseDelegate,this._storing.resolve(),r.setSecretFieldsVisibility(null!==(t=e.showSecretFields)&&void 0!==t&&t),!1===e.showSecretFields&&r.lockFieldsVisibility()}setConnector(e){r.setConnector(e),this._ready.resolve()}get ready(){return this._ready.promise}get storing(){return this._storing.promise}get fieldVisibilityChanged(){return this._fieldsVisibilityChanged}get secretFieldsVisibility(){return r.getSecretFieldsVisibility()}set secretFieldsVisibility(e){r.setSecretFieldsVisibility(e)&&this._fieldsVisibilityChanged.emit(r.getSecretFieldsVisibility())}async get(e,t,s){return r.checkNamespace(e,t),await Promise.all([this.ready,this.storing]),r.get(r.buildConnectorId(t,s))}async set(e,t,s,i){return r.checkNamespace(e,t),await this.ready,r.set(r.buildConnectorId(t,s),i)}async list(e,t){return r.checkNamespace(e,t),await Promise.all([this.ready,this.storing]),r.list(t)}async remove(e,t,s){return r.checkNamespace(e,t),await this.ready,r.remove(r.buildConnectorId(t,s))}async attach(e,t,s,i,a){r.checkNamespace(e,t);const n=r.buildConnectorId(t,s);r.inputs.get(n)&&this.detach(e,t,s),r.inputs.set(n,i),r.secretPath.set(i,{namespace:t,id:s});const o=await r.get(n);!i.value&&o?(i.value=o.value,i.dispatchEvent(new Event("input")),a&&a(o.value)):i.value&&i.value!==(null==o?void 0:o.value)&&(await this.ready,r.set(n,{namespace:t,id:s,value:i.value})),i.addEventListener("input",this._onInput)}async detach(e,t,s){r.checkNamespace(e,t),this._detach(r.buildConnectorId(t,s))}async detachAll(e,t){r.checkNamespace(e,t);for(const e of r.secretPath.values())e.namespace===t&&this._detach(r.buildConnectorId(e.namespace,e.id))}_detach(e){const t=r.inputs.get(e);t&&(t.removeEventListener("input",this._onInput),r.secretPath.delete(t),r.inputs.delete(e))}}Object.freeze(c.prototype),function(e){e.sign=function(e,t){const{lock:s,isLocked:i,namespaces:n,symbols:o}=r,{isDisabled:c}=a.PageConfig.Extension;if(i())throw new Error("Secrets manager is locked, check errors.");c("jupyter-secrets-manager:manager")&&(console.warn("Secrets manager is disabled."),s()),c(e)&&s(`Sign error: plugin ${e} is disabled.`),o.has(e)&&s(`Sign error: another plugin signed as "${e}".`);const l=r.OriginalSymbol(e),u=t(l);return e!==u.id&&s(`Sign error: plugin ID mismatch "${u.id}"â‰ "${e}".`),n.set(l,e),o.set(e,l),u}}(c||(c={})),function(e){let t;!function(e){const t=Object.getPrototypeOf(new Map).constructor,s=t.prototype.get,r=t.prototype.has,i=t.prototype.set,a=t.prototype.delete,n=t.prototype.clear,o=t.prototype.entries,c=t.prototype.keys,l=t.prototype.values,u=t.prototype.forEach;class d{constructor(e){this._map=Reflect.construct(t,e?[e]:[])}get(e){return s.call(this._map,e)}has(e){return r.call(this._map,e)}entries(){return o.call(this._map)}keys(){return c.call(this._map)}values(){return l.call(this._map)}forEach(e){return u.call(this._map,e)}set(e,t){return i.call(this._map,e,t),this}delete(e){return a.call(this._map,e)}clear(){n.call(this._map)}get size(){return this._map.size}[Symbol.iterator](){return o.call(this._map)}}e.SafeMap=d}(t||(t={}));let s=!1;function r(e){if(s=!0,e)throw new Error(e)}function i(){return s}e.OriginalSymbol=Symbol,e.namespaces=new t.SafeMap,e.symbols=new t.SafeMap,e.lock=r,e.isLocked=i,e.checkNamespace=function(t,s){if(i()||e.namespaces.get(t)!==s)throw new Error(`The secrets namespace ${s} is not available with the provided token`)};let a=null;e.setConnector=function(e){null!==a&&r("A secrets manager connector already exists."),a=e},e.get=async function(e){if(null==a?void 0:a.fetch)return a.fetch(e)},e.list=async function(e){if(null==a?void 0:a.list)return a.list(e)},e.set=async function(e,t){if(null==a?void 0:a.save)return a.save(e,t)},e.remove=async function(e){if(null==a?void 0:a.remove)return a.remove(e)};let n=!1;e.lockFieldsVisibility=function(){n=!0};let o=!1;e.getSecretFieldsVisibility=function(){return o},e.setSecretFieldsVisibility=function(e){return!n&&e!==o&&(o=e,!0)},e.inputs=new t.SafeMap,e.secretPath=new t.SafeMap,e.buildConnectorId=function(e,t){return`${e}:${t}`}}(r||(r={}));const l=new n.Token("jupyter-secret-manager:manager","The secrets manager");class u{constructor(){this._secrets=new Map}async fetch(e){return this._secrets.get(e)}async save(e,t){this._secrets.set(e,t)}async remove(e){this._secrets.delete(e)}async list(e){const t=[],s=[];return this._secrets.forEach(((r,i)=>{r.namespace===e&&(t.push(i),s.push(r))})),{ids:t,values:s}}}class d{constructor(){this.storage="jupyter-secrets:secrets",console.warn("\nThe secret connector used currently should not be used in production, since the\npasswords are stored as plain text in the local storage of the browser'\n    ")}async fetch(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");if(s&&s[e])return s[e]}async save(e,t){var s;const r=JSON.parse(null!==(s=localStorage.getItem(this.storage))&&void 0!==s?s:"{}");r[e]=t,localStorage.setItem(this.storage,JSON.stringify(r))}async remove(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");delete s[e],localStorage.setItem(this.storage,JSON.stringify(s))}async list(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");return Object.keys(s).filter((t=>s[t].namespace===e)).reduce(((e,t)=>(e.ids.push(t),e.values.push(s[t]),e)),{ids:[],values:[]})}}const h={id:"jupyter-secrets-manager:connector",description:"A JupyterLab extension to manage secrets.",autoStart:!0,requires:[l],activate:(e,t)=>{t.setConnector(new u)}},p={id:"jupyter-secrets-manager:manager",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:l,optional:[i.ISettingRegistry],activate:(e,t)=>{let s=!0;"false"===a.PageConfig.getOption("secretsManager-showFields")&&(s=!1);const r=new c({showSecretFields:s});return t.load(p.id).then((e=>{var t;if(!s)return void(null===(t=e.schema.properties)||void 0===t||delete t.ShowSecretFields);const i=()=>{var t;const s=null!==(t=e.get("ShowSecretFields").composite)&&void 0!==t&&t;r.secretFieldsVisibility=s};e.changed.connect((()=>i())),i()})).catch((e=>{console.error(`Failed to load settings for ${p.id}`,e)})),console.debug("JupyterLab extension jupyter-secrets-manager is activated!"),r}},g=[h,p]}}]);